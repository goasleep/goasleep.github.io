<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go类型</title>
      <link href="2021/06/19/%E5%90%8E%E7%AB%AF/Go/Go%E5%B9%B6%E5%8F%91/"/>
      <url>2021/06/19/%E5%90%8E%E7%AB%AF/Go/Go%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Go并发"><a href="#Go并发" class="headerlink" title="Go并发"></a>Go并发</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go的并发是指让某个函数独立于其他函数运行的能力。当函数创建为goroutine时，Go将会将其视为一个独立的工作单元。这个单元会通过Go调度器被调度到逻辑处理器上执行。</p><p>Go调度器能管理被创建的所有goroutine并为其分配执行时间。调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器运行goroutine。它能够在任何给定的时间，全面控制哪个goroutine在哪个逻辑处理器上运行。<strong>每个逻辑处理器都分别绑定在单个操作系统线程上。</strong></p><p>Go的并发模型来自于CSP(Communicatting Sequential Process) 通信顺序进程。它时一种消息模型，通过goroutine之间传递数据来传递消息。而不是通过对数据加锁来实现同步访问。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="执行系统IO"><a href="#执行系统IO" class="headerlink" title="执行系统IO"></a>执行系统IO</h4><p>如果创建一个goroutine并准备运行，这个goroutine就会被放到调度器的全局运行队列中，之后，就会为这个goroutine分配一个逻辑处理器，并被放到逻辑处理对应的本地队列中等待执行。</p><p>正在运行的goroutine要执行一个阻塞的系统调用，如果读文件的IO操作。线程和goroutine会从逻辑处理器上分离。该线程会继续阻塞，等待系统调用的返回。</p><p>与此同时，逻辑处理器就失去了用来运行的线程。所以调度器会创建一个新线程，并将其绑定在该逻辑处理器上。之后，调度器会选择本地运行队列里的另外一个goroutine来运行。</p><p>一旦被阻塞的系统调用执行完并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便后续可以继续使用。</p><h4 id="执行网络IO"><a href="#执行网络IO" class="headerlink" title="执行网络IO"></a>执行网络IO</h4><p>如果goroutine要做一个网络IO的调用。goroutine会和逻辑处理器分离(<strong>注意线程和逻辑处理器不分离</strong>)，并移到集成了网络轮询器的运行时。一旦轮询器指示某个网络读或者写操作就绪后，对应的goroutine就会重新分配到逻辑处理上完成操作。</p><blockquote><p>调度器创建的逻辑处理器没有限制，但是语言运行时默认限制每个程序最多创建10000个线程。</p></blockquote><p>一个goroutine在工作结束前，可以被停止并重新调度。调度器这么做的目的就是防止某个goroutine占用逻辑处理器的时间太长。此时，调度器会停止当前正在运行的goroutine，并给其他可运行的goroutine运行的机会.</p><p>go关键字修饰的函数，可以像普通的函数一样，传递参数进去，但是goroutine终止时，是无法获取函数的返回值的。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 分配1个逻辑处理器</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//wg 使用WaitGroup等待goroutine完成，类似于信号量</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupwg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start goroutine"</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 保证每个工作完成都调用wg.Done方法</span><span class="token keyword">for</span> count <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> count<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> char <span class="token operator">:=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> char <span class="token operator">&lt;</span> <span class="token string">'a'</span><span class="token operator">+</span><span class="token number">26</span><span class="token punctuation">;</span> char<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> char<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 后加括号表示立即调用</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> count <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> count<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> char <span class="token operator">:=</span> <span class="token string">'A'</span><span class="token punctuation">;</span> char <span class="token operator">&lt;</span> <span class="token string">'A'</span><span class="token operator">+</span><span class="token number">26</span><span class="token punctuation">;</span> char<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> char<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"wait for finish\n"</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"\n terminal"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>Go 提供了同步goroutine的机制，就是对共享资源加锁，可以使用atomic和sync包里面的函数实现顺序访问。</p><h3 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h3><p>原子函数能够以底层的加锁机制来同步访问整形变量和指针。</p><p>Atomic包提供类似于Java中Java中的原子操作。比如atomic.AddInt64等。<br>同时还提供原子读和原子写，LoadInt64和StoreInt64</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token string">"sync"</span><span class="token string">"sync/atomic"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>counter <span class="token builtin">int64</span>wg sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">increate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">increate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Final counter:"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">increate</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> count <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> count<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 原子添加</span>atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>counter<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 当前goroutine 从线程退出，并放回队列</span>runtime<span class="token punctuation">.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁用于在代码上创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>counter <span class="token builtin">int64</span>wg sync<span class="token punctuation">.</span>WaitGroup<span class="token comment">// 定义互斥锁</span>mutex sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">increate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">increate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Final counter:"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">increate</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> count <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> count<span class="token operator">++</span> <span class="token punctuation">&#123;</span>mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加锁</span><span class="token punctuation">&#123;</span>value <span class="token operator">:=</span> countervalue<span class="token operator">++</span>runtime<span class="token punctuation">.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>counter <span class="token operator">=</span> value<span class="token punctuation">&#125;</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 释放锁</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h2><p>Go中，可以使用原子函数和互斥锁来保证对共享资源的安全访问和消除竞争状态，还可以使用通过，通过发送和接收需要共享的资源，在goroutine之间做同步。</p><p>Channel又分有缓存的通道和无缓存的通道。</p><ul><li>无缓存通道(unbuffered channel)要求发送goroutie和接收goroutine同时准备好，才能发送发送和接收操作。如果有两者没有准备好，通道会导致先执行发送或者接收操作的goroutine进行阻塞。这种交互行为时同步的</li><li>有缓存通道(buffered channel)是在被接受前能存储一个或者多个值的通道。它不强制要求goroutine之间完成发送和接收。只有通道中没有接收的值时，接收动作才会被阻塞。或者通道没有缓存区容纳被发送的值，发送动作才会阻塞。</li></ul><p>对于有缓存的通道，当通道关闭后，goroutine 依旧可以从通道中接收数据，但是不允许向通道发送数据。这样能够保证通道关闭后，不会有数据丢失。如果通道内没有数据，则会返回立即返回通道类型的零值，或者获取值时加入可选标志，得到通道信息。</p><h3 id="通道的使用"><a href="#通道的使用" class="headerlink" title="通道的使用"></a>通道的使用</h3><p>在使用通道过程中，<strong>箭头指向接收的变量</strong><br>同时，当通道不再用的时候，需要对通道进行关闭</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 声明无缓存的通道</span>count <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 声明有缓存的通道</span>count1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 从通道中添加值</span>count <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token comment">// 从通道中取值</span>value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>count<span class="token comment">// 关闭通道,必须要记得关闭</span><span class="token function">clost</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go类型</title>
      <link href="2021/06/17/%E5%90%8E%E7%AB%AF/Go/Go%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/06/17/%E5%90%8E%E7%AB%AF/Go/Go%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Go类型"><a href="#Go类型" class="headerlink" title="Go类型"></a>Go类型</h1><h2 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h2><p>声明一个类型的时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。声明后与内置类型的运作方式类型。</p><blockquote><p>需要注意得是，不同类型即使相互兼容，但是也不能相互赋值</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义一个新的类型</span><span class="token keyword">type</span> user <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    name       <span class="token builtin">string</span>    email      <span class="token builtin">string</span>    ext        <span class="token builtin">int</span>    privileged <span class="token builtin">bool</span><span class="token punctuation">&#125;</span><span class="token comment">// 类型可以嵌套</span><span class="token keyword">type</span> admin <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    persion user    level   <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化与赋值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 默认值为新类型里属性对应的默认值</span><span class="token keyword">var</span> bill userfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>bill<span class="token punctuation">)</span><span class="token comment">//类型创建并初始化</span>newUser <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span>       <span class="token string">"smith"</span><span class="token punctuation">,</span>email<span class="token punctuation">:</span>      <span class="token string">"smith@example.com"</span><span class="token punctuation">,</span>ext<span class="token punctuation">:</span>        <span class="token number">0</span><span class="token punctuation">,</span>privileged<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser<span class="token punctuation">)</span><span class="token comment">//类型创建并初始化的另外一种方式,需要注意值得顺序</span>newUser2 <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@example.com"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法能给用户定义得类型添加新的行为。</p><p>在定义方法的时候，关键字func和函数名之间的参数被称作为接受者，将函数与接受者的类型绑定在一起。如果一个函数有接受者，那么这个函数就被称作为方法。</p><p>Go中有两种接受者： 值接受者和指针接收者。</p><p>如果使用值接收者，那么调用时会使用这个值的一个副本来执行</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> user <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name       <span class="token builtin">string</span>email      <span class="token builtin">string</span>ext        <span class="token builtin">int</span>privileged <span class="token builtin">bool</span><span class="token punctuation">&#125;</span><span class="token comment">// 为user添加修改名字的方法，值接受者</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u user<span class="token punctuation">)</span> <span class="token function">changeName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>u<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">&#125;</span><span class="token comment">// 指针接受者</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>user<span class="token punctuation">)</span> <span class="token function">changeEmail</span><span class="token punctuation">(</span>email <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>u<span class="token punctuation">.</span>email <span class="token operator">=</span> email<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，值接受者使用值得副本来调用方法，而指针接受者使用实际的值调用方法，也可以使用一个值来调用使用指针接受者声明的方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newUser<span class="token punctuation">.</span><span class="token function">changeName</span><span class="token punctuation">(</span><span class="token string">"smith1"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser<span class="token punctuation">)</span>    <span class="token comment">//(&amp;newUser).changeEmail("smith1@example.com"),两者是等价的</span>newUser<span class="token punctuation">.</span><span class="token function">changeEmail</span><span class="token punctuation">(</span><span class="token string">"smith1@example.com"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newUser<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">changeEmail</span><span class="token punctuation">(</span><span class="token string">"smith2@example.com"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser<span class="token punctuation">)</span>newUser4 <span class="token operator">:=</span> <span class="token operator">&amp;</span>user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@example.com"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>newUser4<span class="token punctuation">.</span><span class="token function">changeName</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newUser4<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么时候使用指针接受者，什么时候使用值接受者"><a href="#什么时候使用指针接受者，什么时候使用值接受者" class="headerlink" title="什么时候使用指针接受者，什么时候使用值接受者"></a>什么时候使用指针接受者，什么时候使用值接受者</h3><p>首先需要明白如果给某个类型增加或者删除某个值，是要修改当前值，还是更新当前值？如果是要创建一个新值，该类型的方法就使用值接受者，如果要修改当前值，就使用指针接受者。</p><p><strong>原则是不要关注某个方法如何处理值，而是关注这个值的本质是什么</strong></p><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><h4 id="何时使用值类型"><a href="#何时使用值类型" class="headerlink" title="何时使用值类型"></a>何时使用值类型</h4><p>1.如果接受者是一个 map，func 或者 chan，使用值类型(因为它们本身就是引用类型)。<br>2.如果接受者是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。<br>3.如果接受者是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接受者是一个简单地基本类型像是 int 和 string，使用值类型就好了。</p><p>一个值类型的接受者可以减少一定数量的垃圾生成，如果一个值被传入一个值类型接受者的方法，一个栈上的拷贝会替代在堆上分配内存(但不是保证一定成功)，所以在没搞明白代码想干什么之前，别因为这个原因而选择值类型接受者。</p><h4 id="何时使用指针类型"><a href="#何时使用指针类型" class="headerlink" title="何时使用指针类型"></a>何时使用指针类型</h4><p>1.如果方法需要修改接受者，接受者必须是指针类型。<br>2.如果接受者是一个包含了 sync.Mutex 或者类似同步字段的结构体，接受者必须是指针，这样可以避免拷贝。<br>3.如果接受者是一个大的结构体或者数组，那么指针类型接受者更有效率。(多大算大呢？假设把接受者的所有元素作为参数传给方法，如果你觉得参数有点多，那么它就是大)。<br>4.从此方法中并发的调用函数和方法时，接受者可以被修改吗？一个值类型的接受者当方法调用时会创建一份拷贝，所以外部的修改不能作用到这个接受者上。如果修改必须被原始的接受者可见，那么接受者必须是指针类型。<br>5.如果接受者是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接受者，这样会增加程序的可读性</p><p>当你看完这个还是有疑虑，还是<strong>不知道该使用哪种接受者，那么记住使用指针接受者</strong>。</p><p>是使用值接受者还是指针接受者，不应该由该方法是否修改了接收到的值来决定。这个决策应该基于该类型的本质。<br>只有一个例外，需要让类型值复合某个接口的时候，即便类型的本质是非原始的，也可以选择使用值接受者声明方法。这样做完全复合调用方法的机制。<br>ref：<a href="https://www.136.la/tech/show-933792.html">https://www.136.la/tech/show-933792.html</a></p><h2 id="类型的本质"><a href="#类型的本质" class="headerlink" title="类型的本质"></a>类型的本质</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><ul><li>数值类型</li><li>字符串类型</li><li>布尔类型</li></ul><p>内置类型的本质是原始类型。<br>对于内置类型，对这些值进行增加或者删除的时候，会创建新值，把这些类型的值传递给方法或者函数的时候，应该传递一个对应值的副本。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>切片</li><li>映射</li><li>通道</li><li>接口</li><li>函数类型</li></ul><p>引用类型创建的变量成为标头值。每个标头值包含一个指向底层数据结构的指针。因此通过复制一个引用类型的值的副本，本质上就是在共享底层数据结构。<br>每个引用类型还包含足以独特的字段，用于管理底层数据结构。<strong>标头值是为了复制而设计的，所以永远不要共享一个引用类型的值</strong>。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>结构类型用来描述一组数据值，这组值得本质可以是原始的，也可以是非原始的。</p><h2 id="嵌入类型"><a href="#嵌入类型" class="headerlink" title="嵌入类型"></a>嵌入类型</h2><p>嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型成为新的外部类型的内部类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> user <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name  <span class="token builtin">string</span>email <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> admin <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>user <span class="token comment">// 内嵌</span>level <span class="token builtin">string</span><span class="token punctuation">&#125;</span>user1 <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@email.com"</span><span class="token punctuation">&#125;</span>ad <span class="token operator">:=</span> admin<span class="token punctuation">&#123;</span>user<span class="token punctuation">:</span>  user1<span class="token punctuation">,</span>level<span class="token punctuation">:</span> <span class="token string">"super"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ad<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内部类型的提升</strong>：对于外部类型来说，内部类型总是存在的。这就意味着，虽然没有指定内部类型对应的字段名，还是可以使用内部类型的类型名来范文内部类型的值。<br>即下面两者是等价的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ad<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//smith</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ad<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//smith</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样的，对于接口的值而言，因为内部类型的提升，内部类型实现的接口会自动地提升到外部类型，因此外部类型也同样实现了这个接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义接口</span><span class="token keyword">type</span> notifier <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 内部类型实现接口</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>user<span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"user interface name:%s email:%s\n"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>name<span class="token punctuation">,</span> u<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 外部类型使用内部类型地接口</span>ad<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">//user interface name:smith email:smith@email.com</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果外部类型同样实现同样的接口或者使用同样的变量，内部类型就不会得到提升。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//重新定义admin</span><span class="token keyword">type</span> admin <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>useremail <span class="token builtin">string</span> <span class="token comment">// 与user有同样的字段</span><span class="token punctuation">&#125;</span><span class="token comment">// admin实现接口</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>admin<span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Admin interface name:%s email:%s\n"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>name<span class="token punctuation">,</span> u<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>user1 <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@email.com"</span><span class="token punctuation">&#125;</span>ad <span class="token operator">:=</span> admin<span class="token punctuation">&#123;</span>user<span class="token punctuation">:</span>  user1<span class="token punctuation">,</span>email<span class="token punctuation">:</span> <span class="token string">"super@test.com"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 同样的字段或者变量，内部类型不会得到提升</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ad<span class="token punctuation">.</span>email<span class="token punctuation">)</span>      <span class="token comment">//super@test.com</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ad<span class="token punctuation">.</span>user<span class="token punctuation">.</span>email<span class="token punctuation">)</span> <span class="token comment">//smith@email.com</span>ad<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Admin interface name:smith email:super@test.com</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意一点是，<strong>即便内部类型是未公开的，内部类型声明的字段是公开的。那么这些公共字段也可以通过外部类型去访问</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go接口</title>
      <link href="2021/06/15/%E5%90%8E%E7%AB%AF/Go/Go%E6%8E%A5%E5%8F%A3/"/>
      <url>2021/06/15/%E5%90%8E%E7%AB%AF/Go/Go%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h1><p>多态是指带么可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</p><p>接口时用来定义行为的类型，这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。</p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口值时一个两个字长度的数据结构。</p><ul><li>第一个字包含了一个指向内部表的指针。这个内部表叫做iTable,包含了所存储值的类型信息以及与这个值相关的方法。</li><li>第二个字包含时一个指向所存储值的指针。将类型信息和指针组合在一起。</li></ul><p>下面时对于值和指针赋值后接口值得简图<br><img src="/images/Go%E5%AE%9E%E4%BD%93%E5%80%BC%E8%B5%8B%E5%80%BC%E5%90%8E%E6%8E%A5%E5%8F%A3%E5%80%BC%E5%BE%97%E7%AE%80%E5%9B%BE.png" alt="Go实体值赋值后接口值得简图"><br><img src="/images/Go%E5%AE%9E%E4%BD%93%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%90%8E%E6%8E%A5%E5%8F%A3%E5%80%BC%E7%9A%84%E7%AE%80%E5%9B%BE.png" alt="Go实体指针赋值后接口值的简图"></p><p>值调用</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//定义接口</span><span class="token keyword">type</span> notifier <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> user <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name  <span class="token builtin">string</span>email <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token comment">// 值实现接口的方法</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u user<span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>name <span class="token operator">+</span> u<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 接口方法的调用</span><span class="token keyword">func</span> <span class="token function">sendNotification</span><span class="token punctuation">(</span>n notifier<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>n<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>u <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@email.com"</span><span class="token punctuation">&#125;</span><span class="token function">sendNotification</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针调用</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>user<span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>name <span class="token operator">+</span> u<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>u <span class="token operator">:=</span> <span class="token operator">&amp;</span>user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@email.com"</span><span class="token punctuation">&#125;</span><span class="token function">sendNotification</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，使用指针接受者的实现方法，不能被以值得方式调用。即如下调用是无法通过编译的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>user<span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>name <span class="token operator">+</span> u<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//无法通过编译</span>u <span class="token operator">:=</span> user<span class="token punctuation">&#123;</span><span class="token string">"smith"</span><span class="token punctuation">,</span> <span class="token string">"smith@email.com"</span><span class="token punctuation">&#125;</span><span class="token function">sendNotification</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><h3 id="为什么无法通过值来使用指针接受者的实现方法？"><a href="#为什么无法通过值来使用指针接受者的实现方法？" class="headerlink" title="为什么无法通过值来使用指针接受者的实现方法？"></a>为什么无法通过值来使用指针接受者的实现方法？</h3><p>方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接受者的类型决定了这个方法是关联到值还是关联到指针，还是两个都关联。</p><p>对于Go而言，对于值T实现的方法，</p><ul><li>T类型的值的方法集只包含值接受者声明的方法。</li><li>而指向T类型的指针的方法集即包含值接受者声明的方法，也包含指针接受者声明的方法。</li></ul><p>从接受者的视角看，</p><ul><li>使用指针接受者来实现一个接口，那么只有指向那个类型的指针才能实现对应的接口。</li><li>使用值接受者来实现一个接口，那么那个类型的值和指针都能偶实现对应的接口。</li></ul><p><img src="/images/Go%E6%96%B9%E6%B3%95%E9%9B%86%E8%A7%84%E5%88%99.png" alt="Go方法集规则"></p><h3 id="为什么会有无法通过值来使用指针接受者的实现方法这种限制？"><a href="#为什么会有无法通过值来使用指针接受者的实现方法这种限制？" class="headerlink" title="为什么会有无法通过值来使用指针接受者的实现方法这种限制？"></a>为什么会有无法通过值来使用指针接受者的实现方法这种限制？</h3><p><strong>事实上，编译器并不是总能自动获得一个值的地址。所以值的方法集只包括了使用值接受者实现的方法。</strong></p><p>为什么编译器并不总能获取到一个值的地址？</p><ul><li>不能获取到地址，说明对于Go来讲，这个值是不可寻址的。不可寻址可以理解为不可修改或者是寻址没有意义。</li><li>对于常量而言，没法取指针是合理的，如果常量能取到指针，那就意味着可以修改，也就不能叫常量了。</li><li>同样map元素的也是不可寻址的，主要有两个原因：<ul><li>如果对象不存在，返回零值，零值是不可变对象。因此不可寻址</li><li>如果对象存在，又因为元素的地址是可以变化的。因此寻址结果没有意义</li></ul></li><li>字符串中的字符/字节又不能寻址是因为字符串是不可变的<br>参考：<a href="https://colobu.com/2018/02/27/go-addressable/">https://colobu.com/2018/02/27/go-addressable/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go数组、切片和映射</title>
      <link href="2021/06/07/%E5%90%8E%E7%AB%AF/Go/%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/"/>
      <url>2021/06/07/%E5%90%8E%E7%AB%AF/Go/%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组，切片和映射"><a href="#数组，切片和映射" class="headerlink" title="数组，切片和映射"></a>数组，切片和映射</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明数组必须指定数据类型和数组的长度，而且其不可改变<br>数组的每个元素都初始化为对应变量的零值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//声明数组，必须指定数据类型和存储元素的数量</span><span class="token keyword">var</span> varArray <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">// 声明并初始化</span>varArray2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token comment">// 初始化的长度由初始化的值来决定</span>varArray3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>varArray3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 6</span><span class="token comment">// 通过索引使用数组</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>varArray<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 0</span><span class="token comment">//复制数组，内存空间会复制。编译器会阻止不同类型复制</span>varArray4 <span class="token operator">:=</span> varArray2varArray4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>varArray2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//4</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>varArray4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//20</span><span class="token comment">// 多维数组</span><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// [12 13]</span><span class="token comment">// 可以指定下标</span><span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>array1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// [12 13]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是围绕动态数组构建的，可以按需增大或者缩小。切片的动态数组是通过内置的append来实现。append也可以用来合并两个切片。</p><blockquote><p>如果在[] 运算符里指定了一个值，那么创建的就是数组而不是切片。反之，创建的则时切片。</p></blockquote><p>切片之所以称为切片，是因为创建一个新的切片就是把底层数组切出一部分。同时注意切片只能访问其长度内的元素。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//切片操作，底层共享</span>newSlice <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>newSlice1 <span class="token operator">:=</span> newSlice<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 对于容量为k的[i:j]的切片，长度为j-i，容量为k - i</span>newSlice1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>newSlice1<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newSlice<span class="token punctuation">)</span>  <span class="token comment">// [1 2 3 60 5 6]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newSlice1<span class="token punctuation">)</span> <span class="token comment">//[2 3 60]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免上述现象，可以使用第三个变量控制新切片的容量。其目的不是为了增加容量，是为了限制容量.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newSlice2 <span class="token operator">:=</span> newSlice<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>newSlice2 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>newSlice2<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newSlice<span class="token punctuation">)</span> <span class="token comment">// [1 2 3 60 5 6]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newSlice2<span class="token punctuation">)</span> <span class="token comment">// [2 3 70]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片的操作"><a href="#切片的操作" class="headerlink" title="切片的操作"></a>切片的操作</h3><p>可以使用append对两个切片进行合并。</p><p>可以使用for range对切片进行遍历。<strong>range创建了每个元素的副本，而不是直接返回该元素的引用。</strong>因此，一个迭代过程中切片返回变量的地址总是相同，即&amp;value的地址是相同的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">   <span class="token comment">// 切片合并</span>newSlice3 <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>newSlice1<span class="token punctuation">,</span> newSlice2<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newSlice3<span class="token punctuation">)</span> <span class="token comment">// [2 3 60 2 3 70]</span>   <span class="token comment">//切片的遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> newSlice3 <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"index is %d, value is %d, ElemAdrr is %X, ValueAdrr is %X \n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>newSlice3<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/**index is 0, value is 2, ElemAdrr is C000010230, ValueAdrr is C0000141A0index is 1, value is 3, ElemAdrr is C000010238, ValueAdrr is C0000141A0index is 2, value is 60, ElemAdrr is C000010240, ValueAdrr is C0000141A0index is 3, value is 2, ElemAdrr is C000010248, ValueAdrr is C0000141A0index is 4, value is 3, ElemAdrr is C000010250, ValueAdrr is C0000141A0index is 5, value is 70, ElemAdrr is C000010258, ValueAdrr is C0000141A0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片的容量策略"><a href="#切片的容量策略" class="headerlink" title="切片的容量策略"></a>切片的容量策略</h3><ul><li>当元素个数小于1024，则增长因子为2,以2的倍数增长</li><li>当元素个数多余1024，则增长因子为1.25.</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> capSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">511</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>capSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 512</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>capSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1024</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">525</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>capSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>capSlice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1280</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是一种数据结构，用户存储一些列的无序的键值对。底层使用的是散列表。</p><p>映射的散列表包含一组桶，在存储、删除或者查找键值对的时候，所有操作都要先选择一个桶，把操作映射时指定的键传到映射的散列函数，就能选中对应的桶。</p><p>映射使用两个数据结构来存储数据。一个数据结构时数组，内部存储的时用于选择桶的高八位，用于区分每个键值对要存在哪个桶里。另外一个数据结构时字节数组，用于存储键值对。该字节数组先依次存储了这个桶的所有键，之后依次存储这个桶里的所有值，这种实现可以减少每个桶所需的内存。</p><blockquote><p>映射的键可以是内置的类型，也可以是结构类型。只要这个值可以使用==运算符做比较。<strong>但是对于切片、函数以及包含切片的结构类型这些类型具有引用语义，不能作为映射的键</strong>。</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 创建映射，键的类型是string，值的类型是int</span>dict <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>dict1 <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>value<span class="token punctuation">,</span> exists <span class="token operator">:=</span> dict1<span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">]</span>   <span class="token comment">// 第一个返回值表示值，第二个返回值表示这个键是否存在</span>value1<span class="token punctuation">,</span> exists1 <span class="token operator">:=</span> dict1<span class="token punctuation">[</span><span class="token string">"eee"</span><span class="token punctuation">]</span> <span class="token comment">// 如果不存在键，value返回默认零值</span>value2 <span class="token operator">:=</span> dict1<span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">]</span>          <span class="token comment">// 只有一个参数的时候返回值</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>exists<span class="token punctuation">,</span> value<span class="token punctuation">)</span>      <span class="token comment">//true 1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>exists1<span class="token punctuation">,</span> value1<span class="token punctuation">)</span>    <span class="token comment">//false 0</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span>             <span class="token comment">// 1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token comment">//使用内置delete()删除值</span><span class="token function">delete</span><span class="token punctuation">(</span>dict1<span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">)</span><span class="token comment">//迭代映射</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> dict1 <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"key is %s, value is %d\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/**key is blue, value is 2*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer对应题</title>
      <link href="2021/06/04/leetcode%E9%A2%98%E8%A7%A3/%E5%89%91%E6%8C%87offer%E7%BA%AA%E5%BF%B5%E7%89%88/"/>
      <url>2021/06/04/leetcode%E9%A2%98%E8%A7%A3/%E5%89%91%E6%8C%87offer%E7%BA%AA%E5%BF%B5%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode对应题"><a href="#Leetcode对应题" class="headerlink" title="Leetcode对应题"></a>Leetcode对应题</h2><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">面试题3：二维数组中的查找</a><br><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">面试题4：替换空格</a><br><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">面试题5：从尾到头打印链表</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">面试题6：重建二叉树</a><br><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">面试题7： 用两个栈实现队列</a><br><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">面试题8：旋转数组的最小数字</a><br><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">面试题9-1：斐波那契数列</a><br><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">面试题9-2：青蛙跳台阶问题</a><br><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">面试题10：二进制中1的个数</a><br><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">面试题11：数值的整数次方</a></p><h2 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">面试题5：从尾到头打印链表</a><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">面试题13：删除链表的节点</a><br><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">面试题15:链表中倒数第k个节点</a><br><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">面试题16:反转链表</a><br><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">面试题17:合并两个排序的链表</a><br><a href="">面试题26</a><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">面试题27：二叉搜索树与双向链表</a><br><a href="">面试题37</a><br><a href="">面试题45</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><a href="">面试题39</a><br><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">面试题18: 树的子结构</a><br><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">面试题25：二叉树中和为某一值的路径</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">面试题6：重建二叉树</a><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">面试题24：二叉搜索树的后序遍历序列</a><br><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题23:从上到下打印二叉树</a><br><a href="">面试题50</a><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">面试题27：二叉搜索树与双向链表</a><br><a href="">面试题30</a></p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">面试题:栈的压入、弹出序列</a><br><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">面试题21:包含min函数的栈</a><br><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题23:从上到下打印二叉树</a><br><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">面试题7： 用两个栈实现队列</a></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="">面试题35</a></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">面试题24：二叉搜索树的后序遍历序列</a><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">面试题27：二叉搜索树与双向链表</a><br><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">面试题19:二叉树的镜像</a></p><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">面试题8：旋转数组的最小数字</a><br><a href="">面试题38</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">面试题29: 数组中出现次数超过一半的数字</a><br><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">面试题30: 最小的k个数</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">面试题9-1：斐波那契数列</a><br><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">面试题9-2：青蛙跳台阶问题</a><br><a href="">面试题43</a></p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">面试题12:打印从1到最大的n位数</a><br><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">面试题28：字符串的排列</a></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><a href="">面试题10</a><br><a href="">面试题40</a><br><a href="">面试题47</a></p><h3 id="大数相关"><a href="#大数相关" class="headerlink" title="大数相关"></a>大数相关</h3><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">面试题12:打印从1到最大的n位数</a></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">面试题14:调整数组顺序使奇数位于偶数前面</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/23/%E5%90%8E%E7%AB%AF/Go/Go%E7%8E%AF%E5%A2%83/"/>
      <url>2021/05/23/%E5%90%8E%E7%AB%AF/Go/Go%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>环境搭建<br><a href="https://blog.csdn.net/AdolphKevin/article/details/105480530">https://blog.csdn.net/AdolphKevin/article/details/105480530</a></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><pre class="line-numbers language-none"><code class="language-none">go mod init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre class="line-numbers language-none"><code class="language-none">go mod tidy <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="构建和删除"><a href="#构建和删除" class="headerlink" title="构建和删除"></a>构建和删除</h2><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">go build&#x2F;clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">go vet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">go fmt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/05/22/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/22/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>主要解决：主要解决接口选择的问题。<br>何时使用：我们明确地计划不同条件下创建不同实例时。<br>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。<br>使用场景：</p><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时</li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>主要解决：一个全局使用的类频繁地创建与销毁。<br>何时使用：当您想控制实例数目，节省系统资源的时候<br>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br>使用场景：要求生产唯一序列号，创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br>何时使用：一些基本部件不会变，而其组合经常变化的时候。<br>如何解决：将变与不变分离开。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>主要解决：在运行期建立和删除原型。<br>如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p>何时使用： </p><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><p>使用场景： </p><ol><li>资源优化场景。</li><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </li><li>性能和安全要求的场景。 </li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。 </li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li><li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</li></ol><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>主要解决：常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。是作为两个不兼容的接口之间的桥梁。<br>何时使用：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式<br>如何解决：继承或依赖（推荐）</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化<br>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。<br>如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合</p><h3 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h3><p>这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次<br>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦<br>何时使用： </p><ol><li>您想表示对象的部分-整体层次结构（树形结构）。</li><li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br>如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。</li></ol><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器允许向一个现有的对象添加新的功能，同时又不改变其结构。<br>主要解决：我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br>如何解决：将具体功能职责划分，同时继承装饰者模式。<br>何时使用： </p><ol><li>扩展一个类的功能</li><li>动态增加功能，动态撤销</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口<br>主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br>何时使用：</p><ol><li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可</li><li>定义系统的入口<br>如何解决：客户端不与系统耦合，外观类与系统耦合。<br>使用场景：</li><li>为复杂的模块或子系统提供外界访问的模块</li></ol><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。运用共享技术有效地支持大量细粒度的对象。<br>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。<br>如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。<br>使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能<br>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br>何时使用：想在访问一个类时做一些控制。<br>如何解决：增加中间层。实现与被代理的组合类</p><h2 id="行为性设计模式"><a href="#行为性设计模式" class="headerlink" title="行为性设计模式"></a>行为性设计模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦<br>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br>如何解决：拦截的类都实现统一接口。<br>使用场景： </p><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令<br>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。<br>如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者<br>使用场景：认为是命令的地方都可以使用命令模式</li></ol><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br>主要解决：对于一些固定文法构建一个解释句子的解释器。<br>如何解决：构建语法树，定义终结符与非终结符。</p><p>使用场景： </p><ol><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 </li><li>一些重复出现的问题可以用一种简单的语言来进行表达。 </li><li>一个简单语法需要解释的场景。</li></ol><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。它支持以不同的方式遍历一个聚合对象。<br>主要解决：不同的方式来遍历整个整合对象。<br>如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。<br>使用场景： </p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li><li>需要为聚合对象提供多种遍历方式。 </li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ol><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合<br>主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br>何时使用：多个类相互耦合，形成了网状结构。<br>如何解决：将上述网状结构分离为星型结构。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br>主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br>何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃<br>如何解决：通过一个备忘录类专门存储对象状态。<br>使用场景： </p><ol><li>需要保存/恢复数据的相关状态场景。</li><li>提供一个可回滚的操作。</li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。<br>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的<br>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。<br>何时使用：代码中包含大量与对象状态有关的条件语句。<br>如何解决：将各种具体的状态类抽象出来</p><h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><p>一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法<br>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。<br>使用场景： </p><ol><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。 </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行<br>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。<br>如何解决：将这些通用算法抽象出来。<br>何时使用：有一些通用的方法。<br>使用场景： </li><li>有多个子类共有的方法，且逻辑相同。</li><li>重要的、复杂的方法，可以考虑作为模板方法。<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3>我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。<br>主要解决：稳定的数据结构和易变的操作耦合问题<br>如何解决：在被访问的类里面加一个对外提供接待访问者的接口。<br>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br>使用场景： </li><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ol><p>注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><h2 id="J2EE设计模式"><a href="#J2EE设计模式" class="headerlink" title="J2EE设计模式"></a>J2EE设计模式</h2><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="适配器和桥接的区别"><a href="#适配器和桥接的区别" class="headerlink" title="适配器和桥接的区别"></a>适配器和桥接的区别</h3><ol><li>从意图上看<br>适配器是为了复用已有接口的功能，而通过适配将已有接口功能引入到所需接口的一种模式，目的是能够结合。桥接模式是为了实现两个接口结合的多样化而设计的一种模式，目的是结合的更好。</li><li>从实现上看<br>适配器是先定义了新接口，然后才与旧接口进行适配，即先接口后关系。<br>桥接模式是先定义了一个桥（即两个接口之间的关系），然后通过每个接口的多个实现的不同组合达到其灵活性的目的，即先关系后组合。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go入门</title>
      <link href="2021/05/22/%E5%90%8E%E7%AB%AF/Go/Go%E5%BC%80%E7%AF%87/"/>
      <url>2021/05/22/%E5%90%8E%E7%AB%AF/Go/Go%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h1><p>离开一门舒服、掌握熟练的语言，去学习一门不仅对自己来说，对整个世界来说都是全新的，是需要勇气的。这是一条人迹罕见，沿途充满了Bug，只有少数先行者熟悉的路。这里充满了意外，文档不明确或者丢失，而且缺少可以拿来即用的代码库。这是拓荒者、先锋者才会选择的道路。                   —–《Go in Action》</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量名是以小写开头的，对于小写开头的变量是不公开的。对于大写字母开头是公开的。即小写开头变量仅对包可以见，不能被其他包的中的代码访问。<br>但是也可以通过一个函数返回不公开的值获取。</p><p>Go中，所有变量都默认初始化为零值。数值类型默认为0，字符串类型默认为空字符串，布尔值默认为false，指针默认为nil</p><p>创建引用类型需要使用make()来构造，如make(map[string]Matcher),类似于创建Java 中的Map&lt;String,Matcher&gt;</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>range可以迭代数组、字符串、切片、映射和通道。每次迭代会返回元素的索引以及元素值得副本。如果某些变量我们并不需要，可以使用下划线代替将其忽略</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>可以在匿名函数里面访问外部变量，一般访问共享变量</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>自己实现函数，最好保证函数有返回值，并且也有错误返回。如果发生了错误，永远不要使用函数返回的另一个值。尽量遵守这个准则，保证含义足够明确</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>每一个.go文件，都应该在第一行声明自己所属的包。每个包都应该在单独一个目录中，不要将多个包放入到同一个目录，也不要将同一个包的文件拆分到多个不同目录中。<br>同一个目录的下.go文件必须声明同一个包名</p><p>给包命名应该使用简洁、清晰且<strong>全小写</strong>的形式</p><h3 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h3><p>所以Go语言编译的可执行程序都比如有一个名为main的包。同时当编译器发现包名为main的时候，必须也要有main函数，不然编译器不会创建可执行文件。<br>编译时，会将main包所在代码所在的目录的目录名作为二进制可执行文件的文件名。</p><p>如果不是main包，则编译器认为这就是一个包，而不是命令。</p><blockquote><p>Go中经常使用命令来指代可执行文件。命令时可执行的，而包只是作为予以上的功能单元</p></blockquote><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>go：启动一个goroutine。如go func(){}<br>defer：安排随后的函数调用在函数返回时才执行, 如 defer func(){}</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li><p>当要写的代码属于某个包时，好的实践时使用与代码所在文件夹一样的名字作为包名。</p></li><li><p>将工厂函数命名为New时Go语言的一个习惯，这个New函数做的事情：它创建一个未公开的类型的值，并把这个值返回给调用者</p></li></ul><h2 id="goroutine和-channal"><a href="#goroutine和-channal" class="headerlink" title="goroutine和 channal"></a>goroutine和 channal</h2><p>gouroutine是可以和其他goroutine并行执行的函数，同时也会和主程序并行执行</p><p>channal是一种数据结果，能够让goroutine之间进行安全的数据通信</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/21/middleware/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B7%AE%E5%BC%82/"/>
      <url>2021/05/21/middleware/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列对比"><a href="#消息队列对比" class="headerlink" title="消息队列对比"></a>消息队列对比</h2><p>主流MQ包括：kafka、ActiveMQ、RabbitMQ和RocketMQ</p><p>常见的MQ其实就上面的四种</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td><td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td><td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td>10万级1这是kafka最大的优点，就是吞吐量高。一般配置和数据类的系统进行实时数据计算、日志采集等场景</td></tr><tr><td>时效性</td><td>ms级</td><td>微妙级，这是RabbitMQ的一大特点，就是延迟最低</td><td>ms级</td><td>延迟在ms级内</td></tr><tr><td>可用性</td><td>基于主从架构实现高可用</td><td>高，基于主从架构实现高可用</td><td>非常高，分布式架构</td><td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机后，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>消息不丢失</td><td>经过参数优化配置，可以做到0丢失</td><td>经过参数优化配置可以做到0丢失</td></tr><tr><td>核心特点</td><td>MQ领域的功能及其完备</td><td>基于Erlang开发，所以并发能力强，性能及其好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时上的标准。</td></tr><tr><td></td><td>非常成熟，功能强大，在业内大量公司以及项目都有应用。  但是偶尔消息丢失的概率，并且现在社区以及国内应用都越来越少，官方社区对ActiveMQ5.X维护越来越少，而且确实主要是基于解耦和异步来用的，较少在大规模吞吐场景中使用</td><td>erlang语言开发的，性能及其好，延时很低。而且开源的版本，就提供的管理界面非常棒，在国内一些互联网公司近几年用RabbitMQ也是比较多一些，特别适用于中小型的公司 缺点显而易见，就是吞吐量会低一些，这是因为它做的实现机制比较中，因为使用erlang开发，目前没有多少公司使用其开发。所以针对源码界别的定制，非常困难，因此公司的掌控非常弱，只能依赖于开源社区的维护。</td><td>接口简单易用，毕竟在阿里大规模应用过，有阿里平台保障，日处理消息上 百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是OK的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。</td><td>仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，分布式可以任意扩展。    同时kafka最好是支撑较少的topic数量即可，保证其超高的吞吐量。</td></tr></tbody></table><h2 id="为什么Kafka的吞吐量这么高？"><a href="#为什么Kafka的吞吐量这么高？" class="headerlink" title="为什么Kafka的吞吐量这么高？"></a>为什么Kafka的吞吐量这么高？</h2><ol><li>基于磁盘的顺序读写。磁盘的顺序读写性能高于内存随机读写。kafka的消息不断地追加到本地磁盘的末尾，而不是随机写入</li><li>利用了系统本身的Page cache。即利用操作系统本身的内存，而不是JVM的内存。这样避免了Object的消耗和CG问题。通过Page Cache，kafka的读写操作基本是基于内存的</li><li>零拷贝。Page Cache 结合 sendfile 方法，Kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。</li><li>分区分段+索引。topic中的数据暗道一个个的分区存储到不同的broker节点。而分区实际上又是segment分段存储的。因此kafka的message实际上分布式存储在一个个segment中，每次文件操作也是直接操作segment的。同时kafka又为每一个分段的数据文件建立索引。不仅提升数据读取效率，还提高数据处理的并行度</li><li>批量读写。kafka数据读写是批量的而不是单条的。写入数据时，可以采用批次写入。这样避免网络上频繁传输单个消息带来的延迟和带宽开销</li><li>批量压缩。在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。进行数据压缩会消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑。<ol><li>采取批量压缩，而不是每条message都压缩</li><li>kafka支持多压缩协议</li></ol></li></ol><p>kafka速度的秘诀在于：<strong>它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I/O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合sendfile直接暴力输出。</strong>，同样也因为如此，kafka的时效性并不高，不过也在ms以内<br>(<a href="https://www.cnblogs.com/18800105616a/p/13863254.html">https://www.cnblogs.com/18800105616a/p/13863254.html</a>)</p><h2 id="为什么RabbitMQ随着队列的堆积导致吞吐量降低？"><a href="#为什么RabbitMQ随着队列的堆积导致吞吐量降低？" class="headerlink" title="为什么RabbitMQ随着队列的堆积导致吞吐量降低？"></a>为什么RabbitMQ随着队列的堆积导致吞吐量降低？</h2><p><a href="https://www.freesion.com/article/7358885921/">https://www.freesion.com/article/7358885921/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="2021/05/20/%E5%90%8E%E7%AB%AF/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/05/20/%E5%90%8E%E7%AB%AF/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>为什么需要使用线程池？线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：线程复用、控制最大并发数、管理线程</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="Java线程池"></p><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断<ol><li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li><li>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程来运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：<ol><li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</li></ol></li></ol><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p>corePoolSize：核心线程数，线程池中的常驻核心线程数，最小线程数量。<br>maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1<br>keepAliveTime：多余的空闲线程存活时间。针对超过corePollSize数量的线程<br>unit：keepAliveTime的单位<br>workQueue：任务队列，被提交但是没有被执行的任务<br>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可<br>handler：拒绝策略，表示当<strong>队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize）</strong>时，如何来拒绝请求执行的Runnable的策略</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li>CPU密集型任务配置尽可能少的线程数量。一般：CPU核数 + 1个线程数</li><li>IO密集型任务尽可能配置多的线程数量。参考公式：CPU核数 / (1 - 阻塞系数)  阻塞系数在0.8 ~ 0.9左右。比如8核CPU配置80个线程数量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁</title>
      <link href="2021/05/19/%E5%90%8E%E7%AB%AF/Java/Java%E9%94%81/"/>
      <url>2021/05/19/%E5%90%8E%E7%AB%AF/Java/Java%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>是指多个线程按照申请锁的顺序来获取锁。先来后到，先来先服务，就是公平的，也就是队列</p><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建公平锁</span><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 构造参数默认或者是false为非公平锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><p>递归锁指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p><p>ReentrantLock/ Synchronized 都是递归锁</p><h2 id="自旋锁-spinLock"><a href="#自旋锁-spinLock" class="headerlink" title="自旋锁(spinLock)"></a>自旋锁(spinLock)</h2><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>自旋锁的原理就是 CAS(compare and swap)</p><h2 id="独占锁-写锁-共享锁-读锁-互斥锁"><a href="#独占锁-写锁-共享锁-读锁-互斥锁" class="headerlink" title="独占锁(写锁) / 共享锁(读锁) / 互斥锁"></a>独占锁(写锁) / 共享锁(读锁) / 互斥锁</h2><p>独占锁： 该锁一次只能被一个线程所持有，ReentrantLock和Synchronized 都是独占锁<br>共享锁： 该锁可以被多个线程所持有</p><p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReentrantReadWriteLock</span> reentrantReadWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reentrantReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>作用：允许一个或者多个线程等待其他线程完成操作<br>使用场景：多个线程同时执行不同的操作，当所有线程完成后，输出完成<br>实现原理：CountDownLatch设置一个计数器，每当执行countDown方法的时候，计数器就会减一，当计数器为0的时候，就调用await方法被阻塞的线程会被唤醒，继续执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 计数器</span>        <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//唤醒</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>作用：让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障，屏障才会打开，所有被屏障拦截的进程才会继续运行<br>使用场景：多个进程进行并行计算，需要得到当前所有的进程的结果，才能进行下一步计算。<br>实现原理：CyclicBarrier会设置一个目标数值和达到目标后需要执行的方法。每次调用CyclicBarrier的await方法时，CyclicBarrier的实际数值就会加一，当实际数值与目标相等时，就会调用目标方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法         */</span>        <span class="token class-name">CyclicBarrier</span> cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">final</span> <span class="token class-name">Integer</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br>使用场景：做流量控制<br>实现原理：Semaphore设置一个目标值，表示有这么多个令牌。当线程要访问公共资源的时候，需要先通过acquire方法获取令牌才能访问。当不需要的时候，通过release方法归还令牌。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 获取令牌</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//释放令牌</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>作用：用于进行线程间的数据交换<br>使用场景：遗传算法<br>实现原理：通过提供一个同步点，在这个同步点。两个线程可以通过exchange方法交换数据。如果第一个线程执行exchange()方法，那么它会等第二个线程也执行exchange()方法。当两个线程都到达同步点时，交换数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> nameExchanger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> exchange <span class="token operator">=</span> nameExchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"   "</span> <span class="token operator">+</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> exchange <span class="token operator">=</span> nameExchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"   "</span> <span class="token operator">+</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><ol><li>synchronized属于JVM层面，属于java的关键字,Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li><li>synchronized底层是通过monitor对象来完成，wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法</li><li>synchronized不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用。ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</li><li>synchronized：不可中断，除非抛出异常或者正常运行完成。而ReentrantLock是可中断，可以设置超时方法，或者调用interrupt() 方法中断</li><li>synchronized是非公平锁。ReentrantLock默认是非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li><li>synchronized：没有，要么随机，要么全部唤醒线程。ReentrantLock用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><ul><li>互斥：可以通过将互斥的共享资源封装成可同时访问</li><li>占有并等待：要求进程必须一次性申请到所有资源，不占有任何资源</li><li>非抢占式：如果进程不能立即分配资源，要求它不占有任何其他资源，只有同时获取所有资源时，才执行分配动作</li><li>循环等待：对资源进行排序，要求进程按照顺序请求资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器</title>
      <link href="2021/05/18/%E5%90%8E%E7%AB%AF/Java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2021/05/18/%E5%90%8E%E7%AB%AF/Java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>新生代收集器：Serial、ParNew、Parallel Scavenge；<br>老年代收集器：Serial old、Parallel old、CMS；<br>整堆收集器：G1；</p><p><img src="/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="垃圾回收器"></p><h2 id="Serial收集器：串行回收"><a href="#Serial收集器：串行回收" class="headerlink" title="Serial收集器：串行回收"></a>Serial收集器：串行回收</h2><p>Serial收集器采用<strong>复制算法</strong>、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p><p>特点：这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优点：<br>简单而高效，对于单CPU环境而言，Serial收集器没有线程交互的开销</p><p><img src="/images/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p><h2 id="ParNew收集器：并行回收"><a href="#ParNew收集器：并行回收" class="headerlink" title="ParNew收集器：并行回收"></a>ParNew收集器：并行回收</h2><p>ParNew收集器则是serial收集器的多线程版本。采用<strong>复制算法</strong>、并行回收和”stop-the-World”机制的方式执行内存回收。除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</p><h2 id="Parallel-Scavenge收集器：吞吐量优先"><a href="#Parallel-Scavenge收集器：吞吐量优先" class="headerlink" title="Parallel Scavenge收集器：吞吐量优先"></a>Parallel Scavenge收集器：吞吐量优先</h2><p>Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</li></ul><p>在JDK1.6时提供了用于执行老年代垃圾收集的Parallel old收集器，用来代替老年代的serial old收集器。<br>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p>Parallel收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><p><img src="/images/Parallel%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel收集器"></p><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong></p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p><strong>CMS的垃圾收集算法采用标记-清除算法</strong>，并且也会”stop-the-world”，使用空闲列表执行内存分配</p><p>触发CG是时候：当堆内存使用率达到某一定的阈值时，便开始垃圾回收。由此需要保证在垃圾回收的时候，还有内存空间支持应用程序运行</p><p>处理流程：</p><ol><li><strong>初始标记</strong>（Initial-Mark）阶段：程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因<strong>用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ol><p>尽管CMS收集器采用的是并发回收（非独占式），但是<strong>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，<strong>CMS收集器是当堆内存使用率达到某一阈值时，便开始进行回收。因此需要确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行</strong>。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>缺点：</p><ul><li>会产生内存随便，导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发FullGC</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</li><li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><p><img src="/images/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p><h2 id="G1收集器：区域化分代式"><a href="#G1收集器：区域化分代式" class="headerlink" title="G1收集器：区域化分代式"></a>G1收集器：区域化分代式</h2><p>G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。它是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p><img src="/images/G1%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="G1内存区域"></p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，主要用于存储大对象，如果超过1.5个region，就放到Humongous内存区域。</p><p>优点：</p><ul><li>并行：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。</li><li>并发：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li><li>分代收集：<ul><li>它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>它同时兼顾年轻代和老年代</li></ul></li><li>空间整合：G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片</li><li>可预测的停顿时间模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li></ul></li></ul><p>缺点：<br>G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>适用场景：<br>面向服务端应用，针对具有大内存、多处理器的机器</p><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p><img src="/images/G1%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png" alt="G1回收流程"></p><h4 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h4><p>先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p>回收过程</p><ol><li>扫描根节点</li><li>更新Remembered Set：跟新后，Remembered Set可以准确的反映老年代对所在的内存分段中对象的引用。</li><li>处理Remembered Set：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li>复制对象：，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li><li>处理引用：处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h4 id="并发标记过程"><a href="#并发标记过程" class="headerlink" title="并发标记过程"></a>并发标记过程</h4><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h4 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h4><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。</p><h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：<br>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E6%AF%94.png" alt="垃圾回收器对比"></p><h2 id="垃圾回收优化的方向"><a href="#垃圾回收优化的方向" class="headerlink" title="垃圾回收优化的方向"></a>垃圾回收优化的方向</h2><p>避免FullGC</p><ul><li>减少扫描的区域，如通过维护列表</li><li>减少STW的时间：并行并发标记</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/16/%E5%90%8E%E7%AB%AF/Java/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/05/16/%E5%90%8E%E7%AB%AF/Java/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java对象分配</title>
      <link href="2021/05/15/%E5%90%8E%E7%AB%AF/Java/Java%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
      <url>2021/05/15/%E5%90%8E%E7%AB%AF/Java/Java%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><h2 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h2><ol><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）</li><li>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件</li><li>果没有找到文件，则抛出ClassNotFoundException异常，</li><li>如果找到，则进行类加载，并生成对应的Class对象。</li></ol><h2 id="对象内存分配过程"><a href="#对象内存分配过程" class="headerlink" title="对象内存分配过程"></a>对象内存分配过程</h2><p>在分配之前，首先先会计算对象占用空间的大小，接着在堆中划分一块内存给新对象。（如果允许使用栈上分配，并且符合栈上分配的条件，则在栈上进行分配。）</p><ul><li>如果内存规整，则使用指针碰撞法。指针碰撞法意思就是放一个指针作为分界点，使用过的内存放在一边，空闲的放在另外一边。分配内存时调整指针的位置即可。</li><li>如果内存不规整，则需要维护一个空闲列表记录可用的内存块来为对象分配内存。</li></ul><p>使用哪种方式是由堆是否规整所决定，而是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="/images/Java%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="Java对象分配过程"></p><h3 id="对象在栈上分配的过程"><a href="#对象在栈上分配的过程" class="headerlink" title="对象在栈上分配的过程"></a>对象在栈上分配的过程</h3><p>基本思想：将线程私有的对象打散分配在栈上<br>栈上分配是基于逃逸分析和标量替换实现的。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。标量替换是将聚合对象(非原始数据类型)，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。<br>比如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Point</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"point.x"</span> <span class="token operator">+</span> point<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">";point.y"</span> <span class="token operator">+</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会被替换成</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"point.x = "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"; point.y="</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象在TLAB分配的过程"><a href="#对象在TLAB分配的过程" class="headerlink" title="对象在TLAB分配的过程"></a>对象在TLAB分配的过程</h3><p><img src="/images/TLAB%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="TLAB分配过程"><br>TLAB是从内存模型的角度，为Eden区继续划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。<br>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p>若要分配的对象在TLAB中不足有多余空间分配，那么会有两种分配策略</p><ul><li>废弃当前的TLAB</li><li>将这个30KB的对象直接分配到堆上，保留当前TLAB</li></ul><h3 id="对象在堆上的分配过程"><a href="#对象在堆上的分配过程" class="headerlink" title="对象在堆上的分配过程"></a>对象在堆上的分配过程</h3><ol><li>new的对象先放Eden园区。此区有大小限制。</li><li>当Eden园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden园区进行垃圾回收（MinorGC），将Eden园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden园区</li><li>然后将Eden园中的剩余对象移动到Survivorv0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到Survivorv0区的，如果没有回收，就会放到Survivorv1区。</li><li>如果再次经历垃圾回收，此时会重新放回Survivorv0区，接着再去Survivorv1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。或者是Survivor慢后，将会触发一些规则，直接去到老年区</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><p><img src="/images/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="对象在堆上的分配过程"></p><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行init方法进行初始化。在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p><img src="/images/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Java对象创建过程"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM方法调用</title>
      <link href="2021/05/14/%E5%90%8E%E7%AB%AF/Java/JVM%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>2021/05/14/%E5%90%8E%E7%AB%AF/Java/JVM%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM方法调用"><a href="#JVM方法调用" class="headerlink" title="JVM方法调用"></a>JVM方法调用</h1><p>方法调用的本质是根据方法的符号引用确定方法的直接引用</p><h2 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h2><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h2 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h2><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p>如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区域</title>
      <link href="2021/05/13/%E5%90%8E%E7%AB%AF/Java/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>2021/05/13/%E5%90%8E%E7%AB%AF/Java/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h1><p><img src="/images/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84.png" alt="JVM运行时数据区的"></p><ul><li>每个线程：独立包括程序计数器、Java栈(虚拟机栈)、本地栈(Native Method Stack)。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol><li>程序计数器是一块很小的内存区域，也是运行速度最快的存储区域。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能。节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li><li>任何时间一个线程只有一个方法执行，程序计数器会存储当前线程正在执行的Java的JVM指令地址。如果是再执行native的方法，则是未指定值</li><li>是Java虚拟机规范中没有规定OOM的情况的区域</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。<br>特点：</p><ul><li>虚拟机栈是线程私有的。生命周期与线程的生命周期保持一致</li><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>只有入栈和出现两个动作</li><li>对于栈不存在垃圾回收问题，但是也可以会出现栈溢出并抛出异常(无限递归可以导致栈溢出)</li><li>可以通过-xss来设置JVM虚拟机栈的大小</li></ul><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><ol><li>每个线程都有自己的栈，<strong>栈中的数据都是以栈帧（Stack Frame）的格式存在</strong>。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息，包括类和对象，类中的field和method</li><li>在同一线程的同一时间点，只有一个活动的栈帧，称之为当前栈帧，与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。<br><img src="/images/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="JVM虚拟机栈"></li></ol><h4 id="栈帧的运行原理"><a href="#栈帧的运行原理" class="headerlink" title="栈帧的运行原理"></a>栈帧的运行原理</h4><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧之中引用另外一个线程的栈帧。</strong></p><p>如果当前方法调用了其他方法，方法返回之际，<strong>当前栈帧会传回此方法的执行结果给前一个栈帧</strong>，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h4 id="栈帧的存储内容"><a href="#栈帧的存储内容" class="headerlink" title="栈帧的存储内容"></a>栈帧的存储内容</h4><ul><li>局部变量表(local variables):局部变量数组或本地变量表</li><li>操作数栈(operation stack):</li><li>动态链接</li><li>方法返回地址</li><li>附加信息</li></ul><p><img src="/images/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%B8%A7.png" alt="JVM虚拟机栈帧"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul><li>在局部变量表中，存储的基本单元式Slot(变量槽), Slot可以存放基本数据类型、引用类型和returnAddress类型的变量(指向字节码的指针)。</li><li>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，因此如果需要访问局部变量表的64bit的局部变量时，只需要使用前一个索引即可。</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的Slot处。</li><li>Slot是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的局部变量就有可能会服用过期的局部变量的Slot，从而节省资源。</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>每一个独立的栈帧除了包含局部变量表以外，还包含操作数栈，也可以称之为表达式栈（Expression Stack）</p><ul><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li>栈中的任何一个元素都是可以任意的Java数据类型。而32bit的类型占用一个栈单位深度<br>4bit的类型占用两个栈单位深度</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li></ul><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成:调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</li><li>出现未处理的异常，非正常退出:返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li></ul><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。<br>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈用于管理本地方法的调用</p><h3 id="本地方法-Native-Method"><a href="#本地方法-Native-Method" class="headerlink" title="本地方法(Native Method)"></a>本地方法(Native Method)</h3><p>一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互。</p><p>为什么需要使用Native方法：Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时需要使用。</p><p>本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><p>比如</p><ul><li>与Java环境交互</li><li>与操作系统交互</li></ul><h3 id="本地方法栈-1"><a href="#本地方法栈-1" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆对于JVM进程来说是唯一的。线程之间是共享一个堆的<br>Java堆区在JVM启动的时候就被创立了，其大小也就确定了，可以通过-Xms和-Xmx调节</p><ul><li>Xms：最小堆内存(堆区的起始内存)，默认初始内存大小：物理电脑内存大小/64</li><li>Xmx：最大堆内存，默认内存大小：物理电脑内存大小/4</li></ul><p>通常设置时会将两个参数配置相同的值，目的时<strong>为了能偶在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong></p><h3 id="堆内存的分配"><a href="#堆内存的分配" class="headerlink" title="堆内存的分配"></a>堆内存的分配</h3><ul><li>Young Generation Space 新生代对空间  Young/New   又被划分为Eden区和Survivor区</li><li>Tenure generation space 老年代对空间 Old/Tenure</li><li>Permanent Space永久区   Perm —-&gt; Java8后改为元空间</li></ul><p>JVM中的对象可以分为两类</p><ul><li>一是生命周期较短的瞬时对象，这种对象的创建和消亡都十分迅速</li><li>另一类生命周期非常长，极端情况下和JVM的生命周期保持一致</li><li><img src="/images/Java%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="Java堆空间"></li></ul><h4 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h4><p>年轻代又可以划分为Eden空间、Survivor0空间(from区)和Survivor1空间(to 区)<br>默认Eden:from:to 比例是8：1：1，新生代：老年代比例是1：2<br>频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收。<br>新生代使用复制算法进行垃圾回收，目的是为了减少内碎片。</p><h3 id="堆的GC："><a href="#堆的GC：" class="headerlink" title="堆的GC："></a>堆的GC：</h3><ul><li>MinorGC/YoungGC：<ul><li>新生代的GC，Eden区满的时候触发，Survivor区满不会引发GC。</li><li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul></li><li>Major GC：<ul><li>老年代的GC，老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC。- STW的时间更长，如果Major GC后，内存还不足，就报OOM了</li></ul></li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集。<ul><li>调用System.gc（）时触发</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul><h3 id="堆分代思想"><a href="#堆分代思想" class="headerlink" title="堆分代思想"></a>堆分代思想</h3><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。分代的理由就是优化GC性能</p><h3 id="堆中的TLAB"><a href="#堆中的TLAB" class="headerlink" title="堆中的TLAB"></a>堆中的TLAB</h3><p>TLAB：Thread Local Allocation Buffer，也就是在堆中为每个线程单独分配了一个缓冲区。</p><p>TLAB是从内存模型的角度，为Eden区继续划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。<br>多线程同时分配内存时，<strong>使用TLAB可以避免一系列的非线程安全问题，同时还能够加速对象的分配，提升内存分配的吞吐量</strong>，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="/images/TLAB%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="TLAB分配过程"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要存放的用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。，而堆中主要存放的是实例化的对象。方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</p><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误。</p><p>JDK7前，习惯将方法去称为永久代，JDK8后使用元空间取代了永久代。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><img src="/images/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="方法区内部结构"><br>主要包括类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h5 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h5><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><h5 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h5><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分<br>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><h5 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h5><p>全局常量就是使用 static final 进行修饰。被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p><h3 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h3><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。<br>回收废弃常量与回收Java堆中的对象非常类似。</p><h4 id="判断不在使用类"><a href="#判断不在使用类" class="headerlink" title="判断不在使用类"></a>判断不在使用类</h4><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存时Java堆外的，直接向系统申请的内存区间。<br>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存<br>访问直接内存的速度会优于Java堆，读写性能更高</p><p>使用场景</p><ul><li>读写频繁的可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>存在的问题：<br>由于直接内存在堆外，因此不受JVM内存回收管理。同时系统的内存时有限的，JVM的内存和直接内存的总和受限于操作系统给出的最大内存。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>基本思想是对于那些线程私有的对象（指的是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。<br>优点：</p><ol><li>可以在函数调用结束后自行销毁对象，不需要垃圾回收器的介入，有效避免垃圾回收带来的负面影响</li><li>栈上分配速度快</li></ol><p>缺点：</p><ol><li>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4></li></ol><p><strong>逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体</strong>。在运行时分析对象的生命周期，如果发现该对象只会被本线程使用（一般是一些局部对象），那么就将该对象在栈上分配，而不在堆中（heap）分配，以减少对象对堆的压力，减少GC的次数。<br>同时如何发现一个对象只有一个线程被访问，那么对于这个对象的操作可以不考虑同步</p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等）。标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p><p>通过逃逸分析确定<strong>该对象不会被外部访问，并且对象可以被进一步分解</strong>时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。</p><h3 id="字符串常量池、Class常量池和运行时常量池"><a href="#字符串常量池、Class常量池和运行时常量池" class="headerlink" title="字符串常量池、Class常量池和运行时常量池"></a>字符串常量池、Class常量池和运行时常量池</h3><h4 id="字符串常量池-也成为StringTable"><a href="#字符串常量池-也成为StringTable" class="headerlink" title="字符串常量池(也成为StringTable)"></a>字符串常量池(也成为StringTable)</h4><ul><li><strong>字符串常量池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例</strong>，</li><li>然后将该字符串<strong>对象实例的引用值存到字符串常量池</strong>中</li><li>字符串常量池中存的是引用值而不是具体的实例对象，<strong>具体的实例对象是在堆中开辟的一块空间存放的</strong>。</li><li>字符串常量池在每个HotSpot VM的实例只有一份，被所有的类共享</li></ul><h4 id="Class常量池"><a href="#Class常量池" class="headerlink" title="Class常量池"></a>Class常量池</h4><p>当java文件被编译成class文件之后，会在class文件中生成我们所说的class常量池，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，<strong>用于存放编译器生成的各种字面量(文本字符串、被声明为final的常量、基本数据类型的值)和符号引用(类和接口的全限定名、字段的名称和描述符、方法的名称和描述符)</strong></p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。运行时常量池也是每个类都有一个。class常量池中存的是字面量和符号引用，经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询字符串常量池。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件加载子系统</title>
      <link href="2021/05/12/%E5%90%8E%E7%AB%AF/Java/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/12/%E5%90%8E%E7%AB%AF/Java/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件加载子系统"><a href="#类文件加载子系统" class="headerlink" title="类文件加载子系统"></a>类文件加载子系统</h1><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="/images/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类文件子系统加载过程"><br>加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>目的：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>加载class文件的方式</p><ul><li>从本地系统直接加载</li><li>通过网络获取,如web applet</li><li>从压缩包获取。如jar包，war包</li><li>运行时生成。如动态代理</li><li>由其他文件生成。如JSP从数据库中提取.class文件</li><li>从加密文件或许。防止反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><h4 id="验证-并非必要"><a href="#验证-并非必要" class="headerlink" title="验证(并非必要)"></a>验证(并非必要)</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>目的：保证输入的字节流能正确地解析并存储到方法区内。<br>文件格式验证验证是基于二进制字节流进行的，只有通过这次验证，字节流才会进入方法区进行存储。后续的校验都是在方法区进行</p><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>目的：对类的元数据信息进行语意校验，保证不存在不符合Java语言规范的元数据信息</p><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>目的：通过数据流和控制流分析，确定语义是合法的、符合逻辑的。<br>字节码验证会对类的方法体进行校验，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</p><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>目的：确保解析动作能够正常执行</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类变量分配内存并且设置该类变量的<strong>默认初始值，即零值</strong>。</p><blockquote><p>此时不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；<br>此时不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池内的符号引用转换为直接引用。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在类初始化阶段，执行类构造器&lt;clinit&gt;()方法。</p><ol><li>编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码和 static {} 域的代码，收集在一起成为 &lt;clinit&gt;() 方法，收集的顺序是由语句在源文件出现的顺序决定的</li><li>如果不存在静态语句块，也没有对变量初始化操作，就不会为这个类生成&lt;clinit&gt;()方法。</li><li>子类初始化时会首先调用父类的 &lt;clinit&gt;() 方法</li><li>VM 会保证 &lt;clinit&gt;() 方法的线程安全，保证同一时间只有一个线程执行</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h3><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自Java.lang.ClassLoader，<strong>没有父加载器</strong>。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，<strong>Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</strong></li></ul><h3 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="应用程序类加载器-AppClassLoader"><a href="#应用程序类加载器-AppClassLoader" class="headerlink" title="应用程序类加载器(AppClassLoader)"></a>应用程序类加载器(AppClassLoader)</h3><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。<br><img src="/images/JVM%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="JVM的双亲委派模型"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>如果一个类加载器收到类加载请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，则返回成功。若父类加载器无法完成加载任务，子加载器会尝试自己去加载</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免类的重复加载</li><li>保存程序安全，防止核心API被篡改，如Java.lang.*下的类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码执行流程</title>
      <link href="2021/05/11/%E5%90%8E%E7%AB%AF/Java/Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>2021/05/11/%E5%90%8E%E7%AB%AF/Java/Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h1><p>Java源代码文件会被Java编译器解析成class的字节码文件。<br>Java编译器会对.java文件进行词法分析和语法分析生成抽象语法树，进行语义分析生成注解语法树，最后通过字节码生成器生成字节码文件。</p><p>而字节码文件时可以被Java虚拟机执行的</p><p>Java文件生成.class文件</p><p>JVM使用双亲委派机制加载class文件。<br>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，<br>可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="/images/Java%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java代码执行过程"><br><img src="/images/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类文件加载过程"><br><img src="/images/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E6%83%85.png" alt="类文件加载过程详情"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis是否能用作消息队列</title>
      <link href="2021/05/10/middleware/Redis/Redis%E6%98%AF%E5%90%A6%E8%83%BD%E7%94%A8%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>2021/05/10/middleware/Redis/Redis%E6%98%AF%E5%90%A6%E8%83%BD%E7%94%A8%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis是否可以作为消息队列？"><a href="#Redis是否可以作为消息队列？" class="headerlink" title="Redis是否可以作为消息队列？"></a>Redis是否可以作为消息队列？</h1><p>关于Redis能不能做消息队列，主要是解决以下两个问题</p><ul><li>能否保证消息不丢失</li><li>消息是否能够堆积<h2 id="使用List作为消息队列"><a href="#使用List作为消息队列" class="headerlink" title="使用List作为消息队列"></a>使用List作为消息队列</h2>如果使用Redis作为消息队列，那么首先会使用List这个数据类型。生产者将数据放入List中，消费者从List中读取数据。<br>那么会产生一个问题：消费者需要不断地从消息队列中读取数据。如果队列为空，那么就会出现CPU空转的情况。如果解决这个空转的问题呢？有两种方式</li></ul><ol><li>如果消息队列为空，那么就先让消费者休息一会，然后再尝试读取数据。这样又会引入一个问题，就是新的消息来了，消费者处理消息会存在延迟。</li><li>如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息。Redis提供了阻塞式拉取消息的命令：BRPOP/BLPOP</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>不支持重复消费</li><li>消息丢失：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了</li></ol><h2 id="使用发布订阅模型"><a href="#使用发布订阅模型" class="headerlink" title="使用发布订阅模型"></a>使用发布订阅模型</h2><p>Redis提供了PUBLISH/SUBSCRIBE 命令，来完成发布、订阅的操作。<br>Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>可能会导致信息丢失，消费者向队列发布消息，Redis就会转发给消费者的。这个过程是实时的，不存在任何的数据存储。</li><li>无法处理消息堆积。当消息积压时，有可能会导致消费失败和消息丢失。当生产者发布消息时，Redis先把消息写到对应消费者的缓冲区中。之后，消费者不断地从缓冲区读取消息，处理消息。</li></ol><h2 id="Redis新的数据类型Stream"><a href="#Redis新的数据类型Stream" class="headerlink" title="Redis新的数据类型Stream"></a>Redis新的数据类型Stream</h2><p>Stream通过XADD和XREAD完成最简单的生产、消费模型：</p><ul><li>XADD：发布消息</li><li>XREAD：读取消息</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>支持「阻塞式」拉取消息</li><li>支持发布/订阅模式</li><li>保证消息不丢失，重新消费。当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。</li><li>Stream 会写入到RDB和AOF做持久化。但是</li><li>消息堆积时，Stream指定队列的最大长度，防止队列积压导致内存爆炸。当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。因此依旧可能会导致丢失消息。</li></ul><p><img src="/images/redis%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98.png" alt="redis作为消息队列问题"></p><p>Refer:<a href="https://mp.weixin.qq.com/s/3oFf0-v6Ba2iO7dIcXY-6A">https://mp.weixin.qq.com/s/3oFf0-v6Ba2iO7dIcXY-6A</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列关注点</title>
      <link href="2021/05/10/middleware/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%B3%E6%B3%A8%E7%82%B9/"/>
      <url>2021/05/10/middleware/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%B3%E6%B3%A8%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="消息队列的关注点"><a href="#消息队列的关注点" class="headerlink" title="消息队列的关注点"></a>消息队列的关注点</h2><ol><li>消息不丢</li><li>消息可堆积</li></ol><h3 id="如何保证消息不丢？"><a href="#如何保证消息不丢？" class="headerlink" title="如何保证消息不丢？"></a>如何保证消息不丢？</h3><p>消息队列的三个组成部分：生产者、消息队列、消费者<br>因此消息是否会发生丢失，在于以下三个环节</p><ul><li>生产者会不会丢数据</li><li>消费者会不会丢数据</li><li>消息中间件会不会丢数据</li></ul><h4 id="生产者丢消息"><a href="#生产者丢消息" class="headerlink" title="生产者丢消息"></a>生产者丢消息</h4><p>当生产者在发布消息时，可能会发生</p><ul><li>消息没有发出去：网络故障或其它问题导致发布失败，中间件直接返回失败</li><li>消息发了出去：网络问题导致发布超时，可能数据已发送成功，也可能没有发送成功。比如数据已发送成功，但读取响应结果超时了</li></ul><p>针对上面的方式，都可以采用重发的方式进行处理。宁可重发也不能丢失。</p><blockquote><p>生产者都会通过设置一个最大重试次数，超过上限，就需要记录日志报警处理</p></blockquote><p>重发之后，消费者会引入一个新的问题，就是有可能会收到多条重复的消息。这时消费就需要对重复的消息进行处理，保证消息的幂等性，即处理多条同样的消息会有相同的结果</p><h4 id="消费者丢消息"><a href="#消费者丢消息" class="headerlink" title="消费者丢消息"></a>消费者丢消息</h4><p>消费者拿到消息后，还没处理完就异常宕机了。这时候，消费者是否还能重新接收到处理失败数据？</p><p>解决这个问题，需要消费者在处理完消息后，必须通知队列中间件，队列中间件才会把处理完成的数据标记为处理，否则仍然将这些数据发送给消费者。</p><h4 id="队列中间件会不会丢数据"><a href="#队列中间件会不会丢数据" class="headerlink" title="队列中间件会不会丢数据"></a>队列中间件会不会丢数据</h4><p>消息中间件必须在宕机的时候，保证原本消息队列里的数据在中间件恢复的时候依旧存在。或者通过集群的方式保证某一结点挂了，集群的数据不丢失。</p><h3 id="消息可堆积"><a href="#消息可堆积" class="headerlink" title="消息可堆积"></a>消息可堆积</h3><p>消息存储在内存或者是硬盘中，如果存储在内存中的话，如果消息过多，当内存不够的时候，超过堆积上线的消息将会丢失。</p><p>当消息堆积时，一般有两种解决方案：</p><ol><li>生产者限流，避免消费者处理不及时，导致持续积压</li><li>丢弃消息：中间件丢弃旧的消息，只保留固定长度的消息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile关键字</title>
      <link href="2021/05/04/%E5%90%8E%E7%AB%AF/Java/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/05/04/%E5%90%8E%E7%AB%AF/Java/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="Volatile的作用"><a href="#Volatile的作用" class="headerlink" title="Volatile的作用"></a>Volatile的作用</h2><p>Volatile是JVM提供的轻量级的同步机制，主要有以下三个功能</p><ul><li>保证可见性</li><li><strong>不保证</strong>原子性</li><li>禁止指令重排<h2 id="Volatile如何实现可见性"><a href="#Volatile如何实现可见性" class="headerlink" title="Volatile如何实现可见性"></a>Volatile如何实现可见性</h2>当某个线程修改了某个值以后，写入主内存。此时其他线程会被通知重新去主内存中读取值。<blockquote><p>Java内存模型中规定:所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中的变量</strong>。各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成</p></blockquote></li></ul><p>当使用Volatile关键字修饰的共享变量转换成汇编时，会添加一个以lock为前缀的指令，当CPU执行该指令时，需要做两件事：</p><ul><li>将当前内核高速缓存行的数据立刻回写到内存</li><li>使在其他内核里缓存了该内存地址的数据无效，这里<a href="https://blog.csdn.net/itakyubi/article/details/100527743">使用CPU的MESI协议实现</a></li></ul><blockquote><p>MESI协议简单说就是：<br>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会<strong>发出信号通知其他CPU将该变量的缓存行设置为无效状态。当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量</strong></p></blockquote><h2 id="为什么Volatile不保证原子性"><a href="#为什么Volatile不保证原子性" class="headerlink" title="为什么Volatile不保证原子性"></a>为什么Volatile不保证原子性</h2><p>当Volatile转化成汇编时，并没有添加锁的操作。因此对于复合操作如num++不具有原子性。但是对于单个变量的读写仍然具有原子性</p><h2 id="Volatile指令重排"><a href="#Volatile指令重排" class="headerlink" title="Volatile指令重排"></a>Volatile指令重排</h2><p>编译器和处理器常常会对指令重排。一般分为以下三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>由于编译器和处理器都能执行指令重排的优化。Volatile指令在生成字节码的同时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障：禁止上面的普通写和下面的volatile写重排序</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障：防止上面的volatile写与下面可能有的volatile重排序</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障：禁止下面所有的普通读操作和上面的volatile读重排序</li><li>在每个volatile读操作的后面插入一个LoadStore屏障：禁止下面所有的普通写和上面的volatile读重排序</li></ul><p><img src="/images/Volatile%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="Volatile重排序"></p><blockquote><p>在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子性操作的实现</title>
      <link href="2021/05/04/%E5%90%8E%E7%AB%AF/Java/%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/05/04/%E5%90%8E%E7%AB%AF/Java/%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="原子性操作的实现"><a href="#原子性操作的实现" class="headerlink" title="原子性操作的实现"></a>原子性操作的实现</h1><h2 id="CPU原子性操作的实现"><a href="#CPU原子性操作的实现" class="headerlink" title="CPU原子性操作的实现"></a>CPU原子性操作的实现</h2><h3 id="使用总线锁保证原子性："><a href="#使用总线锁保证原子性：" class="headerlink" title="使用总线锁保证原子性："></a>使用总线锁保证原子性：</h3><p>总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号的时候，其他处理器的请求将会被阻塞住，那么该处理器就可以独享内存</p><h3 id="通过缓存锁定来保证原子性："><a href="#通过缓存锁定来保证原子性：" class="headerlink" title="通过缓存锁定来保证原子性："></a>通过缓存锁定来保证原子性：</h3><p>内存区域如果被缓存在处理器的缓存行，并且在Lock操作期间被锁定，当它执行锁操作回写内存的时候，处理器不在总线上声称LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写已经被锁定的缓存行数据时，会使缓存行失效</strong>。</p><h3 id="不适用缓存锁定的情况"><a href="#不适用缓存锁定的情况" class="headerlink" title="不适用缓存锁定的情况"></a>不适用缓存锁定的情况</h3><ul><li>操作的数据不能被缓存到处理器内部，或者操作的数据跨多个缓存行</li><li>不支持缓存锁定的处理器</li></ul><h2 id="Java原子性操作的实现"><a href="#Java原子性操作的实现" class="headerlink" title="Java原子性操作的实现"></a>Java原子性操作的实现</h2><h2 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h2><h3 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h3><p>当线程拿到一个值并对其修改，然后写入到内存中时。在写入之前，会先拿到当前内存中的值，然后与之前拿到的旧值进行对比。如果没有变化，则写入新的值。如果有变化，则使用新拿到的值进行修改<br>这一个行为称之为CAS操作。</p><p>CAS操作会不断轮询来判断旧值是否被修改,我们也称之为自旋CAS。</p><h3 id="Java是如何实现CAS的"><a href="#Java是如何实现CAS的" class="headerlink" title="Java是如何实现CAS的"></a>Java是如何实现CAS的</h3><p>Java中CAS操作的执行依赖于Unsafe类的方法。Unsafe类处于sun.misc.Unsafe类中的中。通过调用UnSafe类中CAS方法，JVM会帮我们实现CAS汇编指令。由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe的方法也都是native的方法，基于该类可以直接操作特定内存的数据,其内部方法操作可以像C的指针一样直接操作内存.</p><h3 id="CAS引发的问题"><a href="#CAS引发的问题" class="headerlink" title="CAS引发的问题"></a>CAS引发的问题</h3><ol><li>自旋CAS如果长期不成功,那么会不断地轮询,这样会给CPU带来非常大地执行开销。<ol><li>可以通过延迟流水线执行指令,使CPU不会消耗过多地资源,延迟时间取决于实现</li><li>避免在退出循环地时候因内存顺序冲突而引起地CPU流水线被清空,从而调高CPU的执行效率<blockquote><p>内存顺序冲突:多个CPU同时修改同一个缓存行的不同部分引起其中一个CPU的操作无效.当出现这个内存顺序冲突时,CPU会必须清空流水线</p></blockquote></li></ol></li><li>只能保证一个共享变量的原子操作<ol><li>Java1.5后,引入了AtomicReference类保证引用对象之间的原子性</li></ol></li><li>ABA问题:CAS只判断最终结果,保证了新值和旧值之间的正确性,但是旧值可能经过一系列操作之后,没有发生改变.比如50-&gt;100-&gt;50.CAS只关注一头一尾.<ol><li>解决方式是通过版本号,除了检查新值和旧值的正确性以外,还需要判断版本是否是一致的</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维的价值</title>
      <link href="2021/05/04/%E8%BF%90%E7%BB%B4/SRE/%E8%BF%90%E7%BB%B4%E4%BB%B7%E5%80%BC/"/>
      <url>2021/05/04/%E8%BF%90%E7%BB%B4/SRE/%E8%BF%90%E7%BB%B4%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="运维的价值"><a href="#运维的价值" class="headerlink" title="运维的价值"></a>运维的价值</h1><h1 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h1><ol><li>保证业务高质量不间断的对外服务</li><li>既要服务的好,又要运营成本最低</li><li>又稳又快又安全地让业务进行自我更新</li></ol><h2 id="阶段价值"><a href="#阶段价值" class="headerlink" title="阶段价值"></a>阶段价值</h2><ul><li>业务起步阶段:整个团队要的是快速迭代功能,快速发布.此时运维的<strong>重点在于快速</strong>.帮助团队搭建更好更敏捷的研发，测试环境，以及制定偏向敏捷高效的生产环境管理与发布流程</li><li>业务快速成长阶段:开发可能无法及时的去优化代码的，这个时期就需要<strong>运维保证充足的资源供应，用硬件弥补软件的性能不足，以及各种监控报警，救火预案，和开发一道维护线上的服务质量</strong>，后台开发和运维最辛苦的阶段</li><li>业务成熟阶段:这时更加关注的是<strong>稳定稳定还是稳定,还有就是成本</strong>。线上90%的故障都是有变更引起，这时运维会对严控变更流程，审批手段，变更时间，灰度时长，打分制度等都会一 一出台，除了卡着开发以外，还会去挖掘线上服务的性能问题，<strong>推动开发去优化改造以降低运营成本</strong>。</li><li>业务衰落期:此时在<strong>保证业务正常的前提下进一步的压缩运营成本</strong>，对于次要模块推动下线</li></ul><h2 id="三步工作法"><a href="#三步工作法" class="headerlink" title="三步工作法"></a>三步工作法</h2><ol><li>第一工作法:从开发-&gt;运维-&gt;客户的整个自左向右的工作流,为了使流量最大化,需要小的批量规模和工作间隔,决不让缺陷流向下游工作中心,并且不断为整体目标进行优化.</li><li>第二工作法:从开发&lt;-运维&lt;-客户的反向持续反馈流,放大其效益确保防止问题再次发生,或者更快地发现和修复问题.从源头上保证质量.</li><li>第三工作法:创造公司文化以至于带动两种风气:<ol><li><strong>不断尝试,需要承担风险并从成功和失败中吸取经验和教训</strong>,使我们不懈地改进工作系统.</li><li><strong>理解重复和联系是熟练掌握地前提</strong>,不断重复地日常操练赋于我们技能和经验,令我们可以撤回安全区并恢复正常运作</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch检索原理</title>
      <link href="2021/05/03/middleware/Elasticsearch/Elasticsearch%20%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/03/middleware/Elasticsearch/Elasticsearch%20%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch简介</title>
      <link href="2021/05/03/middleware/Elasticsearch/Elasticsearch%E7%AE%80%E4%BB%8B/"/>
      <url>2021/05/03/middleware/Elasticsearch/Elasticsearch%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Elasticsearch是一个基于Lucene，使用Java开发的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，而且基于RESTful web接口。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>海量数据的分布式存储以及集群管理<ul><li>服务与数据的高可用，水平扩展</li></ul></li><li>近实时搜索，性能卓越<ul><li>结构化/全文/地理位置/自动完成</li></ul></li><li>海量数据的近实时分析<ul><li>聚合功能</li></ul></li></ul><h2 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h2><ul><li>ElasticSearch是面向文档的，文档是所有可搜索数据的最小单位<ul><li>日志文件中的日志项</li><li>电影/MP3/文档的具体信息</li></ul></li><li>文档会被序列化喂JSON格式，保存再ElasticSearch 中<ul><li>JSON队友由字段组成</li><li>每个字段都由对应的字段类型</li></ul></li><li>每个文档都有一个Unique ID<ul><li>ID可以自己指定或者Elasticsearch自动生成</li></ul></li></ul><h3 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h3><ul><li>_index：文档的索引名</li><li>_type: 文档所属的类型名</li><li>_id：文档的唯一ID</li><li>_source：文档的原始Json数据</li><li>_all：整个字段所有内容到该字段，目前已经被废除</li><li>_version：文档的版本信息</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>索引是文档的容器，是一类文档的结合<ul><li>Index体现了逻辑空间的概念，每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型</li><li>Shard 体现了物理空间的盖面，索引中的数据分散再Shard上</li></ul></li><li>索引的Mapping和Setting   <ul><li>Mapping定义文档字段的类型</li><li>Setting定义不同的数据分布</li></ul></li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><ul><li>节点是一个Elasticsearch的实例<ul><li>本质上就是一个Java进程</li><li>一台机器上可以运行多个Elasticsearch进程</li></ul></li><li>每个节点都有名字，通过配置文件设置，或者启动时候用-E node.name=node1 指定</li><li>每个节点启动之后，会分配一个UID,保存在data目录下</li></ul><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ul><li>green：主分片和副本分片都有</li><li>yellow：所有的主分片已经分片了，但至少还有一个副本是缺失的</li><li>red：至少一个主分片（以及它的全部副本）都在缺失中</li></ul><h3 id="Master-Node-和-Master-eligible-nodes"><a href="#Master-Node-和-Master-eligible-nodes" class="headerlink" title="Master Node 和 Master-eligible nodes"></a>Master Node 和 Master-eligible nodes</h3><ul><li>节点启动后，默认就是一个Master-eligible 节点。当第一个节点启动时，会将自己选举成为Master节点</li><li>Master-eligible 参加选主流程，成为Master节点</li><li>每个节点上保存了集群的状态，只有Master节点才能修改<ul><li>集群状态的信息包括：所有节点的信息，所有的索引和相关的Mapping和Setting信息，分片的路由信息</li></ul></li><li>任意节点都能修改信息会导致数据的不一致性</li></ul><h3 id="Data-Node-和Coordinating-Node"><a href="#Data-Node-和Coordinating-Node" class="headerlink" title="Data Node 和Coordinating Node"></a>Data Node 和Coordinating Node</h3><ul><li>Data Node 用于保存数据的节点，负责保存数据分片</li><li>Coordinating Node 负责接收Client端的请求，将请求分发到合适的节点。每个节点默认都起到Coordinating Node的职责</li></ul><h3 id="其他类型的节点"><a href="#其他类型的节点" class="headerlink" title="其他类型的节点"></a>其他类型的节点</h3><ul><li>Hot &amp; Warm Node： 不同硬件配置的Data Node，用于实现Hot &amp; Warm 架构</li><li>Machine Learning Node：负责跑机器学习的Job，用于做异常检测</li><li>Tribe Node： 连接不同的集群，并且支持将这些集群当成一个单独的集群处理</li></ul><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><h3 id="主分片-Primary-shard"><a href="#主分片-Primary-shard" class="headerlink" title="主分片(Primary shard)"></a>主分片(Primary shard)</h3><p>用于解决数据水平扩展的问题，通过主分片，可以将数据分布到集群内的所有节点上。一个分片就是一个运行Lucene的实例，并且再索引创建时指定，后续不允许修改，除非Reindex</p><h3 id="副本分片-replica-shard"><a href="#副本分片-replica-shard" class="headerlink" title="副本分片(replica shard)"></a>副本分片(replica shard)</h3><p>用以解决数据高可用的问题，是主分片的拷贝。副本分片数可以动态调整。</p><h3 id="分片的设定"><a href="#分片的设定" class="headerlink" title="分片的设定"></a>分片的设定</h3><ul><li>分片数设置过小<ul><li>导致后续无法增加节点实现水平扩展</li><li>单个分片数据太大，导致数据重新分配耗时</li></ul></li><li>分片设置过大<ul><li>影响搜索结果的相关性打分，影响统计结果的准确性</li><li>单节点上过多的分片，会导致资源浪费，同时影响性能</li></ul></li></ul><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mapping类似于数据库中的schema<br>作用：</p><ul><li>定义索引中的字段名称</li><li>定义字段的数据类型</li><li>字段，倒排索引的相关配置</li><li>Mapping会将JSON格式映射成Lucene所需要的扁平格式</li><li>一个Mapping属于一个索引的type</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch问题集</title>
      <link href="2021/05/03/middleware/Elasticsearch/Elasticsearch%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/03/middleware/Elasticsearch/Elasticsearch%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用Elasticsearch？"><a href="#为什么要使用Elasticsearch？" class="headerlink" title="为什么要使用Elasticsearch？"></a>为什么要使用Elasticsearch？</h2><h2 id="Elasticsearch的master选举流程？"><a href="#Elasticsearch的master选举流程？" class="headerlink" title="Elasticsearch的master选举流程？"></a>Elasticsearch的master选举流程？</h2><h2 id="Elasticsearch如何处理脑裂问题？"><a href="#Elasticsearch如何处理脑裂问题？" class="headerlink" title="Elasticsearch如何处理脑裂问题？"></a>Elasticsearch如何处理脑裂问题？</h2><h2 id="Elasticsearch索引文档的流程"><a href="#Elasticsearch索引文档的流程" class="headerlink" title="Elasticsearch索引文档的流程"></a>Elasticsearch索引文档的流程</h2><h2 id="Elasticsearch更新和删除文档的流程"><a href="#Elasticsearch更新和删除文档的流程" class="headerlink" title="Elasticsearch更新和删除文档的流程"></a>Elasticsearch更新和删除文档的流程</h2><h2 id="Elasticsearch搜索的流程"><a href="#Elasticsearch搜索的流程" class="headerlink" title="Elasticsearch搜索的流程"></a>Elasticsearch搜索的流程</h2><h2 id="并发状况下Elasticsearch-如何保证读写一致"><a href="#并发状况下Elasticsearch-如何保证读写一致" class="headerlink" title="并发状况下Elasticsearch 如何保证读写一致"></a>并发状况下Elasticsearch 如何保证读写一致</h2><h2 id="Elasticsearch如何实现大数据的聚合？"><a href="#Elasticsearch如何实现大数据的聚合？" class="headerlink" title="Elasticsearch如何实现大数据的聚合？"></a>Elasticsearch如何实现大数据的聚合？</h2><h2 id="Elasticsearch-中的集群、节点、索引、文档、类型是什么？"><a href="#Elasticsearch-中的集群、节点、索引、文档、类型是什么？" class="headerlink" title="Elasticsearch 中的集群、节点、索引、文档、类型是什么？"></a>Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h2><h2 id="Elasticsearch-中的倒排索引是什么？"><a href="#Elasticsearch-中的倒排索引是什么？" class="headerlink" title="Elasticsearch 中的倒排索引是什么？"></a>Elasticsearch 中的倒排索引是什么？</h2><h2 id="ElasticSearch中的分片是什么"><a href="#ElasticSearch中的分片是什么" class="headerlink" title="ElasticSearch中的分片是什么?"></a>ElasticSearch中的分片是什么?</h2><h2 id="如何建立倒排索引"><a href="#如何建立倒排索引" class="headerlink" title="如何建立倒排索引"></a>如何建立倒排索引</h2><h2 id="写数据过程"><a href="#写数据过程" class="headerlink" title="写数据过程"></a>写数据过程</h2><h2 id="读数据过程"><a href="#读数据过程" class="headerlink" title="读数据过程"></a>读数据过程</h2><h2 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h2><p>Ref:<a href="https://zhuanlan.zhihu.com/p/139762008">https://zhuanlan.zhihu.com/p/139762008</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="2021/05/03/%E8%BF%90%E7%BB%B4/SRE/%E6%97%A5%E5%BF%97/"/>
      <url>2021/05/03/%E8%BF%90%E7%BB%B4/SRE/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志的重要性"><a href="#日志的重要性" class="headerlink" title="日志的重要性"></a>日志的重要性</h2><ul><li>运维：发现问题可以用来查原因</li><li>恶意攻击，恶意注册，刷单，恶意密码猜测<h2 id="日志的挑战"><a href="#日志的挑战" class="headerlink" title="日志的挑战"></a>日志的挑战</h2></li><li>关注点多，任何一个点都有可能引起问题</li><li>日志分散再多个机器，出现问题，才发现日志被删</li><li>很多运维人员是消防员，哪里有问题就去哪里</li></ul><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><ol><li>日志收集</li><li>格式化分析</li><li>全文检索</li><li>风险警告</li></ol><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p><img src="/images/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90.png" alt="日志分析"></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/02/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="常见资源缩写"><a href="#常见资源缩写" class="headerlink" title="常见资源缩写"></a>常见资源缩写</h2><p>rc：replication controller<br>rs：replicaSet<br>po：pods<br>svc：service<br>ns：namespace<br>ds: daemonSet<br>pv: persistent volume<br>pvc：persistent volume claim<br>sc：storage class<br>cm: configMap</p><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><p>操作资源： kubectl get/delete po<br>查看yaml属性：kubectl explain pod.spec</p><h2 id="minikube-的安装与设置"><a href="#minikube-的安装与设置" class="headerlink" title="minikube 的安装与设置"></a>minikube 的安装与设置</h2><p><a href="https://www.jianshu.com/p/3152aa738e39">https://www.jianshu.com/p/3152aa738e39</a></p><h2 id="国内安装"><a href="#国内安装" class="headerlink" title="国内安装"></a>国内安装</h2><p>例如下面的命令 kubectl create deployment hello-minikube –image=k8s.gcr.io/echoserver:1.10 ，替换后为 kubectl create deployment hello-minikube –image=registry.aliyuncs.com/google_containers/echoserver:1.10 即可<br><a href="https://juejin.cn/post/6844904073054027789">https://juejin.cn/post/6844904073054027789</a></p><p>kubectl create deployment balanced –image=k8s.gcr.io/echoserver:1.4  </p><h2 id="为什么要使用service"><a href="#为什么要使用service" class="headerlink" title="为什么要使用service"></a>为什么要使用service</h2><h2 id="ReplicationController-和ReplicationSet的区别与关系"><a href="#ReplicationController-和ReplicationSet的区别与关系" class="headerlink" title="ReplicationController 和ReplicationSet的区别与关系"></a>ReplicationController 和ReplicationSet的区别与关系</h2><p>两者的行为完全相同，但是ReplicationSet的标签表达能力更强。ReplicationController的标签选择器只允许包含某个标签的匹配pod。<br>ReplicationSet的标签选择器还允许匹配缺少某个标签的pod，或包含特定标签名的pod。</p><h2 id="为什么要使用Downward-API将元数据与数据分离"><a href="#为什么要使用Downward-API将元数据与数据分离" class="headerlink" title="为什么要使用Downward API将元数据与数据分离"></a>为什么要使用Downward API将元数据与数据分离</h2><p>因为这样设计简单元数据需要一直在线，如果分到不同的datanode里面可靠性比较难做，而集中到namenode里面就只需要对namenode做热备份就行。元数据操作之间需要同步，放一台机器上好做，分到不同机器的话就需要做分布式transaction元数据本身并不大，假设每个block 64MB，相应的元数据64B，那么存1PB数据也就需要1GB的元数据。这个数据量放到一台机器上完全没问题。</p><h2 id="持久卷和持久卷声明是如何匹配的"><a href="#持久卷和持久卷声明是如何匹配的" class="headerlink" title="持久卷和持久卷声明是如何匹配的"></a>持久卷和持久卷声明是如何匹配的</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E8%BF%90%E7%BB%B4/kubernetes/base/"/>
      <url>2021/05/02/%E8%BF%90%E7%BB%B4/kubernetes/base/</url>
      
        <content type="html"><![CDATA[<p>不可变基础设施：服务器、虚拟机或者是容器<br>k8s中不可变基础设施就是pod<br>pod是k8s中的最原子化单位</p><h2 id="可变基础设施的风险"><a href="#可变基础设施的风险" class="headerlink" title="可变基础设施的风险"></a>可变基础设施的风险</h2><ul><li>持续的变更修改给服务运行态引入过多的中间态，增加了不可预知的风险；</li><li>故障发生时，难以及时快速构建出新的服务副本；</li><li>不易标准化，交付运维过程异常痛苦，虽然可以通过 Ansible、Puppet 等部署工具进行交付，但是也很难保证对底层各种异构的环境支持得很好，还有随时会出现的版本漂移问题</li></ul><h2 id="init-容器"><a href="#init-容器" class="headerlink" title="init 容器"></a>init 容器</h2><p>通常用来做一些初始化工作，比如环境检测、OSS 文件下载、工具安装，等等。<br>应用容器专注于业务处理，其他一些无关的初始化任务就可以放到 init 容器中。这种解耦有利于各自升级，也降低相互依赖</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E8%BF%90%E7%BB%B4/Docker/Docker%E7%9B%91%E6%8E%A7/"/>
      <url>2021/05/02/%E8%BF%90%E7%BB%B4/Docker/Docker%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-监控"><a href="#Docker-监控" class="headerlink" title="Docker 监控"></a>Docker 监控</h1><h2 id="使用-docker-stats-命令"><a href="#使用-docker-stats-命令" class="headerlink" title="使用 docker stats 命令"></a>使用 docker stats 命令</h2><p>docker stats命令可以很方便地看到主机上所有容器的 CPU、内存、网络 IO、磁盘 IO、PID 等资源的使用情况</p><h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><p>cAdvisor 是谷歌开源的一款通用的容器监控解决方案。cAdvisor 不仅可以采集机器上所有运行的容器信息，还提供了基础的查询界面和 HTTP 接口，更方便与外部系统结合。所以，cAdvisor很快成了容器指标监控最常用组件，并且 Kubernetes 也集成了 cAdvisor 作为容器监控指标的默认工具<br>cAdvisor 监控容器具有以下特点：</p><ol><li>可以同时采集物理机和容器的状态</li><li>可以展示监控历史数据</li></ol><h2 id="监控原理"><a href="#监控原理" class="headerlink" title="监控原理"></a>监控原理</h2><p>Docker 是基于 Namespace、Cgroups 和联合文件系统实现的<br>Cgroups 不仅可以用于容器资源的限制，还可以提供容器的资源使用率。无论何种监控方案的实现，底层数据都来源于 Cgroups。<br>Cgroups 的工作目录为/sys/fs/cgroup</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E5%90%8E%E7%AB%AF/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>2021/05/02/%E5%90%8E%E7%AB%AF/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ol><li>数字数据编码为数字信号</li><li>1 非归零码</li><li>2 曼切斯特编码</li><li>3 差分曼切斯特编码</li><li>4 4B/5B 编码</li><li>数字数据编码为模拟信号</li><li>1 ASK 横幅键控</li><li>2 FSK 频移键控</li><li>3 PSK 相移键控</li><li>4 QAM 正交振幅调制</li><li>模拟数据编码为数字信号<br>步骤:<ol><li>采样</li><li>量化</li><li>编码</li></ol></li><li>模拟数据调制为模拟信号<br> FDM技术(频分复用)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E7%94%B5%E8%B7%AF%EF%BC%8C%E6%8A%A5%E6%96%87%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E7%94%B5%E8%B7%AF%EF%BC%8C%E6%8A%A5%E6%96%87%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>电路交换<br>三个阶段：建立连接，数据传输，连接释放<br>优点：</p><ul><li>通信延迟小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单<br>缺点：</li><li>建立时间长</li><li>灵活性差</li><li>线路独占</li><li>灵活性差</li><li>难以规格化</li></ul></li><li><p>报文交换<br>采用存储转发的方式<br>优点：</p><ul><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务<br>缺点：</li><li>需要经历存储、转发。从而引起转发延时(接受报文，检查正确性，排队，发送时间)</li><li>大小没有限制。需要网络节点有更大的缓存</li></ul></li><li><p>分组交换<br>采用存储转发的方式。通过将大数据块分割成小数据块来解决大报文传输问题。<br>优点：</p><ul><li>无建立时延</li><li>线路利用率高</li><li>相对于报文减缓简化存储管理</li><li>加速传输</li><li>减少出错几率和重发数据量<br>缺点：</li><li>存在传输时延</li><li>需要传输额外的信息量</li><li>当分组使用数据报的时候，可能会出现失序、丢失或重复的分组。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<ol><li>数据报服务<br>特点：<ul><li>发送分组无需建立连接</li><li>网络尽最大努力交付</li><li>发送的分组包含发送端和接收端的完整地址，以便独立传输</li><li>分组在交换节点存储转发时需要排队等待处理</li><li>网络具有冗余路径</li><li>存储转发时延小，提高网络吞吐量</li><li>双方不占用电路，资源利用率高</li></ul></li><li>虚电路<br>思想：将数据报的方式与电路交换方式相结合<br>三个阶段：虚电路建立，数据传输和虚电路释放<br>特点：<ul><li>有建立连接的开销</li><li>提供可靠的通信，确保每个分组正确且有序可达</li><li>可靠的通信功能</li><li>不具备容灾特性</li><li>首部不含包目的地址，而是包含虚电路标识符，相对数据报方式开销少</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%89%A9%E7%90%86%E5%B1%82/%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ol><li><p>奈氏准则<br>条件：无噪音，带宽有限(理想情况下)<br>$$ V_{低通道} =  2Wlog_2V_{Baud}$$<br>$V_{低通道}$:理想状态下的低通道的极限传输速率<br>$W$:带宽，单位为<em>HZ</em><br>$V_{Baud}$: 每个码元的离散电平数目</p></li><li><p>香农定理<br>条件：有高斯白噪声干扰，带宽有限<br>$$ V_{信道} = 2Wlog_2(1+S/N) $$<br>$V_{信道}$:信道的极限数据传输速率<br>$W$:带宽<br>$S$信道所传输信号的平均功率<br>$N$信道内部的高斯噪声功率<br>$S/N$：信噪比，单位dB。$S/N = 10log_{10}(S/N) $</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>特点  </p><ul><li>将两个或多个以太网通过网桥连接起来成为一个网段</li><li>具有寻址和路径选择能力</li><li>能在不同或相同的LAN之间存储并转发帧</li><li>对接受的帧不做任何修改或只对封装格式做少量修改</li><li>通过执行帧翻译互联不同类型的局域网<br>优点：</li><li>过滤信息通道</li><li>扩大物理范围</li><li>可互联不同类型的局域网</li><li>提高可靠性</li><li>改善性能</li><li>采用存储转发</li></ul><p>缺点：</p><ul><li>增加时延</li><li>没有流量控制</li></ul><p>路径选择<br>透明网桥(对主机透明)：自学习算法 选择的不是最佳路由<br>源路由网桥(对主机不透明)：以广播的方式检测来找到最佳路由</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>实质是多端口网桥<br>特点：</p><ul><li>全双工</li><li>一般直接与局域网的主机相连</li><li>采用直通方式转发</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h3 id="流量控制原理"><a href="#流量控制原理" class="headerlink" title="流量控制原理"></a>流量控制原理</h3><ol><li>停止-等待流量控制</li><li>滑动窗口流量控制<h3 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h3></li><li>确认</li><li>超时重传</li><li>自动重传请求(ARQ)<h3 id="具体实现协议"><a href="#具体实现协议" class="headerlink" title="具体实现协议"></a>具体实现协议</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议()"></a>停止等待协议()</h4></li></ol><ul><li>使用单帧滑动窗口</li><li>双方需要设置一个帧的缓冲区。采用1个比特对帧编号。</li><li>发送端在发送数据时保留帧的副本，用以重传。当接收到ACK时，清除此副本。</li><li>缺点：利用率低</li></ul><h4 id="后退N帧协议-BRN"><a href="#后退N帧协议-BRN" class="headerlink" title="后退N帧协议(BRN)"></a>后退N帧协议(BRN)</h4><ul><li>使用多帧滑动窗口</li><li>保证接收方只能按顺序接受帧。当发送方发送N帧后，如果N个帧之前的帧在计时器超时未收到ACK，则重发该错误帧及其随后的N个帧。</li><li>接收方的接收窗口为1，采用n个比特对帧编号。</li><li>发送窗口的大小应该为$1 \leq W_T \leq 2^n -1$ 。若$W_T &gt; 2^n - 1$，则会使接收方无法分辨新帧和旧帧</li><li>缺点：信道传输质量很差容易导致误码率过大时，效率很低</li></ul><h4 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h4><ul><li>使用多帧滑动窗口</li><li>需要$接收窗口W_R + 发送窗口W_T \leq 2^n$ 用以保证新窗口和旧窗口序号没有重叠的部分。</li><li>同时需要满足$W_R \leq W_T$，接收窗口最大值时，$W_{Tmax} = W_{Rmax} = 2^{(n-1)}$</li><li>SR可以避免重复传送的那些到达接收端的数据帧。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>特点：  </p><ul><li>面向字节</li><li>点对点协议，不支持多点线路</li><li>提供差错检测但不纠错</li><li>支持全双工</li><li>组成部分<ul><li>链路控制协议LCP</li><li>网络控制协议NCP</li><li>将IP报封装成串行链路的方法</li></ul></li></ul><h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>特点：</p><ul><li>面向比特</li><li>使用0比特插入法实现透明传输</li><li>使用CRC检验 </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7/</url>
      
        <content type="html"><![CDATA[<p>组帧<br>解决的问题</p><ol><li>帧定界：在数据的首部和尾部添加控制信息。作用就是确定帧的界限</li><li>帧同步：接收方应当能从接收到的二进制比特流中区分帧的起始和终止</li><li>透明传输：解决数据中恰好与帧定界符相同的比特组合而丢弃帧的问题</li></ol><p>解决方式</p><ol><li>字符计数法<br> 在首部添加一个计数字段来表明帧内的字符数用以解决上述三个问题。</li><li>字符填充的首尾定界法<ul><li>对于帧定界和帧同步，通过首尾添加特殊字符来界定帧的开始与结束</li><li>对于透明传输，在内容当中添加转义字符来加以区分</li></ul></li><li>比特填充的首尾标志法<ul><li>对于帧定界和帧同步，首尾使用01111110 来表示帧开始和结束</li><li>对于透明传输，发送方如果信息中遇到5个连续的1，则在其后插入一个0。接收方反之</li></ul></li><li>违规编码法<br> 采用曼切斯特编码。无需填充技术就能保证透明传输。因为其将1和0编码成高低电平对和地高电平对。可以使用高高电平对和低低电平对来表示界限。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>差错产生原因</p><ul><li>信号固有的，持续存在的随机热噪声</li><li>外界特定的短暂原因所造成的冲击噪声<br>解决方法：  </li></ul><ol><li>检错编码</li><li>1 奇偶校验码</li><li>2 <strong>循环冗余码</strong></li><li>纠错编码</li><li>1 <strong>海明码</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/02/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>介质访问控制<br>目的：防止两对节点之间的通信不会互相干扰<br>控制方法：</p><ol><li>频分多路复用(FDM)</li><li>时分多路复用(TDM)</li><li>波分多路复用(WDM)</li><li>码分多路复用(CDM)<br> 码分多址(CDMA)是码分多路复用的一种方式。原理是使用向量的规格化内积。</li></ol><p>随机访问介质访问控制<br>思想：胜利者通过争用获得信道，从而获得信息的发送权。<br>采用协议</p><ol><li>ALOHA协议<ul><li>纯ALOHA<br>不检测就直接发送数据，一段时间内没有收到确认就重传。<br>重传策略：让各站随机等待一段时间，再进行重传</li><li>时隙ALOHA<br>各站时间同一起来，并划分成等长的时隙，规定只能在时隙开始前发送帧<br>重传策略：让各站随机等待一段时间，再进行重传   </li></ul></li><li>CSMA协议<ul><li>1-坚持CSMA<br>思想：发送数据时侦听信道，忙则等待，空闲则立即发送。</li><li>非坚持CSMA<br>思想：发送数据时侦听信道，忙则放弃监听，等待一个随机事件后再侦听，空闲则发送。</li><li>p-坚持CSMA<br>思想：发送数据时侦听信道，忙则下一时隙再监听，空闲则以p概率发送数据。</li></ul></li><li>CSMA/CD<br> 载波侦听多路访问/碰撞检测<br> 适用于总线型和半双工性网络<br> 思想：先监听后发送，边监听边发送，冲突停发，随机重发<br> 采用截断二进制指数退避算法解决碰撞问题<br> 以太网规定的最短帧长为64B，最小帧长 = 总线传播时延 * 数据传输速率 * 2</li><li>CSNA/CA协议<br> 载波侦听多路访问/碰撞避免<br> 适用于无线网络<br> 采用预约信道、ACK帧、RTS/CTS帧来实现碰撞避免</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/network/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2021/05/02/network/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么TCP-需要3次握手"><a href="#为什么TCP-需要3次握手" class="headerlink" title="为什么TCP 需要3次握手"></a>为什么TCP 需要3次握手</h1><p>为什么三次？</p><p>1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>2、换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</p><p>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</p><p>其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。</p><p>比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>ref：<a href="https://zhuanlan.zhihu.com/p/108822858">https://zhuanlan.zhihu.com/p/108822858</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/9.%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/9.%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="LeetCode-9-Palindrome-Number"><a href="#LeetCode-9-Palindrome-Number" class="headerlink" title="### LeetCode 9. Palindrome Number"></a>### LeetCode 9. Palindrome Number</h5><h4 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9.Palindrome Number"></a>9.Palindrome Number</h4><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><h5 id="求出回文数对比"><a href="#求出回文数对比" class="headerlink" title="求出回文数对比"></a>求出回文数对比</h5><p>将数字反转进行对比。可以参考LeetCode 7 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = x;</span><br><span class="line">    <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;          </span><br><span class="line">        res = res* <span class="number">10</span> + (y % <span class="number">10</span>);</span><br><span class="line">        y = y/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x==res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h5><p>将数字转换成字符串，然后使用两个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/4.%E6%B1%82%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/4.%E6%B1%82%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="有序数组的中位数"><a href="#有序数组的中位数" class="headerlink" title="有序数组的中位数"></a>有序数组的中位数</h3><h4 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h4><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">nums1 &#x3D; [1, 3]nums2 &#x3D; [2]The median is 2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="中位数定义法"><a href="#中位数定义法" class="headerlink" title="中位数定义法"></a>中位数定义法</h5><p>求中位数，即求位置在中间的数。这是一种很好理解并实现的方法。根据定义，我们可以使用指针指向最小的数字开始，之后指向到比这个数字大的最小的数字。经过两组数组的长度的一半。即我们要找的中位数。时间复杂度为O((m+n)/2)。空间复杂度为O(1)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> halfLength <span class="token operator">=</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">+</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>halfLength <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> halfLength<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> nums1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            start<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            start<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            start<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            start<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         cur<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">+</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>start<span class="token punctuation">[</span>cur <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>start<span class="token punctuation">[</span>cur <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> start<span class="token punctuation">[</span>cur <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h5><p>按照中位数的定义，如果将一组有序数字分为两半，若这组数字的数字个数为偶数，则中位数为前一半最大的数和后一半最小的数字和的一半。若为数字个数为奇数，则中位数为前一半最大的数。</p><p>对于两组数字。我们可以将其合并为一组数字，然后根据上述的方式进行寻找。</p><p>如数字</p><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5     3 4 5  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们很容易会发现，这个中位数就是 （3+4）/2 = 3.5。</p><p>我们中间可以画一条拆分线，拆分线的左边就是两半中小的数字，右边就是两年中大的数字。</p><pre class="line-numbers language-none"><code class="language-none">1 2 3 | 4 5     3 | 4 5  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于奇数，同理也如此。</p><pre class="line-numbers language-none"><code class="language-none">1 2 3 | 4    3 | 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此我们的任务就是找到 这一条拆分线。</p><p>设置两个指针i 和 j。j 随着 i 动而动。i和j的关系就是 j = (m+n+1)/2 - i，其中m，n为两个数组的长度。我们可以将其短的数组放在前面，将长的数组放在后面整合成新的数组。这么做可以避免j出现溢出的情况。</p><p>调整i，指导找出符合条件的拆分线的条件的i。</p><p>我们要找的拆分线处满足的条件就是 A[i] ≥ B[j - 1]，A[i - 1] ≤ B[j]。</p><pre class="line-numbers language-none"><code class="language-none">3 4 5 1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// to ensure m&lt;=n</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">;</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">;</span> <span class="token class-name">B</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> m<span class="token punctuation">;</span> m <span class="token operator">=</span> n<span class="token punctuation">;</span> n <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> iMin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> iMax <span class="token operator">=</span> m<span class="token punctuation">,</span> halfLen <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iMin <span class="token operator">&lt;=</span> iMax<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>iMin <span class="token operator">+</span> iMax<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> halfLen <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> iMax <span class="token operator">&amp;&amp;</span> <span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            iMin <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// i is too small</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> iMin <span class="token operator">&amp;&amp;</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            iMax <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// i is too big</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// i is perfect</span>            <span class="token keyword">int</span> maxLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> maxLeft <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> maxLeft <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> maxLeft <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> maxLeft<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> minRight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> minRight <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> minRight <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> minRight <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>maxLeft <span class="token operator">+</span> minRight<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二分（转换成寻找第k小的问题）"><a href="#二分（转换成寻找第k小的问题）" class="headerlink" title="二分（转换成寻找第k小的问题）"></a>二分（转换成寻找第k小的问题）</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> total <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length <span class="token operator">+</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getKmin</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>total<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getKmin</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>total <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getKmin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">></span> nums1<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>n <span class="token operator">+</span> k <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> nums2<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>m <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> min1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">int</span> min2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">+</span> k<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        min1 <span class="token operator">=</span> nums1<span class="token punctuation">[</span>m <span class="token operator">+</span> k<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">+</span> k<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        min2 <span class="token operator">=</span> nums2<span class="token punctuation">[</span>n <span class="token operator">+</span> k<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> min1 <span class="token operator">&lt;</span> min2 <span class="token operator">?</span> <span class="token function">getKmin</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>m <span class="token operator">+</span> k<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token operator">-</span>k<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">getKmin</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>m<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>n<span class="token operator">+</span>k<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>k<span class="token operator">-</span>k<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/7.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/7.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-7-Reverse-Integer-反转整数"><a href="#LeetCode-7-Reverse-Integer-反转整数" class="headerlink" title="LeetCode 7. Reverse Integer 反转整数"></a>LeetCode 7. Reverse Integer 反转整数</h3><h4 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h4><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><h5 id="直接反转"><a href="#直接反转" class="headerlink" title="直接反转"></a>直接反转</h5><p>需要注意的是整形的溢出问题。我这里使用结果的值大于MAX/10来判断。</p><p>总结了有几种判断溢出的方法</p><ol><li>使用结果的值大于MAX/10来判断。</li><li>使用双符号位的方法来判断溢出。</li><li>使用乘以10，再除以10，比较两个数的方法来判断溢出。</li><li>使用 异常来捕捉溢出。</li><li>使用更大的数字，如double来判断。</li></ol><p>当然也可以使用双符号位的方法来判断溢出。同样也可以使用乘以10，再除以10，比较两个数的方法来判断溢出。或者使用 异常来捕捉溢出也可以。时间复杂度为O(n)，空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x &gt;= Integer.MAX_VALUE || x &lt;= Integer.MIN_VALUE)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> s = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>( x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           sign = -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> y = Math.abs(x);</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;          </span><br><span class="line">           <span class="keyword">if</span>(res &gt; Integer.MAX_VALUE/<span class="number">10</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           res = res* <span class="number">10</span> + (y % <span class="number">10</span>);</span><br><span class="line">           y = y/<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res * sign;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/371.%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/371.%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="整数加法"><a href="#整数加法" class="headerlink" title="整数加法"></a>整数加法</h3><h4 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h4><p>Calculate the sum of two integers <em>a</em> and <em>b</em>, but you are <strong>not allowed</strong> to use the operator <code>+</code> and <code>-</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h5 id="使用-和-–-运算"><a href="#使用-和-–-运算" class="headerlink" title="使用++ 和 – 运算"></a>使用++ 和 – 运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b; j ++)&#123;</span><br><span class="line">            a ++ ;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &gt; b; j--)&#123;</span><br><span class="line">            a -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用位运算"><a href="#使用位运算" class="headerlink" title="使用位运算"></a>使用位运算</h5><p>原理：二进制加法器</p><table><thead><tr><th>x</th><th>y</th><th>sum</th><th>carry</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>进位的计算放好方式为 x 与 y</p><p>和的计算方式为 x 异或 y</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a;</span><br><span class="line">    <span class="keyword">int</span> carry = b;</span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = sum;</span><br><span class="line">        sum = temp ^ carry;</span><br><span class="line">        carry = (temp &amp; carry) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾Java的位运算符</p><table><thead><tr><th>运算</th><th>运算符</th><th>Demo</th></tr></thead><tbody><tr><td>&lt;&lt;</td><td>左移</td><td>5&lt;&lt;2  = 20 左移2位</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>5&gt;&gt;2  = 1 右移2位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号右移</td><td>-5&gt;&gt;&gt;3 = 536870911</td></tr><tr><td>&amp;</td><td>位与</td><td>5&amp;3 = 1</td></tr><tr><td>|</td><td>位或</td><td>5 | 3 = 7</td></tr><tr><td>~</td><td>非</td><td>~5 = 6</td></tr><tr><td>^</td><td>异或</td><td>5^3 = 6</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><h5 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h5><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><h5 id="末尾置零法"><a href="#末尾置零法" class="headerlink" title="末尾置零法"></a>末尾置零法</h5><p>关键点在于如何处理所给的两个链表长度不一致的情况。</p><p>末尾置零法的关键在于将短的链表长度用0补充直到长度和长度链表的长度相等。这样写代码比较简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//补充链表</span></span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h5><p>链表法相比于末尾置零法，稍微复杂一点，需要判断l1，l2的长度。</p><p>若l1比l2长的话，只需根据l1和进位的情况，判断l1是否要进行修改。如果不需要进行修改，则只需将结果链表的下一个结点指向l1的剩余子链表的第一个结点即可。l2同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//创建头结点</span></span><br><span class="line">    <span class="keyword">int</span> temp = l1.val + l2.val;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">        temp = temp % <span class="number">10</span>;</span><br><span class="line">        carry ++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">    ListNode l4 = l3; <span class="comment">// l4 作为l3的头指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != l1.next &amp;&amp; <span class="keyword">null</span> != l2.next)&#123;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            temp = l1.val + l2.val + carry;</span><br><span class="line">            carry --;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = l1.val + l2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            temp = temp % <span class="number">10</span>;</span><br><span class="line">            carry ++;</span><br><span class="line">        &#125;</span><br><span class="line">        l3.next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">        l3 = l3.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果l1长了，就把l1附在l3的后面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != l1.next)&#123;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span> )&#123;</span><br><span class="line">            temp = l1.val + carry;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                temp = temp % <span class="number">10</span>;</span><br><span class="line">                carry ++;</span><br><span class="line">            &#125;</span><br><span class="line">            l3.next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            carry --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l3.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l3.next.next = l1.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l3 = l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果l2长了，就把l2附在l3的后面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != l2.next)&#123;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span> )&#123;</span><br><span class="line">            temp = l2.val + carry;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                temp = temp % <span class="number">10</span>;</span><br><span class="line">                carry ++;</span><br><span class="line">            &#125;</span><br><span class="line">            l3.next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            carry --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l3.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l3.next.next = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l3 = l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两者长度相等，有进位的话就附加一个进位</span></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        l3.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/12.%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/12.%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-12-Integer-to-Roman-阿拉伯数字转换为罗马数字"><a href="#LeetCode-12-Integer-to-Roman-阿拉伯数字转换为罗马数字" class="headerlink" title="LeetCode 12 Integer to Roman 阿拉伯数字转换为罗马数字"></a>LeetCode 12 Integer to Roman 阿拉伯数字转换为罗马数字</h3><h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h4><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>通过和罗马数字比较进行转换。但是递归效率会很低，很多重复的计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">1000</span> ? <span class="string">&quot;M&quot;</span> + intToRoman(num-<span class="number">1000</span>) : </span><br><span class="line">        num &gt;= <span class="number">900</span> ? <span class="string">&quot;CM&quot;</span> + intToRoman(num-<span class="number">900</span>) :</span><br><span class="line">        num &gt;= <span class="number">500</span> ? <span class="string">&quot;D&quot;</span> + intToRoman(num-<span class="number">500</span>) :</span><br><span class="line">        num &gt;= <span class="number">400</span> ? <span class="string">&quot;CD&quot;</span> + intToRoman(num-<span class="number">400</span>) :</span><br><span class="line">        num &gt;= <span class="number">100</span> ? <span class="string">&quot;C&quot;</span> + intToRoman(num-<span class="number">100</span>) :</span><br><span class="line">        num &gt;= <span class="number">90</span> ? <span class="string">&quot;XC&quot;</span> + intToRoman(num-<span class="number">90</span>) :</span><br><span class="line">        num &gt;= <span class="number">50</span> ? <span class="string">&quot;L&quot;</span> + intToRoman(num-<span class="number">50</span>) :</span><br><span class="line">        num &gt;= <span class="number">40</span> ? <span class="string">&quot;XL&quot;</span> + intToRoman(num-<span class="number">40</span>) :</span><br><span class="line">        num &gt;= <span class="number">10</span> ? <span class="string">&quot;X&quot;</span> + intToRoman(num-<span class="number">10</span>) :</span><br><span class="line">        num &gt;= <span class="number">9</span> ? <span class="string">&quot;IX&quot;</span> + intToRoman(num-<span class="number">9</span>) :</span><br><span class="line">        num &gt;= <span class="number">5</span> ? <span class="string">&quot;V&quot;</span> + intToRoman(num-<span class="number">5</span>) :</span><br><span class="line">        num &gt;= <span class="number">4</span> ? <span class="string">&quot;IV&quot;</span> + intToRoman(num-<span class="number">4</span>) :</span><br><span class="line">        num &gt;= <span class="number">1</span> ? <span class="string">&quot;I&quot;</span> + intToRoman(num-<span class="number">1</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接转换"><a href="#直接转换" class="headerlink" title="直接转换"></a>直接转换</h5><p>递归效率很低，我们可以采用迭代的方式根据转换规则进行转换。将每一个规则看成是一个键值对。建立一个RomanMap对象。然后根据给的数字的大小，与键值对的阿拉伯数字从大到小地进行对比，然后进行转化。这里设置了一个lastPosition的变量来减少比对的顺序。虽然通过建立对象的方式效率会低一点，但是代码的可读性会增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RomanMap</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        String romanNumber;</span><br><span class="line">        </span><br><span class="line">        RomanMap(<span class="keyword">int</span> number,String romanNumber)&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">            <span class="keyword">this</span>.romanNumber = romanNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">String <span class="title">getRomanNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> romanNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;RomanMap&gt; list = <span class="keyword">new</span> ArrayList&lt;RomanMap&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">1000</span>,<span class="string">&quot;M&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">900</span>,<span class="string">&quot;CM&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">500</span>,<span class="string">&quot;D&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">400</span>,<span class="string">&quot;CD&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">100</span>,<span class="string">&quot;C&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">90</span>,<span class="string">&quot;XC&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">50</span>,<span class="string">&quot;L&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">40</span>,<span class="string">&quot;XL&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">10</span>,<span class="string">&quot;X&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">9</span>,<span class="string">&quot;IX&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">5</span>,<span class="string">&quot;V&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">4</span>,<span class="string">&quot;IV&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> RomanMap(<span class="number">1</span>,<span class="string">&quot;I&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> lastPosition = <span class="number">0</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= lastPosition ;i &lt; list.size();i++)&#123;</span><br><span class="line">                RomanMap map = list.get(i);</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= map.getNumber())&#123;</span><br><span class="line">                    num -= map.getNumber();</span><br><span class="line">                    result.append(map.getRomanNumber());</span><br><span class="line">                    i--;</span><br><span class="line">                    lastPosition = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="13-罗马数字转阿拉伯数字"><a href="#13-罗马数字转阿拉伯数字" class="headerlink" title="13. 罗马数字转阿拉伯数字"></a>13. 罗马数字转阿拉伯数字</h3><h4 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h4><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><h5 id="从头往后扫描转换"><a href="#从头往后扫描转换" class="headerlink" title="从头往后扫描转换"></a>从头往后扫描转换</h5><p>根据阿拉伯数字和罗马数字的关键建立映射。只需遍历整个字符串一次，通过映射关系找到对应的阿拉伯数字的值，然后相加即可。对于IV这样子的罗马数字，采用字符比较的方式进行判定。若前一个字符比后一个字符所代表的意思小的话，那么应该减去前一个字符的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            put(<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">            put(<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>);</span><br><span class="line">            put(<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">            put(<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">            put(<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = map.get(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sLen ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = map.get(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> cur = map.get(s.charAt(i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur &lt;= pre)&#123;</span><br><span class="line">                result += cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += (cur - <span class="number">2</span> * pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从后往前转换"><a href="#从后往前转换" class="headerlink" title="从后往前转换"></a>从后往前转换</h5><p>同样也可以从后往前转换。处理IV这样子的数字的时候，采用的处理方式也和刚才一样。当遇到I时，和上一个扫过的V进行对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            put(<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">            put(<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>);</span><br><span class="line">            put(<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">            put(<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">            put(<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(cur &lt; n)&#123;</span><br><span class="line">                result -= cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += cur;</span><br><span class="line">            &#125;</span><br><span class="line">            n = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%BA%94%E7%94%A8/11.%20Container%20With%20Most%20Water%20%E5%AE%B9%E5%99%A8%E6%9C%80%E5%A4%A7%E6%B0%B4%E5%AE%B9%E9%87%8F/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%BA%94%E7%94%A8/11.%20Container%20With%20Most%20Water%20%E5%AE%B9%E5%99%A8%E6%9C%80%E5%A4%A7%E6%B0%B4%E5%AE%B9%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="11-Container-With-Most-Water-容器最大水容量"><a href="#11-Container-With-Most-Water-容器最大水容量" class="headerlink" title="11. Container With Most Water 容器最大水容量"></a>11. Container With Most Water 容器最大水容量</h3><h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h4><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><p>本质上就是求容量的大小问题。使用左右指针从两边向中间扫描，扫描的时候计算出当前指针位置上的容器体积并和之前最大的容器体积进行比较，取最大的容器体积。计算体积的告诉是由两边最低的高度所决定的。最后输出容器体积的最大结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea,Math.min(height[left],height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%BD%A2/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-8-String-to-Integer-atoi-字符串转整形"><a href="#LeetCode-8-String-to-Integer-atoi-字符串转整形" class="headerlink" title="LeetCode 8. String to Integer (atoi) 字符串转整形"></a>LeetCode 8. String to Integer (atoi) 字符串转整形</h3><h4 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h4><p>Implement <code>atoi</code> which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p><strong>Note:</strong></p><ul><li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical </span><br><span class="line">             digit or a +&#x2F;- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure><h5 id="直接转换"><a href="#直接转换" class="headerlink" title="直接转换"></a>直接转换</h5><p>本题的关键的地方是要对一些边界情况和特殊的字符情况进行处理。由例子3我们可以知道，对于开头非0的字符串。我们需要对前两个字符进行处理</p><p>对于开头为空的字符串，我们可以先去掉空置，然后对剩余的字符串进行统一处理。</p><p>之后我们分为以下几种情况。</p><ol><li><p>首先开头的字符串不为 ‘+’，‘-’和数字。那么直接返回的就是0</p></li><li><p>开头为 ‘+’或者 ‘-’。那么需要查看这个字符串的长度，如果长度仅仅为1的话，那么返回也依旧是0。如过长度是大于1的情况，就需要进一步判断第二个字符。</p><ol><li>如果第二个字符为数字，那么就继续对剩余的数字进行判断。</li><li>如果第二个字符是非数字，那么也直接返回0.</li></ol></li><li><p>在判断为前两个数字以后，剩余就继续判断剩余的字符。如果当中出现了非数字的字符，则直接返回目前的数字。</p></li><li><p>字符可以表示的数字范围会比整数要大，因此需要判断这个转换后的数字有没有溢出。如果出现上溢，则返回最大值的整数值。出现下溢，则返回最小的整数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    str = str.trim();</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(str.charAt(i)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        sign = -<span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( i == <span class="number">0</span> &amp;&amp;str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!isNumber(str.charAt(i)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= len -<span class="number">1</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isNumber(str.charAt(i)))&#123;</span><br><span class="line">                res = res * <span class="number">10</span> + (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span>? Integer.MAX_VALUE:Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)res*sign ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (str &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str &gt;= <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用符号位和进位"><a href="#使用符号位和进位" class="headerlink" title="使用符号位和进位"></a>使用符号位和进位</h5><p>和上述同理，只不过不将第一步和第二部单独拿出来进行处理。直接在循环当中进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value = str.toCharArray();</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;<span class="comment">//表示正负号</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//第一个非空格的位置</span></span><br><span class="line">    <span class="comment">//遍历一遍，找出数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:value)</span><br><span class="line">    &#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            result *= <span class="number">10</span>;</span><br><span class="line">            result += (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> &amp;&amp; index == <span class="number">1</span>)&#123;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span> &amp;&amp; index == <span class="number">1</span>)&#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span> &amp;&amp; index == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">// 非数字符号空格的，直接返回 0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看数字是否越界</span></span><br><span class="line">    <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(result * sign);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/6.Z%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/6.Z%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-6-ZigZag-ConversionZ字形转换"><a href="#LeetCode-6-ZigZag-ConversionZ字形转换" class="headerlink" title="LeetCode 6. ZigZag ConversionZ字形转换"></a>LeetCode 6. ZigZag ConversionZ字形转换</h3><h4 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h4><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure><h5 id="直接跳转法-横着走"><a href="#直接跳转法-横着走" class="headerlink" title="直接跳转法(横着走)"></a>直接跳转法(横着走)</h5><p>按照规律走，对于第一行和最后一行，我们能够能发现，一个元素到他的下一个元素的距离为2 * numRow - 2。</p><p>对于中间的元素，我们能都发现他的下一元素与其步长有关。我们可以从每列的第一个元素A开始算起，到满列的元素C的距离为2 * numRow - 2。达到下一个满列元素之前必然会遇到一个元素B。即A-&gt;B-&gt;C的总距离为2 * numRow - 2。同时有A-&gt;B 的距离加上 B-&gt;C的距离等于总距离。因此步长为step(B -&gt; C) = 2 * numRows - 2 - step(A-&gt;B)。</p><p>上述很容易通过画出图以及下标来进行验证。这样时间复杂度为O(n)，空间复杂度为O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i = i + <span class="number">2</span> * numRows - <span class="number">2</span>)&#123;</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">2</span>*i;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">                res.append(s.charAt(index));</span><br><span class="line">                step = <span class="number">2</span> * numRows - <span class="number">2</span> - step;</span><br><span class="line">                index += step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numRows - <span class="number">1</span>; i &lt; len; i = i + <span class="number">2</span> * numRows - <span class="number">2</span>)&#123;</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="拉链法（竖着走）"><a href="#拉链法（竖着走）" class="headerlink" title="拉链法（竖着走）"></a>拉链法（竖着走）</h5><p>拼接法是按着原来的字符串的顺序走。与拉链法类似。设置一个长度为numRows的数组，每个数组对应着一个链表。然后将字符串的每个字符加入到对应的位置。按链表的方式输出字符串。这样时间复杂度为O(n)，空间复杂度为O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">        rows.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        rows.get(curRow).append(c);</span><br><span class="line">        <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">        curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (StringBuilder row : rows) ret.append(row);</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E5%AD%90%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E5%AD%90%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="最长子回文串"><a href="#最长子回文串" class="headerlink" title="最长子回文串"></a>最长子回文串</h3><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h4><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>如果一个字符串为回文串，那么除去他的首尾一个字符，得到的新字符依旧是回文串。即对于一个字符串S有</p><p>p(i,j) = p(i+1,j-1) and Si = Sj。P(i,j)表示从i到j的字符串。</p><p>从表达式可以看出，需要知道p(i,j)，必须先知道p(i+1,j-1)。不如将外层循环倒置过来，先求i+1的值，再求j-1的值。</p><p>还有一点要注意的是初始值，关于j - i &lt;3。如果长度为1的话，那么这个字符串必然为回文串，如果长度为2的话，又满足Si = Sj 那么他也必然是回文串。即他们不受上述表达式的约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">    String res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i&gt;= <span class="number">0</span> ;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">            dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp;(j - i &lt; <span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; (res == <span class="keyword">null</span> || j - i + <span class="number">1</span> &gt; res.length()))&#123;</span><br><span class="line">                res = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h5><p>首先先看一下回文串有什么特点，回文串的最大特点就是中心对齐。如“ababa”，他是以a为中心对齐。那么对于“abba”这种偶数的回文串，同样也是中心对齐的。他以两个b之间的字符之间为中心。因此我们可以以数组的每一个元素作为中心，找出最大的回文串。</p><p>我们可以设置回文串的头尾指针，start 和 end。如果有比目前的回文串更长的回文串，则修改start和end的的位置。这样子时间复杂度为O(n^2),空间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1,len2);</span><br><span class="line">        <span class="keyword">if</span>(len &gt; end - start)&#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            end = i + len/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left,R = right;</span><br><span class="line">    <span class="keyword">while</span>(L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R))&#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="马拉车算法-Manacher’s-Algorithm"><a href="#马拉车算法-Manacher’s-Algorithm" class="headerlink" title="马拉车算法(Manacher’s Algorithm)"></a>马拉车算法(Manacher’s Algorithm)</h5><p>马拉车算法充分应用了回文串的对称性。和中心扩展法一样，我们以某个节点为中心，分别向两边扩展。为了保持字符的个数为奇数，在字符与字符之间插入特殊符号“#”来保证出力的字符个数是为奇数的。如“abab”变为“#a#b#a#b#”。假设新的字符串为T，我们使用P[i] 表示 T[i]处的回文半径。如以T[i]为中心的最长回文串为T[l,r]，则P[i] = r - i + 1。这样求最长回文串的问题就转换为求数组P的问题了。</p><p>数组P怎么求，考虑。center 表示之前取得最大回文串的中心位置。right表示最大回文串能到达的最右端的值。</p><ol><li>若i&lt;right，则i之前的值必然计算出来了。我们可以利用回文串的性质。找出点i关于center的对称点j。j = 2* center - i。<ol><li>如果P[j] &lt; right -i。即以j为中心的回文串没有超出[left,right]的范围，由回文串的性质知道，两端的对应字符应该是相等的。所以有P[j] = P[i]。</li><li>如果P[j] &gt;= right -i。即表明以j为中心的最大回文串超出了范围。在范围内的部分肯定是复合回文串的性质，但是对于超出的部分，只要从right+1开始一一匹配，从而更新right和对应的center，</li></ol></li><li>若i &gt; right 无法利用回文串的性质，只能一步一步去匹配。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">       StringBuilder t = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="comment">// t.append(&quot;$&quot;);</span></span><br><span class="line">       t.append(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++)&#123;</span><br><span class="line">           t.append(s.charAt(i));</span><br><span class="line">           t.append(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">       &#125; </span><br><span class="line">    </span><br><span class="line">       <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">       <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxCenter =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> *sLen + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; ++i)&#123;</span><br><span class="line">           </span><br><span class="line">           p[i] = i&lt;right?Math.min(p[<span class="number">2</span>*center -i],right -i):<span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(i - p[i] &gt;= <span class="number">0</span> &amp;&amp; i + p[i]&lt;tLen &amp;&amp; t.charAt(i - p[i]) == t.charAt(i + p[i]))&#123;</span><br><span class="line">               p[i]++;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(right &lt; i + p[i])&#123;</span><br><span class="line">               right = i + p[i];</span><br><span class="line">               center = i;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(maxLen &lt; p[i])&#123;</span><br><span class="line">               maxLen = p[i];</span><br><span class="line">               maxCenter = i;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;        </span><br><span class="line">       <span class="keyword">return</span> s.substring((maxCenter - maxLen + <span class="number">1</span>)/<span class="number">2</span>,(maxCenter - maxLen + <span class="number">1</span>)/<span class="number">2</span> + maxLen - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h3><h4 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ol><li>设置左指针left和右指针right</li><li>置Map表示左指针和右指针之间的字母</li><li>右指针先走，把没有遇到过重复的字母加入Map中。记录长度</li><li>如果遇到已经在Map中的字母，则左指针走一步。 并从map中删除</li><li>直到右指针走到头。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">            set.add(s.charAt(j++));</span><br><span class="line">            ans = Math.max(ans, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="滑动窗口改进"><a href="#滑动窗口改进" class="headerlink" title="滑动窗口改进"></a>滑动窗口改进</h5><p>在滑动窗口中，左指针是一步一步走的。然而实际上并不需要一步一步走，可以直接到上一次该字母的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(right &lt; length)&#123;</span><br><span class="line">        Character cur = s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(cur) &amp;&amp; map.get(cur) &gt; left)&#123;</span><br><span class="line">            left = map.get(cur);</span><br><span class="line">            map.put(cur,right + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(cur,right + <span class="number">1</span>);</span><br><span class="line">            maxLength = Math.max(maxLength,right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/43.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/43.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h3><h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43.Multiply Strings"></a>43.Multiply Strings</h4><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure><h5 id="进位和计算同时进行"><a href="#进位和计算同时进行" class="headerlink" title="进位和计算同时进行"></a>进位和计算同时进行</h5><p>按照平常的思维去计算，一边做乘法，一边进行加法进位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = num1.length();</span><br><span class="line">    <span class="keyword">int</span> length2 = num2.length();         </span><br><span class="line">    <span class="keyword">int</span>[] cal = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = i + j;</span><br><span class="line">            <span class="keyword">int</span> p2 = i + j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + cal[p2];</span><br><span class="line">            cal[p2] = cur % <span class="number">10</span>;</span><br><span class="line">            cal[p1] += cur/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换成字符串</span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: cal)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.length() != <span class="number">0</span> || i != <span class="number">0</span> )&#123;</span><br><span class="line">            result.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.length() == <span class="number">0</span>? <span class="string">&quot;0&quot;</span>:result.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进位和计算分步进行"><a href="#进位和计算分步进行" class="headerlink" title="进位和计算分步进行"></a>进位和计算分步进行</h5><p>分步进行的思想实际上运用了进制的思想。采取两步走的策略。首先不如将其看成百进制，之后再将百进制转换为十进制。</p><p>对于个位数的乘法，必然结果小于100，即不存在进位。因此首先转换为百进制。</p><p>然后对于百进制的转换，说白了就是处理进位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = num1.length();</span><br><span class="line">    <span class="keyword">int</span> length2 = num2.length();</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[length1 + length2];</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length1 - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            result[i + j + <span class="number">1</span>] += (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = result.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        result[i] += carry;</span><br><span class="line">        carry = result[i]/<span class="number">10</span>;</span><br><span class="line">        result[i] %= <span class="number">10</span>;</span><br><span class="line">        result[i] += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理字符串前的0</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; result.length - <span class="number">1</span> &amp;&amp; result[begin] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        begin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result,begin,result.length - begin);            </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/10%20.%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/10%20.%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-10-正则匹配"><a href="#LeetCode-10-正则匹配" class="headerlink" title="LeetCode 10 .正则匹配"></a>LeetCode 10 .正则匹配</h3><h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h4><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;.&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p>递归实现最大的缺点就是效率低，因为需要进行很多重复的运算。</p><p>我们可以对字符逐一进行匹配。容易发现，对于‘*’来讲，需要对对应字符串的后序字符串进行匹配。对于‘.’来讲，它对应着任何字符，将与其匹配的所有字符都视为匹配成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> first_match = (!s.isEmpty() &amp;&amp; (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (isMatch(s,p.substring(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substring(<span class="number">1</span>),p)));</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h5><p>我们可以使用一个数组记录已经计算过的结果结果，以避免重复的计算。也就是使用动态规划的思想。</p><h6 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Boolean[][] result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span> ];</span><br><span class="line">        <span class="comment">// return result[0][0];</span></span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>,s,p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> sIndex, <span class="keyword">int</span> pIndex,String s, String p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[sIndex][pIndex] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[sIndex][pIndex] == <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> ans;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">        <span class="keyword">if</span>(pIndex == pLen)&#123;</span><br><span class="line">            ans = sIndex == sLen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> first_match = (sIndex &lt; sLen) &amp;&amp; (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(pIndex + <span class="number">1</span> &lt; pLen &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                ans = dp(sIndex,pIndex+<span class="number">2</span>,s,p) || first_match &amp;&amp; dp(sIndex+<span class="number">1</span>,pIndex,s,p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; dp(sIndex+<span class="number">1</span>,pIndex+<span class="number">1</span>,s,p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result[sIndex][pIndex] = ans?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">        dp[text.length()][pattern.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = text.length(); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                        pattern.charAt(j) == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NFA-（非自动性有穷向量机）"><a href="#NFA-（非自动性有穷向量机）" class="headerlink" title="NFA （非自动性有穷向量机）"></a>NFA （非自动性有穷向量机）</h5><p>可以使用编译原理中的非自动性有穷向量机来处理。将正则表达式看成是一种语言。然后根据输入进行状态转换。简单来讲就是：假设初始状态为A，当接收到输入为*的值，就进入状态B。而正则匹配的原理可以参考如下链接</p><p>原理：<a href="https://swtch.com/~rsc/regexp/regexp1.html">https://swtch.com/~rsc/regexp/regexp1.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> ONE= <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MANY= <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> SPLIT= <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> END= <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        <span class="keyword">return</span> nfa(s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">char</span> c;    <span class="comment">// state char</span></span><br><span class="line">        <span class="keyword">public</span> State out1;  <span class="comment">// next state 1</span></span><br><span class="line">        <span class="keyword">public</span> State out2;  <span class="comment">// next state 2 (for split state only)</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id= id;</span><br><span class="line">            <span class="keyword">this</span>.c= c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id*c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id==((State)o).id &amp;&amp; c==((State)o).c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nfa</span><span class="params">(String s, String p)</span></span>&#123;</span><br><span class="line">        State match= <span class="keyword">new</span> State(p.length(), END);</span><br><span class="line">        Set&lt;State&gt; clist= <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">// current list of states</span></span><br><span class="line">        Set&lt;State&gt; nlist= <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">// next list of states</span></span><br><span class="line">        </span><br><span class="line">        State start= buildNfa(p, match);</span><br><span class="line">        addState(clist, start); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length() &amp;&amp; !clist.isEmpty(); i++)&#123;</span><br><span class="line">            step(clist, s.charAt(i), nlist);</span><br><span class="line">            Set&lt;State&gt; temp= clist;</span><br><span class="line">            clist= nlist;</span><br><span class="line">            nlist= temp;</span><br><span class="line">            nlist.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasMatch(clist, match);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step</span><span class="params">(Set&lt;State&gt; clist, <span class="keyword">char</span> c, Set&lt;State&gt; nlist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(State state:clist)</span><br><span class="line">            <span class="keyword">if</span> (state.c==ONE &amp;&amp; state.out1!=<span class="keyword">null</span>)</span><br><span class="line">                addState(nlist, state.out1);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==state.c &amp;&amp; state.out1!=<span class="keyword">null</span>)</span><br><span class="line">               addState(nlist, state.out1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addState</span><span class="params">(Set&lt;State&gt; list, State state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state.c==SPLIT)&#123;</span><br><span class="line">            addState(list, state.out1);</span><br><span class="line">            addState(list, state.out2);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(state);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasMatch</span><span class="params">(Set&lt;State&gt; list, State match)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.contains(match);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">buildNfa</span><span class="params">(String p, State match)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= p.length();</span><br><span class="line">        State start= <span class="keyword">null</span>;</span><br><span class="line">        State prev_state= <span class="keyword">null</span>, state= <span class="keyword">null</span>, split= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;p.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c= p.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> next_c= i&lt;n-<span class="number">1</span> ? p.charAt(i+<span class="number">1</span>) : END;</span><br><span class="line">            <span class="keyword">if</span> (next_c==MANY)&#123;</span><br><span class="line">                split= <span class="keyword">new</span> State(i+<span class="number">1</span>, SPLIT);  <span class="comment">// split state character</span></span><br><span class="line">                state= <span class="keyword">new</span> State(i, c);</span><br><span class="line">                split.out2= state;</span><br><span class="line">                state.out1= split;</span><br><span class="line">                <span class="keyword">if</span> (prev_state!=<span class="keyword">null</span>) prev_state.out1= split;</span><br><span class="line">                <span class="keyword">if</span> (start==<span class="keyword">null</span>) start= split;</span><br><span class="line">                prev_state= split;</span><br><span class="line">                i++; <span class="comment">// consume 2 characters</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                state= <span class="keyword">new</span> State(i, p.charAt(i));</span><br><span class="line">                <span class="keyword">if</span> (prev_state!=<span class="keyword">null</span>) prev_state.out1= state;</span><br><span class="line">                <span class="keyword">if</span> (start==<span class="keyword">null</span>) start= state;</span><br><span class="line">                prev_state= state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev_state.out1= match;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%8A%80%E5%B7%A7/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="位技巧"><a href="#位技巧" class="headerlink" title="位技巧"></a>位技巧</h1><h2 id="判断一个数是不是2的n次方"><a href="#判断一个数是不是2的n次方" class="headerlink" title="判断一个数是不是2的n次方"></a>判断一个数是不是2的n次方</h2><p>若一个数x是2的n次方，则由x &amp; (x-1) = 0</p><h1 id="栈的技巧"><a href="#栈的技巧" class="headerlink" title="栈的技巧"></a>栈的技巧</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ol start="84"><li>柱状图中最大的矩形</li><li>下一个更大元素 I</li><li>下一个更大元素 II<br>面试题 17.21. 直方图的水量</li></ol><h1 id="队列的技巧"><a href="#队列的技巧" class="headerlink" title="队列的技巧"></a>队列的技巧</h1><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ol><li>  分割回文串</li></ol><h1 id="插槽的思想和替换的思想"><a href="#插槽的思想和替换的思想" class="headerlink" title="插槽的思想和替换的思想"></a>插槽的思想和替换的思想</h1><ol><li>  验证二叉树的前序序列化</li></ol><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>防止溢出，计算mid采用 left + (right - left)/2 的方式避免</p><ul><li><ol start="69"><li>x 的平方根：使用long防止int相乘溢出</li></ol></li><li><ol start="374"><li>猜数字大小</li></ol></li></ul><h1 id="素数？"><a href="#素数？" class="headerlink" title="素数？"></a>素数？</h1><h2 id="素数的定义"><a href="#素数的定义" class="headerlink" title="素数的定义"></a>素数的定义</h2><p>在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性。</p><h2 id="为什么在hash表中使用素数"><a href="#为什么在hash表中使用素数" class="headerlink" title="为什么在hash表中使用素数"></a>为什么在hash表中使用素数</h2><p>哈希表设计目的就是希望尽量的随机散射，不希望这些在同一列上的元素（也就是会冲突的元素）之间具有关系，所以我们都采用素数作为哈希表的大小，从而避免模数相同的数之间具备公共因数<br>参考：<a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">https://blog.csdn.net/zhishengqianjun/article/details/79087525</a></p><h1 id="动态规划六步"><a href="#动态规划六步" class="headerlink" title="动态规划六步"></a>动态规划六步</h1><ol><li>看最后一步</li><li>子问题</li><li>递推关系</li><li>f(x)表达</li><li>初始条件和边界</li><li>计算顺序</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%BD%92%E6%A1%A3/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%BD%92%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol start="53"><li>最大子序和</li><li>比特位计数(最低有效位，最高有效位，最低设置位)</li><li>最长递增子序列</li><li>俄罗斯套娃信封问题（300最长递增子序列二维版）</li></ol><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><ol start="355"><li>目标和</li><li>最后一块石头的重量 II</li></ol><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><ol><li> 最大子序和</li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>剑指 Offer 32 - I. 从上到下打印二叉树<br>117. 填充每个节点的下一个右侧节点指针 II</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol start="206"><li>反转链表</li><li>反转链表 II</li></ol><h1 id="数据结构构造"><a href="#数据结构构造" class="headerlink" title="数据结构构造"></a>数据结构构造</h1><ol><li>  设计哈希集合，拉链法构造哈希表</li><li>  设计循环队列</li><li>  设计哈希映射</li><li>  二叉搜索树迭代器构造</li><li>实现 Trie (前缀树)</li></ol><h2 id="前缀和-HashMap"><a href="#前缀和-HashMap" class="headerlink" title="前缀和+ HashMap"></a>前缀和+ HashMap</h2><ol start="523"><li>连续的子数组和</li><li>连续数组</li></ol><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ol start="494"><li>目标和</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>2021/05/02/leetcode%E9%A2%98%E8%A7%A3/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ol><li>组合问题</li><li>切割问题</li><li>子集问题</li><li>排列问题</li><li>棋盘问题</li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><pre class="line-numbers language-none"><code class="language-none">void backTracking(参数)&#123;    if（终止条件）&#123;        收集结果;        return    &#125;    for(遍历集合元素)&#123;        处理节点;        递归函数;        回溯操作;    &#125;    return &#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">res &#x3D; []path &#x3D; []def backtrack(未探索区域, res, path):    if 未探索区域满足结束条件:        res.add(path) # 深度拷贝        return    for 选择 in 未探索区域当前可能的选择:        if 当前选择符合要求:            path.add(当前选择)            backtrack(新的未探索区域, res, path)            path.pop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol start="78"><li>子集</li><li>子集 II</li><li> 目标和</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/Docker/Docker%E7%9B%91%E6%8E%A7/"/>
      <url>2021/05/02/Docker/Docker%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-监控"><a href="#Docker-监控" class="headerlink" title="Docker 监控"></a>Docker 监控</h1><h2 id="使用-docker-stats-命令"><a href="#使用-docker-stats-命令" class="headerlink" title="使用 docker stats 命令"></a>使用 docker stats 命令</h2><p>docker stats命令可以很方便地看到主机上所有容器的 CPU、内存、网络 IO、磁盘 IO、PID 等资源的使用情况</p><h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><p>cAdvisor 是谷歌开源的一款通用的容器监控解决方案。cAdvisor 不仅可以采集机器上所有运行的容器信息，还提供了基础的查询界面和 HTTP 接口，更方便与外部系统结合。所以，cAdvisor很快成了容器指标监控最常用组件，并且 Kubernetes 也集成了 cAdvisor 作为容器监控指标的默认工具<br>cAdvisor 监控容器具有以下特点：</p><ol><li>可以同时采集物理机和容器的状态</li><li>可以展示监控历史数据</li></ol><h2 id="监控原理"><a href="#监控原理" class="headerlink" title="监控原理"></a>监控原理</h2><p>Docker 是基于 Namespace、Cgroups 和联合文件系统实现的<br>Cgroups 不仅可以用于容器资源的限制，还可以提供容器的资源使用率。无论何种监控方案的实现，底层数据都来源于 Cgroups。<br>Cgroups 的工作目录为/sys/fs/cgroup</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>2021/05/02/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="多益网络"><a href="#多益网络" class="headerlink" title="多益网络"></a>多益网络</h2><ol><li>常见攻击类型sql注入防治，ddos防治</li><li>Ngnix分发策略：hash,轮询有什么区别</li><li>磁盘的Raid模式</li><li>Linux的iptables</li><li>普罗米修斯的监控</li><li>HTTPS加密策略</li></ol><h2 id="网上面试题整理"><a href="#网上面试题整理" class="headerlink" title="网上面试题整理"></a>网上面试题整理</h2><p>计算机网络：<a href="https://zhuanlan.zhihu.com/p/24001696">https://zhuanlan.zhihu.com/p/24001696</a></p><h2 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h2><ol><li>在网址中输入URL之后，发生了什么</li><li>Nosql数据库和sql数据库的区别</li><li>Vue的了解</li><li>介绍Java内存模型（JMM）</li><li>如何排查CPU 过高的问题<br>如何具体定位到某行代码？具体思路，定位进程，查看线程，打印Java堆栈，可借助arthas工具。对于非Java程序呢？<br>没有指具体是CPU，对于应用服务器的CPU，那对于数据库服务器的CPU，Web服务器的呢？<br>Ref：<a href="https://www.cnblogs.com/you-men/p/13382659.html">https://www.cnblogs.com/you-men/p/13382659.html</a></li><li>Shell脚本如何区分bash和dash(首行注解)</li><li>给一台Linux机器，如何区分是使用Bash还是dash(linux的env环境里有配置项)<br><em>Remind：unix/linux 一切皆文件</em></li></ol><h2 id="Flat-incubator"><a href="#Flat-incubator" class="headerlink" title="Flat incubator"></a>Flat incubator</h2><ol><li>中介者模式(MVC架构使用了中介者模式)</li><li>cpu 中的load是如何计算的</li><li>布隆过滤器</li></ol><h2 id="卓动科技"><a href="#卓动科技" class="headerlink" title="卓动科技"></a>卓动科技</h2><ol><li>df -h 磁盘满，du -sh 磁盘少</li><li>数据库的级联更新</li><li>如何优雅的关闭程序</li><li>python切片越界</li><li>CDN基本原理和同步</li><li>判断端口是否存在和Cronjob设置</li><li>业务监控的调用链，性能排查</li></ol><h2 id="钱大妈"><a href="#钱大妈" class="headerlink" title="钱大妈"></a>钱大妈</h2><ol><li>有关zabbix的配置，如何监控网络，netstat的效率不好</li><li>MQ爆了怎么办？（能不能设置消息队列做housekeep？</li><li>同时跑CI/CD，怎么解决？</li></ol><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><ol><li>Java 闭包</li><li>JVM的GC机制 G1垃圾回收器</li><li>如何判断对象是否为垃圾？</li><li>Spring处理请求的流程？</li><li>请求是如何被Spring处理的，Java是如何将请求的body识别为对象？根据什么转化为XML?JSON</li><li>如何保证Java的某个线程在其他线程执行完后再执行</li><li>如何update数据库，Oracle和MySql有什么区别</li><li>如何设计一张表的，数据时常要更新？</li><li>数据库中的varchar和text的区别</li><li>进程是如何通信的？</li><li>如何找出某个进程占用的端口或者是找到某个端口被哪个进程占用？</li><li>有关.socket</li><li>编程题浮点数的N次方</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/thinking/"/>
      <url>2021/05/02/thinking/</url>
      
        <content type="html"><![CDATA[<h1 id="金字塔原理："><a href="#金字塔原理：" class="headerlink" title="金字塔原理："></a>金字塔原理：</h1><p>一件事情可以总结出一个中心思想，这个中心思想可以由三至七个论点支持，每个论点可以由三到七个论据支持</p><h2 id="如何阐释一个问题-运用结构化表达SCQA工具"><a href="#如何阐释一个问题-运用结构化表达SCQA工具" class="headerlink" title="如何阐释一个问题(运用结构化表达SCQA工具)"></a>如何阐释一个问题(运用结构化表达SCQA工具)</h2><ul><li>S(situation)：问题的出现的环境背景</li><li>C(complication)：在该背景下出现了哪些矛盾，常见的类型有三种：哪些预期未达标、哪些流程不顺畅、哪些还存在隐患</li><li>Q(question)：根据背景和冲突自然而然地提出问题，常见类型有四种：应该做什么，应该如何做，是否应该做，为什么会发生</li><li>A(answer)：针对上述问题进行回答</li></ul><h2 id="结构化方式组织回答"><a href="#结构化方式组织回答" class="headerlink" title="结构化方式组织回答"></a>结构化方式组织回答</h2><h3 id="纵向结构"><a href="#纵向结构" class="headerlink" title="纵向结构"></a>纵向结构</h3><h4 id="结论先行-先展示中心思想"><a href="#结论先行-先展示中心思想" class="headerlink" title="结论先行(先展示中心思想)"></a>结论先行(先展示中心思想)</h4><p>包含以下六点方面</p><ul><li>先重要后次要</li><li>先框架后细节</li><li>先总体后细分</li><li>先论点后论据</li><li>先结论后原因</li><li>先结果后过程</li></ul><h4 id="以上统下-5W2H"><a href="#以上统下-5W2H" class="headerlink" title="以上统下(5W2H)"></a>以上统下(5W2H)</h4><ul><li>what</li><li>why</li><li>where</li><li>when</li><li>who</li><li>how</li><li>how much</li></ul><h3 id="横向结构"><a href="#横向结构" class="headerlink" title="横向结构"></a>横向结构</h3><ul><li>归纳推理<ul><li>时间维度：事前、事中、事后；短期、中期、长期</li><li>结构难度：开发组、测试组、运维组</li><li>程度维度：高、中、初；重要、次要、不要</li><li>经验维度：高扩展、高可用、高性能</li></ul></li><li>演绎推理 <ul><li>现象、原因、解决方案</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
      <url>2021/05/02/%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>@RequestParam和@PathVariable的区别</p><p><a href="https://blog.csdn.net/a15028596338/article/details/84976223">https://blog.csdn.net/a15028596338/article/details/84976223</a></p><p>SpringBoot 一些常用的注解</p><p>JPA实现</p><p>配置跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在controller里面添加注解</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/02/Hadoop/"/>
      <url>2021/05/02/Hadoop/</url>
      
        <content type="html"><![CDATA[<p>三大组件：</p><ul><li>MapReduce</li><li>HDFS</li><li>YARN</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/02/hello-world/"/>
      <url>2021/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>anaconda常用指令</title>
      <link href="2021/05/01/anaconda%E5%88%87%E6%8D%A2%E7%8E%AF%E5%A2%83/"/>
      <url>2021/05/01/anaconda%E5%88%87%E6%8D%A2%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>查看所有环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>添加python2.7环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;name&gt; python=2.7</span><br></pre></td></tr></table></figure><p>启动环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate &lt;name&gt;</span><br></pre></td></tr></table></figure><p>关闭环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deactivate &lt;name&gt;</span><br><span class="line">or conda deactivate </span><br></pre></td></tr></table></figure><p>删除环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name &lt;name&gt; --all</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas</title>
      <link href="2021/05/01/arthas/"/>
      <url>2021/05/01/arthas/</url>
      
        <content type="html"><![CDATA[<h2 id="查看JVM-信息"><a href="#查看JVM-信息" class="headerlink" title="查看JVM 信息"></a>查看JVM 信息</h2><ul><li>sysprop：打印所有的System Properties信息</li><li>sysenv：获取到环境变量</li><li>jvm：打印出JVM的各种详细信息</li><li>dashboard：查看当前系统的实时数据面板</li></ul><h2 id="查看已加载的类"><a href="#查看已加载的类" class="headerlink" title="查看已加载的类"></a>查看已加载的类</h2><ul><li>sc：查找到所有JVM已经加载到的类</li><li>sm: 查找类的具体函数</li></ul><h2 id="反编译指令-Jad"><a href="#反编译指令-Jad" class="headerlink" title="反编译指令 Jad"></a>反编译指令 Jad</h2><h2 id="动态执行代码-ognl"><a href="#动态执行代码-ognl" class="headerlink" title="动态执行代码 ognl"></a>动态执行代码 ognl</h2><p>ognl ‘@<a href="mailto:&#106;&#97;&#x76;&#97;&#46;&#x6c;&#97;&#110;&#x67;&#46;&#x53;&#121;&#x73;&#116;&#101;&#109;&#64;&#x6f;&#x75;&#x74;&#46;&#112;&#x72;&#x69;&#110;&#116;&#108;&#110;">&#106;&#97;&#x76;&#97;&#46;&#x6c;&#97;&#110;&#x67;&#46;&#x53;&#121;&#x73;&#116;&#101;&#109;&#64;&#x6f;&#x75;&#x74;&#46;&#112;&#x72;&#x69;&#110;&#116;&#108;&#110;</a>(“hello ognl”)’</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程风格</title>
      <link href="2021/05/01/code%20style%20link/"/>
      <url>2021/05/01/code%20style%20link/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/V8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JavaScript%E4%BB%A3%E7%A0%81.png" alt="JavaScript的执行流程"><br><img src="/images/CDN%E4%BC%A0%E7%BB%9F%E8%BF%87%E7%A8%8B.png" alt="演示Demo"></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://google.github.io/styleguide/javaguide.html">google Java 风格</a></p><p><a href="https://www.oracle.com/java/technologies/javase/codeconventions-contents.html">Java 官方风格</a></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="https://www.python.org/dev/peps/pep-0008/">Python 官方风格</a></p><p><a href="https://google.github.io/styleguide/pyguide.html">google Python 风格</a></p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><a href="https://google.github.io/styleguide/shellguide.html">google Shell 风格</a></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p><a href="https://github.com/Microsoft/api-guidelines">microsoft RESTful</a><br><a href="https://apiguide.readthedocs.io/en/latest/">API design guile</a><br><a href="https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9">RESTful practices</a></p><h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><p><a href="https://github.com/google/styleguide/blob/gh-pages/docguide/style.md">google markdown</a></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://github.com/aseaday/git-style-guide">Git style guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令</title>
      <link href="2021/05/01/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>2021/05/01/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>强制拉取代码覆盖本地</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;master</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>添加账户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;user.name&gt;</span><br><span class="line">git config --global user.email &lt;user.email&gt;</span><br></pre></td></tr></table></figure><p>拉去指定分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch name&gt; &lt;project address&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java碎碎念</title>
      <link href="2021/05/01/java%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>2021/05/01/java%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h2><p>降低接口实现类对接口实现过程的难度，将接口中不需要使用抽象方法交给抽象类进行完成，这样接口实现类只需对接口需要的方法进行重写</p><h2 id="编程时每一个操作都有理论依据"><a href="#编程时每一个操作都有理论依据" class="headerlink" title="编程时每一个操作都有理论依据"></a>编程时每一个操作都有理论依据</h2><h2 id="为什么要问源码？"><a href="#为什么要问源码？" class="headerlink" title="为什么要问源码？"></a>为什么要问源码？</h2><ol><li>方便调试BUG</li><li>看懂源码，方便扩展</li><li>方便做二次开发或者自己项目接口开发</li><li>提升内功，学习别人的设计思想</li></ol><h2 id="spring源码："><a href="#spring源码：" class="headerlink" title="spring源码："></a>spring源码：</h2><ol><li>ioc创建过程</li><li>bean实例化过程</li><li>循环依赖</li><li>AOP</li><li>事件发布监听</li></ol><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程（FP）的意义所在。通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。<br>OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。</p><h2 id="Stream的使用建议"><a href="#Stream的使用建议" class="headerlink" title="Stream的使用建议"></a>Stream的使用建议</h2><ul><li>简单的迭代逻辑，可以直接使用 iterator，对于有多步处理的迭代逻辑，可以使用 stream，损失一点几乎没有的效率，换来代码的高可读性是值得的；</li><li>单核 cpu 环境，不推荐使用 parallel stream，在多核 cpu 且有大数据量的条件下，推荐使用 paralle stream；</li><li>stream 中含有装箱类型，在进行中间操作之前，最好转成对应的数值流，减少由于频繁的拆箱、装箱造成的性能损失</li></ul><p><a href="https://xie.infoq.cn/article/6521ea3ae8a36f2bdaece6e61">https://xie.infoq.cn/article/6521ea3ae8a36f2bdaece6e61</a></p><h2 id="IO流装饰器模式"><a href="#IO流装饰器模式" class="headerlink" title="IO流装饰器模式"></a>IO流装饰器模式</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="2021/05/01/Docker/Docker%20Network/"/>
      <url>2021/05/01/Docker/Docker%20Network/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><h2 id="CNM-Container-Network-Model"><a href="#CNM-Container-Network-Model" class="headerlink" title="CNM(Container Network Model)"></a>CNM(Container Network Model)</h2><p>CNM (Container Network Model) 是 Docker 发布的容器网络标准，意在规范和指定容器网络发展标准，CNM 抽象了容器的网络接口 ，使得只要满足 CNM 接口的网络方案都可以接入到 Docker 容器网络，更好地满足了用户网络模型多样化的需求<br>网络标准的三个元素</p><ol><li>沙箱（Sandbox）：沙箱代表了一系列网络堆栈的配置，其中包含路由信息、网络接口等网络资源的管理</li><li>接入点（Endpoint）：接入点将沙箱连接到网络中，代表容器的网络接口</li><li>网络（Network）：网络是一组可以互相通信的接入点，它将多接入点组成一个子网，并且多个接入点之间可以相互通信</li></ol><p>为了更好地构建容器网络标准，Docker 团队把网络功能从 Docker 中剥离出来，成为独立的项目 libnetwork，它通过插件的形式为 Docker 提供网络功能。使用 Golang 编写，它完全遵循 CNM 网络规范，是 CNM 的官方实现</p><h2 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a>Libnetwork</h2><p>Libnetwork 比较典型的网络模式主要有四种</p><h3 id="1-null-空网络模式"><a href="#1-null-空网络模式" class="headerlink" title="1. null 空网络模式"></a>1. null 空网络模式</h3><p>构建一个没有网络接入的容器环境，以保障数据安全</p><h3 id="2-bridge-桥接模式"><a href="#2-bridge-桥接模式" class="headerlink" title="2. bridge 桥接模式"></a>2. bridge 桥接模式</h3><p>可以打通容器与容器间网络通信的需求。bridge 桥接模式是 Docker 的默认网络模式。桥接模式是基于Linux的veth和bridge技术实现的</p><h4 id="Linux-veth"><a href="#Linux-veth" class="headerlink" title="Linux veth"></a>Linux veth</h4><p>veth 是 Linux 中的虚拟设备接口，veth 都是成对出现的，它在容器中，通常充当一个桥梁。veth 可以用来连接虚拟网络设备，例如 veth 可以用来连通两个 Net Namespace，从而使得两个 Net Namespace 之间可以互相访问</p><h4 id="Linux-bridge"><a href="#Linux-bridge" class="headerlink" title="Linux bridge"></a>Linux bridge</h4><p>Linux bridge 是一个虚拟设备，是用来连接网络的设备，相当于物理网络环境中的交换机。Linux bridge 可以用来转发两个 Net Namespace 内的流量</p><h4 id="veth和bridge的关系"><a href="#veth和bridge的关系" class="headerlink" title="veth和bridge的关系"></a>veth和bridge的关系</h4><p><img src="/images/veth%E5%92%8Cbridge%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="veth和bridge的关系"><br>bridge 就像一台交换机，而 veth 就像一根网线，通过交换机和网线可以把两个不同 Net Namespace 的容器连通，使得它们可以互相通信</p><h3 id="3-host-主机网络模式"><a href="#3-host-主机网络模式" class="headerlink" title="3. host 主机网络模式"></a>3. host 主机网络模式</h3><p>可以让容器内的进程共享主机网络，从而监听或修改主机网络<br>使用 host 主机网络模式时</p><ul><li>libnetwork 不会为容器创建新的网络配置和 Net Namespace</li><li>Docker 容器中的进程直接共享主机的网络配置，可以直接使用主机的网络信息，此时，在容器内监听的端口，也将直接占用到主机的端口</li><li>除了网络共享主机的网络外，其他的包括进程、文件系统、主机名等都是与主机隔离的<h3 id="4-container-网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过-localhost-即可实现访问"><a href="#4-container-网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过-localhost-即可实现访问" class="headerlink" title="4. container 网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问"></a>4. container 网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问</h3>container 网络模式允许一个容器共享另一个容器的网络命名空间<h3 id="网络模式和应用场景"><a href="#网络模式和应用场景" class="headerlink" title="网络模式和应用场景"></a>网络模式和应用场景</h3><img src="/images/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="网络模式及应用场景"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile 书写原则</title>
      <link href="2021/05/01/Docker/Dockerfile%E7%BC%96%E5%86%99%E5%87%86%E5%88%99/"/>
      <url>2021/05/01/Docker/Dockerfile%E7%BC%96%E5%86%99%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Dockerfile-书写原则"><a href="#Dockerfile-书写原则" class="headerlink" title="Dockerfile 书写原则"></a>Dockerfile 书写原则</h1><h2 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="1. 单一职责"></a>1. 单一职责</h2><pre><code>由于容器的本质是进程，一个容器代表一个进程，因此不同功能的应用应该尽量拆分为不同的容器，每个容器只负责单一业务进程。</code></pre><h2 id="2-提供注释信息"><a href="#2-提供注释信息" class="headerlink" title="2. 提供注释信息"></a>2. 提供注释信息</h2><p>   Dockerfile 也是一种代码，我们应该保持良好的代码编写习惯，晦涩难懂的代码尽量添加注释，让协作者可以一目了然地知道每一行代码的作用，并且方便扩展和使用。</p><h2 id="3-保持容器最小化"><a href="#3-保持容器最小化" class="headerlink" title="3. 保持容器最小化"></a>3. 保持容器最小化</h2><p>   应该避免安装无用的软件包</p><h2 id="4-合理选择基础镜像"><a href="#4-合理选择基础镜像" class="headerlink" title="4. 合理选择基础镜像"></a>4. 合理选择基础镜像</h2><p>   容器的核心是应用，因此只要基础镜像能够满足应用的运行环境即可。例如一个Java类型的应用运## 行时只需要JRE，并不需要JDK，因此我们的基础镜像只需要安装JRE环境即可</p><h2 id="5-使用-dockerignore-文件"><a href="#5-使用-dockerignore-文件" class="headerlink" title="5. 使用 .dockerignore 文件"></a>5. 使用 .dockerignore 文件</h2><pre><code>忽略一些不需要参与构建的文件，从而提升构建效率</code></pre><h2 id="6-尽量使用构建缓存"><a href="#6-尽量使用构建缓存" class="headerlink" title="6. 尽量使用构建缓存"></a>6. 尽量使用构建缓存</h2><p>Docker 构建过程中，每一条 Dockerfile 指令都会提交为一个镜像层，下一条指令都是基于上一条指令构建的。如果构建时发现要构建的镜像层的父镜像层已经存在，并且下一条命令使用了相同的指令，即可命中构建缓存<br>命中缓存的原则：</p><ol><li>从当前构建层开始，比较所有的子镜像，检查所有的构建指令是否与当前完全一致，如果不一致，则不使用缓存</li><li>一般情况下，只需要比较构建指令即可判断是否需要使用缓存，但是有些指令除外（例如ADD和COPY）</li><li>对于ADD和COPY指令不仅要校验命令是否一致，还要为即将拷贝到容器的文件计算校验和（根据文件内容计算出的一个数值，如果两个文件计算的数值一致，表示两个文件内容一致 ），命令和校验和完全一致，才认为命中缓存<h2 id="7-正确设置时区"><a href="#7-正确设置时区" class="headerlink" title="7. 正确设置时区"></a>7. 正确设置时区</h2>我们从 Docker Hub 拉取的官方操作系统镜像大多数都是 UTC 时间（世界标准时间）<h2 id="8-使用国内软件源加快镜像构建速度"><a href="#8-使用国内软件源加快镜像构建速度" class="headerlink" title="8. 使用国内软件源加快镜像构建速度"></a>8. 使用国内软件源加快镜像构建速度</h2><h2 id="9-最小化镜像层数"><a href="#9-最小化镜像层数" class="headerlink" title="9. 最小化镜像层数"></a>9. 最小化镜像层数</h2>在构建镜像时尽可能地减少 Dockerfile 指令行数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 组件</title>
      <link href="2021/05/01/Docker/Docker%E7%BB%84%E4%BB%B6/"/>
      <url>2021/05/01/Docker/Docker%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h1><p><em>Docker 在linux下默认的安装目录/var/lib/docker</em></p><h2 id="Docker-相关组件"><a href="#Docker-相关组件" class="headerlink" title="Docker 相关组件"></a>Docker 相关组件</h2><h3 id="docker-客户端"><a href="#docker-客户端" class="headerlink" title="docker 客户端"></a>docker 客户端</h3><p>对用户可见的操作形式为 docker 命令，通过 docker 命令可以完成所有的 Docker 客户端与服务端的通信（还可以通过 REST API、SDK 等多种形式与 Docker 服务端通信）<br>客户端与服务器端交互的过程：<br>    docker 客户端向服务端发送请求后，服务端根据请求执行具体的动作并将结果返回给 docker客户端，docker 解析服务端的返回结果，并将结果通过命令行标准输出展示给用户。这样一次完整的客户端服务端请求就完成了</p><h3 id="dockerd"><a href="#dockerd" class="headerlink" title="dockerd"></a>dockerd</h3><p>dockerd 是 Docker 服务端的后台常驻进程，用来接收客户端发送的请求，执行具体的处理任务，处理完成后将结果返回给客户端<br>Docker 客户端与 dockerd 的交互方式有三种，客户端和服务器端的通信必须保持一致</p><ol><li>通过 UNIX 套接字与服务端通信<br>配置格式为unix://socket_path，默认 dockerd 生成的 socket 文件路径为 /var/run/docker.sock。该文件只有root用户和docker用户组的用户才能访问</li><li>通过 TCP 与服务端通信<br>配置格式为tcp://host:port，存在安全隐患，可以使用TLS认证来保证传输安全</li><li>通过文件描述符的方式与服务端通信<br> 配置格式为：fd://这种格式一般用于 systemd 管理的系统中<h3 id="docker-init"><a href="#docker-init" class="headerlink" title="docker-init"></a>docker-init</h3>在容器内部，当我们自己的业务进程没有回收子进程的能力时，在执行 docker run 启动容器时可以添加 –init 参数，此时 Docker 会使用 docker-init 作为1号进程，帮你管理容器内子进程，例如回收僵尸进程等<h3 id="docker-proxy"><a href="#docker-proxy" class="headerlink" title="docker-proxy"></a>docker-proxy</h3>docker-proxy 主要是用来做端口映射的，底层依赖于iptables实现<h2 id="containerd相关组件"><a href="#containerd相关组件" class="headerlink" title="containerd相关组件"></a>containerd相关组件</h2><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4></li><li>负责容器生命周期的管理</li><li>镜像的管理，例如容器运行前从镜像仓库拉取镜像到本地</li><li>接收 dockerd 的请求，通过适当的参数调用 runc 启动容器</li><li>管理存储相关资源</li><li>管理网络相关资源<h4 id="containerd和dockerd的交互"><a href="#containerd和dockerd的交互" class="headerlink" title="containerd和dockerd的交互"></a>containerd和dockerd的交互</h4>containerd 包含一个后台常驻进程，默认的 socket 路径为 /run/containerd/containerd.sock，dockerd 通过 UNIX 套接字向 containerd 发送请求，containerd 接收到请求后负责执行相关的动作并把执行结果返回给 dockerd。<h3 id="containerd-shim"><a href="#containerd-shim" class="headerlink" title="containerd-shim"></a>containerd-shim</h3>containerd-shim 的主要作用是将 containerd 和真正的容器进程解耦，使用 containerd-shim 作为容器进程的父进程，从而实现重启 containerd 不影响已经启动的容器进程<h3 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h3>containerd的客户端，可以直接向containerd发送容器请求<h2 id="runc（容器运行时组件）"><a href="#runc（容器运行时组件）" class="headerlink" title="runc（容器运行时组件）"></a>runc（容器运行时组件）</h2>runc 是一个标准的 OCI 容器运行时的实现，它是一个命令行工具，可以直接用来创建和运行容器</li></ol><p><img src="/images/Docker%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8.png" alt="Docker组件"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker隔离</title>
      <link href="2021/05/01/Docker/Docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/"/>
      <url>2021/05/01/Docker/Docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker隔离"><a href="#Docker隔离" class="headerlink" title="Docker隔离"></a>Docker隔离</h1><h2 id="Docker-资源隔离-借助于Linux-的Namespace"><a href="#Docker-资源隔离-借助于Linux-的Namespace" class="headerlink" title="Docker 资源隔离 借助于Linux 的Namespace"></a>Docker 资源隔离 借助于Linux 的Namespace</h2><h3 id="Namespace是什么"><a href="#Namespace是什么" class="headerlink" title="Namespace是什么"></a>Namespace是什么</h3><p>Namespace 是 Linux 内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。<br>它实现了在同一个主机中，对进程 ID、主机名、用户 ID、文件名、网络和进程间通信等资源的隔离</p><h3 id="Namespace的功能"><a href="#Namespace的功能" class="headerlink" title="Namespace的功能"></a>Namespace的功能</h3><p>Linux提供了8种类型的Namespace<br>|Namespace 名称    |作用|<br>|—-|—-|<br>|Mount（mnt）    |隔离挂载点    |<br>|Process ID (pid)    |隔离进程 ID    |<br>|Network (net)    |隔离网络设备，端口号等    |<br>|Interprocess Communication (ipc)    |隔离 System V IPC 和 POSIX message queues    |<br>|UTS Namespace(uts)|    隔离主机名和域名    |<br>|User Namespace (user)|    隔离用户和用户组    |<br>|Control group (cgroup) Namespace|    隔离 Cgroups 根目录    |<br>|Time Namespace    |隔离系统时间|    </p><p>Docker 使用了前6种Namespace</p><h3 id="为什么docker需要Namespace"><a href="#为什么docker需要Namespace" class="headerlink" title="为什么docker需要Namespace"></a>为什么docker需要Namespace</h3><p>当 Docker 新建一个容器时， 它会创建这六种 Namespace，然后将容器中的进程加入这些 Namespace 之中，使得 Docker 容器中的进程只能看到当前 Namespace 中的系统资源。</p><p>正是由于 Docker 使用了 Linux 的这些 Namespace 技术，才实现了 Docker 容器的隔离，可以说没有 Namespace，就没有 Docker 容器</p><h2 id="Docker-资源限制-借助于Linux-的Cgroups"><a href="#Docker-资源限制-借助于Linux-的Cgroups" class="headerlink" title="Docker 资源限制 借助于Linux 的Cgroups"></a>Docker 资源限制 借助于Linux 的Cgroups</h2><h3 id="Cgroups是什么"><a href="#Cgroups是什么" class="headerlink" title="Cgroups是什么"></a>Cgroups是什么</h3><p>cgroups（全称：control groups）是 Linux 内核的一个功能，它可以实现限制进程或者进程组的资源（如 CPU、内存、磁盘 IO 等）</p><h3 id="Cgroups功能"><a href="#Cgroups功能" class="headerlink" title="Cgroups功能"></a>Cgroups功能</h3><ol><li>资源限制： 限制资源的使用量，例如我们可以通过限制某个业务的内存上限，从而保护主机其他业务的安全运行</li><li>优先级控制：不同的组可以有不同的资源（ CPU 、磁盘 IO 等）使用优先级</li><li>审计：计算控制组的资源使用情况</li><li>控制：控制进程的挂起或恢复</li></ol><h3 id="Cgroups三个核心概念"><a href="#Cgroups三个核心概念" class="headerlink" title="Cgroups三个核心概念"></a>Cgroups三个核心概念</h3><ul><li>子系统（subsystem）：是一个内核的组件，一个子系统代表一类资源调度控制器。例如内存子系统可以限制内存的使用量，CPU 子系统可以限制 CPU 的使用时间。</li><li>控制组（cgroup）：表示一组进程和一组带有参数的子系统的关联关系。例如，一个进程使用了 CPU 子系统来限制 CPU 的使用时间，则这个进程和 CPU 子系统的关联关系称为控制组。</li><li>层级树（hierarchy）：是由一系列的控制组按照树状结构排列组成的。这种排列方式可以使得控制组拥有父子关系，子控制组默认拥有父控制组的属性，也就是子控制组会继承于父控制组</li></ul><h3 id="Docker-是如何使用Cgroups的"><a href="#Docker-是如何使用Cgroups的" class="headerlink" title="Docker 是如何使用Cgroups的"></a>Docker 是如何使用Cgroups的</h3><p>Docker 创建容器时，Docker 会根据启动容器的参数，在对应的 cgroups 子系统下创建以容器 ID 为名称的目录, 然后根据容器启动时设置的资源限制参数, 修改对应的 cgroups 子系统资源限制文件, 从而达到资源限制的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 镜像</title>
      <link href="2021/05/01/Docker/Docker%E9%95%9C%E5%83%8F/"/>
      <url>2021/05/01/Docker/Docker%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p>Docker 镜像是由文件系统叠加而成</p><ol><li>最低端是一个引导文件系统，即bootfs</li><li>第二层是root文件系统rootfs，位于引导文件系统之上，rootfs可以使一种或多种操作系统<br>使用联合加载技术会在root文件系统层上加载更多制度文件系统。<br>联合加载是指一次同时加载多个文件系统。</li></ol><p>写时复制机制</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker cookbook</title>
      <link href="2021/05/01/Docker/docker%20cookbook/"/>
      <url>2021/05/01/Docker/docker%20cookbook/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-cookbook"><a href="#Docker-cookbook" class="headerlink" title="Docker cookbook"></a>Docker cookbook</h1><h2 id="无权限连接Docker-Daemon-socket"><a href="#无权限连接Docker-Daemon-socket" class="headerlink" title="无权限连接Docker Daemon socket"></a>无权限连接Docker Daemon socket</h2><p>问题描述：Got permission denied while trying to connect to the Docker daemon socket<br>问题原因：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问<br>解决措施：</p><ol><li>使用sudo获取管理员权限</li><li>docker守护进程启动时，会默认赋予docker的用户组读写Unix Socket的权限，因此只需将当前用户添加到用户组就有权限访问Unix Socket了<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改国内镜像源"><a href="#修改国内镜像源" class="headerlink" title="修改国内镜像源"></a>修改国内镜像源</h2><p>问题描述：Error response from daemon: Head “<a href="https://registry-1.docker.io/v2/library/ngnix/manifests/latest&quot;">https://registry-1.docker.io/v2/library/ngnix/manifests/latest&quot;</a>: Get “<a href="https://auth.docker.io/token?scope=repository:library/ngnix:pull&amp;service=registry.docker.io&quot;">https://auth.docker.io/token?scope=repository%3Alibrary%2Fngnix%3Apull&amp;service=registry.docker.io&quot;</a>: net/http: TLS handshake timeout.<br>问题原因：国内无法访问镜像源<br>解决措施：更改为国内镜像源</p><ol><li>sudo vim /etc/docker/daemon.json</li><li>修改配置文件<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">&quot;registry-mirrors&quot;</span>: <span class="string">[&quot;https://docker.mirrors.ustc.edu.cn/&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot;],</span></span><br><span class="line"><span class="meta">&quot;insecure-registries&quot;</span>: <span class="string">[&quot;10.0.0.12:5000&quot;]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li>重新加载守护进程：sudo systemctl daemon-reload</li><li>重启docker：sudo service docker restart</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 问题集</title>
      <link href="2021/05/01/Docker/Docker%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/01/Docker/Docker%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Dockerfile-和-docker-compose-yml-的区别"><a href="#Dockerfile-和-docker-compose-yml-的区别" class="headerlink" title="Dockerfile 和 docker-compose.yml 的区别"></a>Dockerfile 和 docker-compose.yml 的区别</h3><p>Dockerfile: Dockerfile 是拿来构建自定义镜像的，并没有直接生成容器<br>docker-compose.yml是用来编排项目的，里面包含使用各种镜像创建的容器服务,在服务启动的时候用到</p><h3 id="为什么容器是单进程模型"><a href="#为什么容器是单进程模型" class="headerlink" title="为什么容器是单进程模型"></a>为什么容器是单进程模型</h3><p>容器只是通过Linux的Namespaces、Cgroups实现了进程级别的隔离。虽然在容器里看不见宿主机上的其他进程，但归根结底它还只是一个运行在宿主机上的进程，所以就不具备操作系统的进程管理能力。</p><p>容器的”单进程模型”，并不是指容器里只能运行”一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里的主进程（PID=1 的进程）就是应用本身，其他的进程都是这个主进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的init进程或者systemd 那样拥有进程管理的功能。<br>reference：<a href="https://cloud.tencent.com/developer/article/1671554">https://cloud.tencent.com/developer/article/1671554</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="2021/05/01/Docker/docker%E7%AE%80%E4%BB%8B/"/>
      <url>2021/05/01/Docker/docker%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h3><ul><li>提供一个简单、轻量的建模方式<br>所需要的环境知识一台仅仅安装兼容版本的linux内核和二进制文件最小限的宿主机</li><li>职责的逻辑分离<br>开发人员只需要关注容器运行的应用程序，运维只需要关注如何管理容器</li><li>快速、高效的生命开发周期<br>缩短代码从开发、测试到部署、上线运行的周期，让程序具有可以移植性，易于构建和协作</li><li>鼓励使用面向服务的架构<br>Docker推荐单个容器只运行一个应用程序或进程，形成分布式的应用程序模型。</li></ul><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p><img src="/images/Docker%E6%9E%B6%E6%9E%84.png" alt="Docker架构"></p><h4 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h4><p>核心组件：</p><ul><li>Docker客户端和服务器</li><li>Docker镜像</li><li>Registry</li><li>Docker容器</li></ul><h4 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h4><p>Docker是一个C/S架构的程序。Docker客户端向Docker服务器或者守护进程发送请求，服务器或守护进程将完成所有工作并返回结果。</p><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><ol><li>镜像是Docker生命周期中的构建部分。是基于联合(Union)文件系统的一种层式结构。他是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。</li><li>Docker镜像的实现原理：Docker 镜像是静态的分层管理的文件组合，镜像底层的实现依赖于联合文件系统（UnionFS）。每一层的只存放了上一层的增量数据</li><li>如何使用镜像：<ol><li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，你可以在基础镜像上添加一些用户自定义的内容</li><li>从功能镜像仓库拉取别人制作好的镜像，如Docker Hub</li></ol></li><li>Docker镜像的操作<br><img src="/images/Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C.png" alt="Docker镜像的操作"></li></ol><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是Docker生命周期中的启动部分。容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。</p><p>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态</p><p>使用Docker,能够快读构建一个应用程序服务器、一个消息总线、一套实用工具、一个持续集成测试环境或者任意一种应用程序、服务或工具。</p><p>容器的生命周期<br><img src="/images/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="容器的生命周期"></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>Registry类似于代码仓库，用来存储和分发 Docker 镜像。<br>Registry 用于保存用户构建的镜像。分为公共和私有两种。公共Registry叫做Docker Hub。</p><h4 id="容器、仓库、镜像之间的关系"><a href="#容器、仓库、镜像之间的关系" class="headerlink" title="容器、仓库、镜像之间的关系"></a>容器、仓库、镜像之间的关系</h4><p><img src="/images/%E5%AE%B9%E5%99%A8%E3%80%81%E4%BB%93%E5%BA%93%E3%80%81%E9%95%9C%E5%83%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="容器、仓库、镜像之间的关系"></p><h4 id="Docker架构-1"><a href="#Docker架构-1" class="headerlink" title="Docker架构"></a>Docker架构</h4><h3 id="Docker-应用场景"><a href="#Docker-应用场景" class="headerlink" title="Docker 应用场景"></a>Docker 应用场景</h3><ul><li>加快本地开发和构建流程</li><li>能够让独立服务或应用程序在不同的环境中，得到相同的运行结果</li><li>创建隔离的环境来进行测试</li><li>构建一个多用户的平台即服务基础(PaaS)设施</li><li>为开发、测试提供一个轻量级的独立沙河环境</li><li>提供软件即服务(SaaS)应用程序</li><li>高性能、超大规模的宿主机部署</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 简介</title>
      <link href="2021/05/01/Nginx/Nginx/"/>
      <url>2021/05/01/Nginx/Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="为什么使用Nginx"><a href="#为什么使用Nginx" class="headerlink" title="为什么使用Nginx"></a>为什么使用Nginx</h2><p>核心是支持高并发请求的同时保持高效的服务</p><ul><li>快：Nginx可以比其他Web服务器更快地响应请求</li><li>高扩展：它完全是由多个不同功能、 不同层次、 不同类型且耦合度极<br>低的模块组成</li><li>高可靠：Nginx的高可靠性来自于其核心框架代码<br>的优秀设计、 模块设计的简单性</li><li>低内存：10000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存</li><li>单机支持10w以上的并发连接</li><li>热部署：master管理进程与worker工作进程的分离设计， 使得Nginx能够提供热部署功能。支持不停止服务就更新配置项、 更换日志文件等功能。</li></ul><h2 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h2><ul><li>Nginx可以行的二进制文件</li><li>Nginx.conf 配置文件：控制Nginx的行为</li><li>access.log 访问日志：记录每一条http请求信息</li><li>error.log 错误日志：定位问题</li></ul><h2 id="Nginx进程间的关系"><a href="#Nginx进程间的关系" class="headerlink" title="Nginx进程间的关系"></a>Nginx进程间的关系</h2><p>Nginx时使用一个master进程来管理多个worker进程。 一般情况下， worker进程的数量与服务器上的CPU核心数相等。 每一个worker进程都是繁忙的， 它们在真正地提供互联网服务。master进程则很“清闲”， 只负责监控管理worker<br>进程。<strong>worker进程之间通过共享内存、 原子操作等一些进程间通信机制</strong>来实现负载均衡等功能</p><p><img src="/images/nginx%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="nginx进程间的关系"></p><h2 id="Nginx进程间的通讯方式"><a href="#Nginx进程间的通讯方式" class="headerlink" title="Nginx进程间的通讯方式"></a>Nginx进程间的通讯方式</h2><ol><li>信号</li><li>共享内存<ol><li>rbtree(红黑树)会用到(限速等)<ol><li>ngx_stream_limit_conn_module</li><li>ngx_http_limit_conn_module</li><li>ngx_stream_limit_req_module</li><li>http cache</li><li>ssl</li></ol></li><li>单链表会用到<ol><li>Ngx_http_upstream_zone_module</li><li>ngx_stream_upstram_zone_module</li></ol></li></ol></li></ol><p>引入的问题：</p><ol><li>锁</li><li>Slab内存管理器<h3 id="为什么需要按照masterworker方式配置同时启动多个进程呢"><a href="#为什么需要按照masterworker方式配置同时启动多个进程呢" class="headerlink" title="为什么需要按照masterworker方式配置同时启动多个进程呢"></a>为什么需要按照masterworker方式配置同时启动多个进程呢</h3></li><li>master进程可以是唯一的， 它仅专注于自己的纯管理工作， 为管理员提供命令行服务，包括诸如启动服务、 停止服务、 重载配置文件、 平滑升级程序等。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性。可以<strong>充分利用现在常见的SMP多核架构， 从而实现微观上真正的多核并发处理</strong>。当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心） ， 进程间切换的代价是最小的</li></ol><h4 id="为什么建议Nginx上的进程数与CPU核心数相等时"><a href="#为什么建议Nginx上的进程数与CPU核心数相等时" class="headerlink" title="为什么建议Nginx上的进程数与CPU核心数相等时"></a>为什么建议Nginx上的进程数与CPU核心数相等时</h4><p>若worker进程的数量多于CPU内核数， 那么会增大进程间切换带来的消耗（Linux是抢占式内核）。同时worker进程绑定指定的CPU内核</p><h4 id="为什么需要绑定到指定的内核"><a href="#为什么需要绑定到指定的内核" class="headerlink" title="为什么需要绑定到指定的内核"></a>为什么需要绑定到指定的内核</h4><p>假定每一个worker进程都是非常繁忙的， 如果多个worker进程都在抢同一个CPU， 那么这就会出现同步问题。 反之， 如果每一个worker进程都独享一个CPU， 就在内核的调度策略上实现了完全的并发。</p><h2 id="Nginx-Hash表使用的注意"><a href="#Nginx-Hash表使用的注意" class="headerlink" title="Nginx Hash表使用的注意"></a>Nginx Hash表使用的注意</h2><ol><li>只为静态的，不变的内容服务</li><li>hash表的bucket_size 需要考虑cpu cache line 的对齐问题</li></ol><h2 id="日志分析（goaccess）"><a href="#日志分析（goaccess）" class="headerlink" title="日志分析（goaccess）"></a>日志分析（goaccess）</h2><h2 id="Nginx文件缓存"><a href="#Nginx文件缓存" class="headerlink" title="Nginx文件缓存"></a>Nginx文件缓存</h2><p>文件缓存会在内存中存储以下3种信息：</p><ul><li>文件句柄，文件大小和修改次数</li><li>已经打开过的目录结构</li><li>没有找到或者没有权限操作的文件信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 操作</title>
      <link href="2021/05/01/Nginx/Nginx%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/01/Nginx/Nginx%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -S reload 或</span><br><span class="line">kill -HUP 主进程号</span><br></pre></td></tr></table></figure><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><ol><li><p>备份旧的可执行文件</p></li><li><p>给主进程发USER2信号：执行完后新的主进程和旧的同时存在，会将新的请求/连接给到新的主进程中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 9944</span><br></pre></td></tr></table></figure></li><li><p>给旧的主进程发送WINCH信号：通知旧的主进程优雅的关闭旧的work进程(执行完任务后关闭)，旧的主进程还在，以便做版本回退。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 9944</span><br></pre></td></tr></table></figure></li><li><p>给旧的主进程发送QUIT信号，使其关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT 9944</span><br></pre></td></tr></table></figure></li><li><p>如果需要进行版本回退，可以给旧的主进程发HUP命令，nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。然后再优雅的关闭新的主进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP 9944</span><br><span class="line">kill -QUIT 新的主进程pid</span><br></pre></td></tr></table></figure></li></ol><h2 id="重启日志文件（日志文件分割）"><a href="#重启日志文件（日志文件分割）" class="headerlink" title="重启日志文件（日志文件分割）"></a>重启日志文件（日志文件分割）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reopen </span><br><span class="line">或者 kill -USR1 2030</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx反向代理</title>
      <link href="2021/05/01/Nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>2021/05/01/Nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><h2 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h2><p><img src="/images/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="Nginx反向代理流程"></p><h2 id="Proxy-pass模块规则"><a href="#Proxy-pass模块规则" class="headerlink" title="Proxy_pass模块规则"></a>Proxy_pass模块规则</h2><ul><li>URL必须以http://或者https://开头，接下来时域名，IP，unix socket地址或者upstream的名字。可以在域名或者IP之后加端口，最后可选的时URI</li><li>Nginx会根据当前URL参数当中携带URI与否，会导致发至上游请求的URL不同，<ul><li>不携带URI时，则直接将客户端请求中的URL直接发送到上游服务器。location参数后使用正则表达式、@名字时，应采用这种方式</li><li>携带URI时，会将location参数匹配上的一段替换为该URI</li></ul></li><li>更复杂的URL替换，可以在location内配置添加rewrite break语句</li></ul><h2 id="发送给上游的http请求头部包体处理"><a href="#发送给上游的http请求头部包体处理" class="headerlink" title="发送给上游的http请求头部包体处理"></a>发送给上游的http请求头部包体处理</h2><ul><li>请求行<ul><li>proxy method</li><li>proxy_http_version 1.0|1.1</li></ul></li><li>请求头部<ul><li>proxy_set_header</li><li>proxy_pass_request_headers on|off:是否把请求头部发给上游，默认时开启的</li></ul></li><li>请求体<ul><li>proxy_set_body</li><li>proxy_pass_request_body on|off:是否把请求体发给上游，默认时开启的</li></ul></li></ul><h2 id="接受客户端请求的包体"><a href="#接受客户端请求的包体" class="headerlink" title="接受客户端请求的包体"></a>接受客户端请求的包体</h2><h3 id="proxy-request-buffering-on-off"><a href="#proxy-request-buffering-on-off" class="headerlink" title="proxy_request_buffering on|off"></a>proxy_request_buffering on|off</h3><p>决定包体收完再转发还是边收边转发，默认时on</p><ul><li><p>on使用情景</p><ul><li>客户端网速较慢</li><li>上游服务并发处理能力地</li><li>适应高吞吐量场景</li></ul></li><li><p>off使用情景</p><ul><li>更及时的响应</li><li>降低Nginx读写磁盘的消耗</li><li>一旦发送内容，proxy_next_upstream功能失败</li></ul></li></ul><h3 id="客户端包体的接收"><a href="#客户端包体的接收" class="headerlink" title="客户端包体的接收"></a>客户端包体的接收</h3><h4 id="客户端包体的内存分配"><a href="#客户端包体的内存分配" class="headerlink" title="客户端包体的内存分配"></a>客户端包体的内存分配</h4><ul><li>若接收头部时已经接收完全部的包体，则不分配</li><li>若剩余待接收包体的长度小于client_body_buffer_size，则仅分配所需大小</li><li>分配client_body_buffer_size大小内存接收包体<ul><li>关闭包体缓存时，该内存上的内容及时发送给上游</li><li>打开包体缓存，该端内存用完时，写入临时文件，释放内存<h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3></li></ul></li><li>client_body_buffer_size：缓存body长度</li><li>client_max_body_size: 最大包体长度限制</li><li>client_body_temp_path：包体临时文件路径</li><li>client_body_in_file_only：包体必须保存在文件中</li><li>client_body_timeout：读取包体时超时</li></ul><h3 id="和上游服务器建立连接"><a href="#和上游服务器建立连接" class="headerlink" title="和上游服务器建立连接"></a>和上游服务器建立连接</h3><ul><li>TCP keepalive</li><li>HTTP keepalive</li></ul><h3 id="处理上游的响应头部"><a href="#处理上游的响应头部" class="headerlink" title="处理上游的响应头部"></a>处理上游的响应头部</h3><h4 id="proxy-ignore-headers"><a href="#proxy-ignore-headers" class="headerlink" title="proxy_ignore_headers"></a>proxy_ignore_headers</h4><p>作用：禁用某些响应头部改变Nginx的行为<br>可禁用功能的头部：</p><ul><li>X-Accel-Redirect: 由上游服务指定nginx内部重定向，控制请求的执行</li><li>X-Accel-Limit-Rate：由上游设置发往客户端的速度限制</li><li>X-Accel-Buffering：由上游控制是否缓存上游的响应</li><li>X-Accel-Charset：由上游控制Content-Type的Charset</li><li>缓存相关：<ul><li>X-Accel-Expires：设置响应在Nginx中缓存时间</li><li>Expires：控制Nginx缓存时间</li><li>Cache-Control：控制Nginx缓存时间</li><li>Set-cookie：响应中出现Set-Cookie则不缓存</li><li>Vary：响应中出现Vary：*则不缓存</li></ul></li></ul><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><h3 id="Nginx如何解决缓存失效时上游服务器的压力"><a href="#Nginx如何解决缓存失效时上游服务器的压力" class="headerlink" title="Nginx如何解决缓存失效时上游服务器的压力"></a>Nginx如何解决缓存失效时上游服务器的压力</h3><h4 id="合并回源请求，减轻峰值流量下的压力"><a href="#合并回源请求，减轻峰值流量下的压力" class="headerlink" title="合并回源请求，减轻峰值流量下的压力"></a>合并回源请求，减轻峰值流量下的压力</h4><p>使用proxy_cache_lock on|off，同一个时间，仅第一个请求发向上游，其他请求等待第一个响应返回或者超时后，使用缓存响应客户端。<br>可以通过proxy_cache_lock_timeout设置第一个返回响应的最大时间，到达时间后，直接向上游发送请求，<br>Proxy_cache_lock_age 上游请求返回响应的时间，到达该时间后再放行一个请求发送上游。</p><p><img src="//images/Nginx%E5%90%88%E5%B9%B6%E5%9B%9E%E6%BA%90%E8%AF%B7%E6%B1%82.png" alt="Nginx合并回源请求"></p><h4 id="减少回源请求，使用stale陈旧的缓存"><a href="#减少回源请求，使用stale陈旧的缓存" class="headerlink" title="减少回源请求，使用stale陈旧的缓存"></a>减少回源请求，使用stale陈旧的缓存</h4><p><img src="//images/Nginx%E5%90%88%E5%B9%B6%E5%9B%9E%E6%BA%90%E8%AF%B7%E6%B1%82.png" alt="Nginx合并回源请求"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 负载均衡</title>
      <link href="2021/05/01/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2021/05/01/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h1><h2 id="Nginx-负载均衡特点"><a href="#Nginx-负载均衡特点" class="headerlink" title="Nginx 负载均衡特点"></a>Nginx 负载均衡特点</h2><p>Nginx并不会立刻转发到上游服务器，而是先把用户的请求（包括HTTP包体） 完整地接收到Nginx所在服务器的硬盘或者内存中，然后再向上游服务器发起连接， 把缓存的客户端请求转发到上游服务器。（接收到完整的客户端请求（如1GB的文件） 后， 才会与上游服务器建立连接转发请求）。</p><p>缺点：延长了一个请求的处理时间，并增加了用于缓存请求内容的内存和磁盘空间<br>优点：降低了上游服务器的负载， 尽量把压力放在Nginx服务器上<br><img src="/images/%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84Nginx.png" alt="作为静态Web服务器与反向代理服务器的Nginx"></p><p><img src="/images/Nginx%E4%BD%9C%E4%B8%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="Nginx作为反向代理服务器时转发请求的流程"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>upstream块：upstream块定义了一个上游服务器的集群， 便于反向代理中的proxy_pass使用</li><li>ip_hash：我们可能会希望来自某一个用户的请求始终落到固定的一台上游服务器中。如果同一个用户的请求任意地转发到集群中的任一台上游服务器中， 那么每一台上游服务器都有可能会缓存同一份信息， 这既会造成资源。的浪费， 也会难以有效地管理缓存信息，这样确保了<strong>同一个客户端的请求只会转发到指定的上游服务器中</strong>。</li><li>proxy_pass:此配置项将当前请求反向代理到URL参数指定的服务器上， URL可以是主机名或IP地址加端口的形式。</li><li>proxy_method:配置项表示转发时的协议方法名</li><li>proxy_hide_header:Nginx会将上游服务器的响应转发给客户端， 可以任意地指定哪些HTTP头部字段不能被转发。</li><li>proxy_pass_header:与proxy_hide_header 相反</li><li>proxy_pass_request_headers：作用为确定是否转发HTTP头部。</li><li>proxy_redirect：当上游服务器返回的响应是重定向或刷新请求（ 如HTTP响应码是301或者302） 时，proxy_redirect可以重设HTTP头部的location或refresh字段</li><li>proxy_next_upstream：此配置项表示当向一台上游服务器转发请求出现错误时， 继续换一台上游服务器处理这个请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 配置</title>
      <link href="2021/05/01/Nginx/Nginx%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
      <url>2021/05/01/Nginx/Nginx%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h1><h2 id="配置语法："><a href="#配置语法：" class="headerlink" title="配置语法："></a>配置语法：</h2><ol><li>配置文件由指令和指令块构成</li><li>每条指令以; 解为，指令与参数之前用空格分割</li><li>指令块以{}大括号将多条指令组织在一起</li><li>include语句允许组合多个配置文件以提升可维护性</li><li>使用#符号添加注释，提高可读性</li><li>使用$符号使用变量</li><li>部分指令的参数支持正则表达式</li></ol><h2 id="优化性能的配置项"><a href="#优化性能的配置项" class="headerlink" title="优化性能的配置项"></a>优化性能的配置项</h2><ol><li>worker进程个数：worker_processes number</li><li>worker进程绑定指定CPU：worker_cpu_affinity cpumask[cpumask…(0001)]</li><li>SSL硬件加速：ssl_engine device</li><li>系统调用gettimeofday的执行频率[^1]:timer_resolution t</li><li>worker进程优先级：worker_priority nice</li></ol><h2 id="事件类配置项"><a href="#事件类配置项" class="headerlink" title="事件类配置项"></a>事件类配置项</h2><ol><li>是否打开accept锁：accept_mutex[on|off][^2]</li><li>accept锁后到真正建立连接之间的延迟时间：accept_mutex_delay 500ms</li><li>批量建立新连接：multi_accept[on|off]</li><li>选择事件模型：use[kqueue|rtsig|epoll|/dev/poll|select|poll|eventport] [^3]</li><li>每个worker的最大连接数:worker_connections number</li></ol><h2 id="请求转发配置"><a href="#请求转发配置" class="headerlink" title="请求转发配置"></a>请求转发配置</h2><h3 id="配置块-server"><a href="#配置块-server" class="headerlink" title="配置块 server"></a>配置块 server</h3><ol><li>监听端口</li><li>主机名称：server_name name[…]</li><li>service name散列桶的大小[^4]：server_names_hash_bucket_size</li><li>service name散列的大小：server_names_hash_max_size</li><li>重定向主机名称的处理：server_name_in_redirect on|off</li><li>Location:</li></ol><h2 id="内存及磁盘资源的分配配置"><a href="#内存及磁盘资源的分配配置" class="headerlink" title="内存及磁盘资源的分配配置"></a>内存及磁盘资源的分配配置</h2><ol><li>HTTP包体只存储到磁盘文件中：client_body_in_file_only on|clean|off;</li><li>HTTP包体尽量写入到一个内存buffer中[^5]：client_body_in_single_buffer on|off;</li><li>存储HTTP头部的内存buffer大小：client_header_buffer_size size</li><li>存储超大HTTP头部的内存buffer大小[^6]：large_client_header_buffers number size</li><li>存储HTTP包体的内存buffer大小[^7]：client_body_buffer_size 8k/16k</li><li> HTTP包体的临时存放目录</li><li> connection_pool_size</li><li> request_pool_size</li></ol><h2 id="网络连接设置"><a href="#网络连接设置" class="headerlink" title="网络连接设置"></a>网络连接设置</h2><ol><li>读取HTTP头部的超时时间：client_header_timeout time</li><li>读取HTTP包体的超时时间：client_body_timeout time</li><li>发送响应的超时时间：send_timeout time</li><li>reset_timeout_connection[^8]：reset_timeout_connection on|off</li><li>lingering_close[^9]：lingering_close off|on|always</li><li>lingering_timeout</li><li>lingering_time</li><li>对某些浏览器禁用keepalive功能:keepalive_disable[msie6|safari|none]</li><li>keepalive超时时间:keepalive_timeout time</li><li>一个keepalive长连接上允许承载的请求最大数:keepalive_requests n</li><li>确定对keepalive连接是否使用TCP_NODELAY选项:tcp_nodelay on|off</li><li>按HTTP方法名限制用户请求:limit_except method…{…}</li><li>HTTP请求包体的最大值:client_max_body_size size</li><li> 对请求的限速:limit_rate speed</li><li> limit_rate_after:Nginx向客户端发送的响应长度超过limit_rate_after后才开始限速</li></ol><h2 id="文件操作设置"><a href="#文件操作设置" class="headerlink" title="文件操作设置"></a>文件操作设置</h2><ol><li>sendfile系统调用[^10]：sendfile on|off;</li><li>AIO系统调用[^11]:aio on|off;</li><li>directio[^12]：directio size|off;</li><li>directio对齐：directio_alignment size</li><li>打开文件缓存：open_file_cache max=N[inactive=time]|off;</li><li>是否缓存打开文件错误的信息：open_file_cache_errors on|off;</li><li>不被淘汰的最小访问次数：open_file_cache_min_uses number;</li><li>检验缓存中元素有效性的频率：open_file_cache_valid time;</li></ol><h2 id="客户端请求的特殊处理"><a href="#客户端请求的特殊处理" class="headerlink" title="客户端请求的特殊处理"></a>客户端请求的特殊处理</h2><ol><li>忽略不合法的HTTP头部：ignore_invalid_headers on|off</li><li>HTTP头部是否允许下划线：underscores_in_headers on|off;</li><li>对If-Modified-Since头部的处理策略[^13]：if_modified_since[off|exact|before]</li><li>文件未找到时是否记录到error日志:log_not_found on|off;</li><li>是否合并相邻的“/”：merge_slashes on|off;</li><li>设置DNS名字解析服务器的地址：resolver address…;</li><li>DNS解析的超时时间：resolver_timeout time;</li><li>是否在响应的Server头部中标明Nginx版本：server_tokens on|off;</li></ol><p>[^1]:gettimeofday:每次内核的事件调用（如epoll、 select、 poll、 kqueue等） 返回时， 都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟<br>[^2]:accept_mutex是Nginx的负载均衡锁,ccept_mutex这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。<br>[^3]:Nginx会自动使用最适合的事件模型<br>[^4]:server name是存储在散列表里的<br>[^5]:如果HTTP包体超过了client_header_buffer_size的大小，包体还是会写入到磁盘文件<br>[^6]:如果HTTP请求行的大小超过配置值，则返回”Request URI too large”(414)<br>[^7]:HTTP包体会先接收到指定的这块缓存中， 之后才决定是否写入磁盘<br>[^8]:连接超时后将通过向客户端发送RST包来直接重置连接。 这个选项打开后， Nginx会在某个连接超时后， 不是使用正常情形下的四次握手关闭TCP连接， 而是直接向用户发送RST重置包， 不再等待用户的应答， 直接释放Nginx服务器上关于这个套接字使用的所有缓存.一般关闭<br>[^9]:该配置控制Nginx关闭用户连接的方式。 always表示关闭用户连接前必须无条件地处理连接上所有用户发送的数据。 off表示关闭连接时完全不管连接上是否已经有准备就绪的来自用户的数据。 on是中间值， 一般情况下在关闭连接前都会处理连接上的用户发送的数据<br>[^10]:启用Linux上的sendfile系统调用来发送文件， 它减少了内核态与用户态之间的两次内存复制， 这样就会从磁盘中读取文件后直接在内核态发送到网卡设备<br>[^11]:表示是否在FreeBSD或Linux系统上启用内核级别的异步文件I/O功能,与sendfile功能是互斥的<br>[^12]:在FreeBSD和Linux系统上使用O_DIRECT选项去读取文件， 缓冲区大小为size，通常对大文件的读取速度有优化作用。与sendfile功能是互斥的。<br>[^13]:Web浏览器一般会在客户端本地缓存一些文件，并存储当时获取的时<br>间。 这样，下次向Web服务器获取缓存过的资源时， 就可以用If-Modified-Since头部把上次获取的时间捎带上， 而if_modified_since将根据后面的参数决定如何处理If-Modified-Since头部.</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 问题集</title>
      <link href="2021/05/01/Nginx/Nginx%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/01/Nginx/Nginx%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-如何保证所有worker进程之上的客户端请求数尽量接近。"><a href="#Nginx-如何保证所有worker进程之上的客户端请求数尽量接近。" class="headerlink" title="Nginx 如何保证所有worker进程之上的客户端请求数尽量接近。"></a>Nginx 如何保证所有worker进程之上的客户端请求数尽量接近。</h2><p><strong>使用accept_mutex锁</strong>。accept_mutex是Nginx的负载均衡锁,accept_mutex这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接,当某一个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时， 会大大地减小该worker进程试图建立新TCP连接的机会， 以此实现所有worker进程之上处理的客户端请求数尽量接近。</p><h2 id="Nginx-如何处理一个HTTP请求"><a href="#Nginx-如何处理一个HTTP请求" class="headerlink" title="Nginx 如何处理一个HTTP请求"></a>Nginx 如何处理一个HTTP请求</h2><p>Nginx会取出header头中的Host， 与每个server中的。server_name进行匹配， 以此决定到底由哪一个server块来处理这个请求。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>如果Host与多个server块中的server_name都匹配， 这时就会根据匹配优先级来选择实际处理的server块。<br>匹配优先级：</p><ol><li>首先选择所有字符串完全匹配的server_name</li><li>其次选择通配符在前面的server_name</li><li>再次选择通配符在后面的server_name</li><li>最后选择使用正则表达式才匹配的server_name</li></ol><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>Nginx对于每个建立成功的<strong>TCP连接</strong>会预先分配一个内存池.connection_pool_size配置项将指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。<br>Nginx开始处理HTTP请求时， 将会为<strong>每个请求</strong>都分配一个内存池，request_pool_size指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。<br>TCP连接关闭时会销毁connection_pool_size指定的连接内存池， HTTP请求结束时会销毁request_pool_size指定的HTTP请求内存池， 但它们的创建、 销毁时间并不一致， </p><h2 id="Nginx-location"><a href="#Nginx-location" class="headerlink" title="Nginx location"></a>Nginx location</h2><p>location会尝试根据用户请求中的URI来匹配上面的/uri表达式。location是有顺序的， 当一个请求有可能匹配多个location时， 实际上这个请求会被第一个location处理。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ol><li>= 表示把URI作为字符串， 以便与参数中的uri做完全匹配</li><li>~ 表示匹配URI时是字母大小写敏感的。</li><li>~* 表示匹配URI时忽略字母大小写问题。</li><li>^~ 表示匹配URI时只需要其前半部分与uri参数匹配即可。</li><li>@ 表示仅用于Nginx服务内部请求之间的重定向， 带有@的location不直接处理用户请求</li></ol><h2 id="alisa和root的差别"><a href="#alisa和root的差别" class="headerlink" title="alisa和root的差别"></a>alisa和root的差别</h2><ol><li>使用alias时，目录名后面一定要加”/“。</li><li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用</li><li>alias只能位于location块中</li><li>root的处理结果是：root路径 ＋ location路径，而alisa会使用alias路径替换location路径</li></ol><h2 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h2><ol><li>Nginx 事件循环机制</li><li>Nginx 处理Http请求流程</li><li>Nginx 如何做热部署</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 关系数据库类型</title>
      <link href="2021/05/01/SQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/05/01/SQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>关系型数据库类型</p><h2 id="OLTP-Online-transaction-processing"><a href="#OLTP-Online-transaction-processing" class="headerlink" title="OLTP:(Online transaction processing)"></a>OLTP:(Online transaction processing)</h2><p>OLTP管理组织的日常事务。主要目标是数据处理而不是数据分析</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>大量的短时间交易请求和处理</li><li>对信息进行增删改查的操作，常常需要查询明细信息</li><li>必须保证事务和数据的一致性</li><li>通常要支持大量的并发用户<h2 id="OLAP-Online-analytical-processing"><a href="#OLAP-Online-analytical-processing" class="headerlink" title="OLAP:(Online analytical processing)"></a>OLAP:(Online analytical processing)</h2>OLAP可为业务决策提供数据分析，主要目标是数据分析而不是数据处理<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3></li><li>数据量通常比较大</li><li>大部分操作是Select</li><li>数据一致性不是非常的关键</li><li>以读操作为主，很少更新</li><li>并发查询的量通常不会很大</li></ul><p>reference：<a href="https://my.oschina.net/taogang/blog/4953500">https://my.oschina.net/taogang/blog/4953500</a><br><a href="https://my.oschina.net/taogang/blog/3167206">https://my.oschina.net/taogang/blog/3167206</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE 指导思想</title>
      <link href="2021/05/01/SRE/SRE%20%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/"/>
      <url>2021/05/01/SRE/SRE%20%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h1><h2 id="拥抱风险"><a href="#拥抱风险" class="headerlink" title="拥抱风险"></a>拥抱风险</h2><h3 id="管理风险"><a href="#管理风险" class="headerlink" title="管理风险"></a>管理风险</h3><p>管理服务的可靠性很大程度上是通过管理风险来进行的。<br>需要将运维风险和业务风险结合。提高一项服务的可靠性，但不会超过该服务的可靠性<br>高昂的成本在于以下两个维度</p><ol><li>冗余物理服务器/计算资源的成本<br>投入冗余设备，能够进行更多的维护操作，又能利用空间来提供一定程度的数据持久化保证</li><li>机会成本<h3 id="度量服务风险"><a href="#度量服务风险" class="headerlink" title="度量服务风险"></a>度量服务风险</h3></li></ol><ul><li>基于时间的可用性：可用性 = 系统正常运行时间/(系统正常运行时间+停机时间)</li><li>合计可用性：可用性 = 成功请求数/总的请求数<h3 id="服务的风险容忍度"><a href="#服务的风险容忍度" class="headerlink" title="服务的风险容忍度"></a>服务的风险容忍度</h3><h4 id="消费者服务的风险容忍度"><a href="#消费者服务的风险容忍度" class="headerlink" title="消费者服务的风险容忍度"></a>消费者服务的风险容忍度</h4></li><li>需要的可用性水平是什么</li><li>不同类型的失败对服务有不同的影响吗</li><li>我们如何使用服务成本来帮助在风险曲线上定位这个服务</li><li>有哪些其他重要的服务指标需要考虑<h5 id="可用性目标"><a href="#可用性目标" class="headerlink" title="可用性目标"></a>可用性目标</h5>服务的可用性目标通常取决于它提供的功能</li><li>用户期望的服务水平</li><li>这项服务是否直接关系到收入</li><li>这是有偿还是免费的</li><li>市场有竞争对手，那竞争对手提供的服务水平如何</li><li>服务是针对消费者还是企业的<h5 id="故障类型"><a href="#故障类型" class="headerlink" title="故障类型"></a>故障类型</h5>根据业务对服务的停机时间的容忍程度有多高<h5 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h5></li><li>构建再过一个9的系统，收益会增加多少</li><li>额外的首付是否能抵消为了达到这一可靠性水平付出的成本<h4 id="基础设施服务的风险容忍度"><a href="#基础设施服务的风险容忍度" class="headerlink" title="基础设施服务的风险容忍度"></a>基础设施服务的风险容忍度</h4>不同于消费者服务，基础设施组件有多个客户，而且他们通常有很多不同的需求<br>关键战略：明确划分水平</li></ul><h2 id="质量服务目标"><a href="#质量服务目标" class="headerlink" title="质量服务目标"></a>质量服务目标</h2><h3 id="SLI-服务质量指标"><a href="#SLI-服务质量指标" class="headerlink" title="SLI(服务质量指标)"></a>SLI(服务质量指标)</h3><p>几个关键指标</p><ul><li>请求延迟</li><li>错误率(请求处理失败的百分比)</li><li>系统吞吐量(每秒请求数量)</li><li>可用性(服务可用时间的百分比)<h3 id="SLO-服务质量目标-Service-Level-Objectives"><a href="#SLO-服务质量目标-Service-Level-Objectives" class="headerlink" title="SLO(服务质量目标) Service Level Objectives"></a>SLO(服务质量目标) Service Level Objectives</h3>某个SLI值&lt;=目标值或者SLI在某个目标范围<h3 id="SKA-服务质量协议"><a href="#SKA-服务质量协议" class="headerlink" title="SKA(服务质量协议)"></a>SKA(服务质量协议)</h3>指服务和用户之间的一个协议，描述没有达到SLO之后的后果</li></ul><h2 id="减少琐事"><a href="#减少琐事" class="headerlink" title="减少琐事"></a>减少琐事</h2><p>琐事</p><ul><li>手动的</li><li>重复性的</li><li>可以被自动化的</li><li>战术性的</li><li>没有持久价值的</li><li>与服务同步线性增长的<br>SRE活动</li><li>软件工程：<br>编写修改代码，以及所有其他相关的设计和文档工作。如，编写自动化脚本，创造工具或者框架，增加可用性扩展和可靠性服务或修改基础设施代码使其更稳健</li><li>系统工程：<br>配置生产系统、修改现存配置或通过一种一次性工作产生持久的改进的方法来书写文档。例如，监控的部署和更新、负载均衡的配置、服务器配置和操作系统参数调整和负载均衡器的部署</li><li>琐事：</li><li>流程负担：<br>与运维服务不直接相关的行政工作。如任务系统的定期清理，工作总结，自我评价以及培训课程</li></ul><h2 id="分布式监控"><a href="#分布式监控" class="headerlink" title="分布式监控"></a>分布式监控</h2><ul><li>监控：收集、处理、汇总并显示光宇某个系统的实时量化数据。如请求类型和错误数量和类型，以及处理用时，应用服务器的存活时间</li><li>白盒监控：依靠系统内部暴露的一些性能指标进行监控。包括日志分析，java虚拟机提供的监控接口或者一个列出内部统计数据的HTTP接口监控</li><li>黑盒监控：通过测试某种外部用户的系统行为进行监控</li><li>监控台页面：提供某个服务核心指标一览服务的应用程序。该程序提供过滤功能、选择功能。主要用以显示系统最重要的指标。</li><li>警报</li><li>根源问题</li><li>节点和机器</li></ul><h3 id="为什么需要监控"><a href="#为什么需要监控" class="headerlink" title="为什么需要监控"></a>为什么需要监控</h3><ul><li>分析长期趋势</li><li>跨事件范围比较或者观察实验组和控制组之间的区别</li><li>报警</li><li>构建监控台页面：回答有关服务的一些基本问题。如四个黄金指标</li><li>临时性回溯分析：在线调试<h3 id="四个黄金指标"><a href="#四个黄金指标" class="headerlink" title="四个黄金指标"></a>四个黄金指标</h3></li><li>延迟：服务器处理某个请求所需要的时间</li><li>流量：系统某个高层次的指标针对系统负载需求锁进行的度量</li><li>错误：请求失败的速率</li><li>饱和度：系统中目前最为受限的某种资源的某个具体指标的度量</li></ul><h3 id="简化监控系统"><a href="#简化监控系统" class="headerlink" title="简化监控系统"></a>简化监控系统</h3><ul><li><p>最能反映真实故障的规则越简单越好，可预测性强,非常可靠</p></li><li><p>不常用的数据收集、汇总以及警报配置应该定时删除</p></li><li><p>收集到的信息，但是没有暴露给控制台或者没有被任何警报规则使用的应该定时删除</p><h3 id="减少误报"><a href="#减少误报" class="headerlink" title="减少误报"></a>减少误报</h3></li><li><p>该规则是否能够检测到一个目前检测不到的、紧急的、有操作性的，并且即将发生或者已经发生的用户可见故障</p></li><li><p>是否可以忽略这条警报？什么情况下可能会导致用户忽略这条警报，如何避免？</p></li><li><p>这条警报是否确实显示了用户正在受到影响？是否存在用户没有收到影响也可以触发这条规则的情况。例如测试环境和系统维护状态下发出的警报是否被过滤掉</p></li><li><p>收到警报后是否需要进行某个操作，是否要立即执行。该操作是否可以被安全自动化，操作的效果是长期还是短期</p></li><li><p>是否也会有其他人收到相关的紧急警报，这个警报是否不必要</p></li><li><p>每个警报都应该是具体可操作的</p></li><li><p>每个紧急警报的回复都是需要某种智力分析过程，如果某个紧急警报只是需要一个固定的机械动作，那就不应该成文警报</p></li><li><p>每个紧急警报都应该是关于新问题的，不应该彼此重叠</p></li></ul><h2 id="自动化的价值"><a href="#自动化的价值" class="headerlink" title="自动化的价值"></a>自动化的价值</h2><ul><li>一致性</li><li>平台性</li><li>修复速度更快：能够降低一些常见故障的平均修复时间</li><li>行动速度更快</li><li>节省时间<h4 id="专业化倾向"><a href="#专业化倾向" class="headerlink" title="专业化倾向"></a>专业化倾向</h4>自动化程序的不同体现在</li><li>准确性</li><li>延迟：即开始后，执行步骤需要多久</li><li>相关性：自动化所涵盖的实际流程比例</li></ul><h2 id="发布工程"><a href="#发布工程" class="headerlink" title="发布工程"></a>发布工程</h2><h3 id="发布工程的哲学"><a href="#发布工程的哲学" class="headerlink" title="发布工程的哲学"></a>发布工程的哲学</h3><ul><li>自服务模型</li><li>追求速度</li><li>密闭性</li><li>强调策略和流程</li></ul><h2 id="简单化"><a href="#简单化" class="headerlink" title="简单化"></a>简单化</h2><p>SRE管理系统：工作最终是在系统灵活性和稳定性上维持平衡<br>为了最小化意外复杂度，应该</p><ul><li>在他们所复杂的系统音符意外复杂度，及时提出抗议</li><li>不断努力消除正在接受的和已经负责运维的系统的复杂度<br>软件的简单性是可靠性的前提</li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE 方法论</title>
      <link href="2021/05/01/SRE/SRE%20%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2021/05/01/SRE/SRE%20%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h1><h2 id="承担的职责："><a href="#承担的职责：" class="headerlink" title="承担的职责："></a>承担的职责：</h2><p>可用性改进，延迟优化，性能优化，效率优化，变更管理，监控，紧急事务处理，容量规划与管理</p><h2 id="工作内容："><a href="#工作内容：" class="headerlink" title="工作内容："></a>工作内容：</h2><p>开发监控系统，规划容量，处理紧急事件，确保事故根源被跟踪修复</p><h2 id="核心方法论："><a href="#核心方法论：" class="headerlink" title="核心方法论："></a>核心方法论：</h2><ol><li>确保长期关注研发工作<ol><li>将运维工作限制在50%以内，剩余时间花在项目研发上</li><li>运维工作的一项准则：在每8~12个小时的on-cal轮值期间最多只处理两个紧急的事件，确保on-call工程师能够有足够的时间跟进紧急事件，能够正确的处理故障，恢复服务并且撰写事后报告。</li><li>事后总结应该包括内容：事故发生，发现，解决的全过程。事故的根本原因、预防或者优化解决方案</li></ol></li><li>在保障服务SLO（服务等级目标）的前提下最大化迭代速度<ol><li>在办证业务服务的可靠性需求的同事尽可能加快功能上线速度</li><li>错误预算。SRE的目标是不是达到100%可靠。而是基于以下考虑<ol><li>基于用户的使用习惯，服务可靠性要达到什么程度用户才会满意</li><li>如果这项服务的可靠程度不够，用户是否有其他的替代选择</li><li>服务的可靠程度是否会影响用户对这服务的使用模式</li></ol></li></ol></li><li>监控系统<br>系统不应该依赖人来分析警报信息，而是由系统自动分析。仅当需要用户执行某些操作的时候才通知用户<br>一个监控系统应该只有3类输出<ul><li>紧急警报：收到警报的用户需要立即执行某种操作。目标是解决某种已经发生的问题或者避免即将发生的问题</li><li>工单：以为着接受工单的用户应该执行某种操作，并非立即执行。系统并不能自动解决目前的情况。但是用户在几天内执行这项操作，系统不会受到任何影响</li><li>日志：日志信息依旧需要被收集起来以备调试和事后分析使用</li></ul></li><li>应急事件处理<br>可靠性是平均失败时间(MTTF)和平均回复时间(MTTR)的函数。使用运维手册可以缩短平均回复时间。可以将工作重心放在“运维手册”的维护上，同时通过灾难演练培训团队成员</li><li>需求预测和容量规划<br>简单说就是保障一个业务有足够的容量和冗余度去服务预测中的未来需求。业务的容量规划，需要包括自然增长(随着用户使用量的上升，资源用量也上升)和非自然增长(新功能的发布，商业推广和其他因素)<br>必须步骤：<ol><li>必须有一个准确的自然增长需求预测模型，需求预测的时间应该超过资源获取的时间</li><li>规划中必须有准确的非自然增长的需求来源统计</li><li>必须有周期性压力测试，以便准确地将系统原始资源与业务容量对应起来</li></ol></li><li>资源部署<br>资源的部署是变更管理与容量规划的结合物。新资源的部署与配置需要谨慎执行。</li><li>效率与性能<br>密切关注一个服务的容量配置策略，进而改进其资源利用率，降低系统的总成本。<br>资源的使用情况的驱动因素：<ul><li>用户需求(流量)</li><li>可用容量和软件</li><li>资源使用效率</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE实践</title>
      <link href="2021/05/01/SRE/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/05/01/SRE/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="故障排查手段"><a href="#故障排查手段" class="headerlink" title="故障排查手段"></a>故障排查手段</h3><p>故障报告–&gt; 定位问题 –&gt; 检查 –&gt; 诊断 –&gt; 测试/修复 –&gt; 治愈<br>常见的问题主要集中在定位、检查和诊断环节上<br>应该避免</p><ul><li>关注了错误的系统现象，或者错误地理解了系统现象的含义</li><li>不能正确修改系统的配置信息、输入信息或者系统运行环境，造成不能安全和有效地的是假设</li><li>将问题过早地归结为极为不可能的因素，或者念念不忘之前曾今发生过的系统问题</li><li>试图解决与当前系统问题相关的问题，却没有认识到这些其实只是翘课或者这些问题其实是由于当前系统的问题造成的<br>遇到问题的正确做法是尽最大可能让系统恢复服务，缓解系统问题是第一要务</li></ul><h3 id="事故流程管理"><a href="#事故流程管理" class="headerlink" title="事故流程管理"></a>事故流程管理</h3><ol><li>划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场</li><li>事前准备：事先和所有事故处理参与者一起准备一套流程</li><li>信任：充分相信每个事故参与者，分配职责让他们自主行动</li><li>反思：在事故处理过程中注意自己的情绪和精神状态，发现自己开始惊慌失措或者感觉到压力难以承受，应寻求更多的帮助</li><li>考虑替代方案：周期性重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行更重要的事情或者更紧急的事情</li><li>联系：平常不断地使用这项流程，直到习惯成自然</li><li>换位思考：上次你是事故总负责人，下一可以换一个职责试试，鼓励每个团队成员熟悉流程中的其他角色</li></ol><h3 id="事后总结"><a href="#事后总结" class="headerlink" title="事后总结"></a>事后总结</h3><p>需要总结的条件：</p><ul><li>用户可见的宕机事件或者服务质量降级程度达到一定标准</li><li>任何类型的数据丢失</li><li>on-call工程师需要人工介入的事故(包括回滚、切换用户流量)</li><li>问题解决耗时超过一定限制</li><li>监控问题(预示着问题由人工发现的，而非警报系统)<h4 id="协作和共享"><a href="#协作和共享" class="headerlink" title="协作和共享"></a>协作和共享</h4>工具选择：</li><li>实时协作</li><li>开放的评论系统</li><li>邮件通知<br>事后总结还包括正式的评审和发布过程，首先在团队内部发布，同时有目的的找资深工程师评估文档的完整程度，评审条件</li><li>关键的灾难数据是否已经被收集并且保存起来</li><li>本次事故的影响评估是否完整</li><li>造成事故的根源问题是否足够深入</li><li>文档中记录的任务优先级是否合理，能否即使解决了根源问题</li><li>事故处理过程是否共享了所有相关部门</li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务可靠度模型</title>
      <link href="2021/05/01/SRE/%E6%9C%8D%E5%8A%A1%E5%8F%AF%E9%9D%A0%E5%BA%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/01/SRE/%E6%9C%8D%E5%8A%A1%E5%8F%AF%E9%9D%A0%E5%BA%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="服务可靠度模型"><a href="#服务可靠度模型" class="headerlink" title="服务可靠度模型"></a>服务可靠度模型</h1><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li>产品设计</li><li>软件开发</li><li>容量规划</li><li>测试+发布</li><li>事后总结/问题根源分析</li><li>应急事件处理</li><li>监控<h4 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h4>大型监控系统的难点</li></ol><ul><li>大型系统中组件数量特别多，分析工作繁杂繁重</li><li>监控系统本身的维护要求必须非常低<br>时序性监控(borgmon 和 prometheus)<br><a href="https://yq.aliyun.com/articles/664669">zabbix和prometheus的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8工作原理</title>
      <link href="2021/05/01/browser/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/01/browser/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="V8工作原理"><a href="#V8工作原理" class="headerlink" title="V8工作原理"></a>V8工作原理</h1><h2 id="数据是如何存储的？"><a href="#数据是如何存储的？" class="headerlink" title="数据是如何存储的？"></a>数据是如何存储的？</h2><ul><li>栈空间</li></ul><ol><li>通常用来存放一些原始类型的小数据</li></ol><ul><li>堆空间</li></ul><ol><li>通常用来存放引用类型的数据</li></ol><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="代际假说"><a href="#代际假说" class="headerlink" title="代际假说"></a>代际假说</h3><ol><li>大部分对象在内存中存在的时间很短</li><li>不死对象就会获得很久<h3 id="新生代和老生代"><a href="#新生代和老生代" class="headerlink" title="新生代和老生代"></a>新生代和老生代</h3></li><li>生存时间短的对象放在新生代</li><li>生存时间久的对象放在老生代</li><li>新生代和老生代分别使用不同的垃圾回收机制<ol><li>新生代使用副垃圾回收机制</li><li>老生带使用主垃圾回收机制</li></ol></li></ol><h3 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h3><h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><ol><li>使用scavenge算法，把新生代划分为两个区域，一半是对象区域，一半是空闲区域</li><li>当对象空间快满的时候，才执行对象回收操作</li><li>首先对对象区域的垃圾做标记</li><li>标记完后，将活着的对象移到空闲区域，同时有序的排列起来</li><li>完成复制后，对象区域和空间区域进行互换<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4></li><li>使用标记-整理算法</li></ol><h4 id="垃圾回收的全停顿"><a href="#垃圾回收的全停顿" class="headerlink" title="垃圾回收的全停顿"></a>垃圾回收的全停顿</h4><ul><li>进行一次标记-清理-整理，需要一段时间。这种行为就是全停顿，影响应用的性能和响应能力</li><li>为了降低老生代垃圾回收造成的卡顿。V8使用增量标记算法，将垃圾回收标记和应用逻辑交替执行，直到标记阶段完成。</li></ul><h2 id="V8如何执行一段代码"><a href="#V8如何执行一段代码" class="headerlink" title="V8如何执行一段代码"></a>V8如何执行一段代码</h2><ol><li>生成抽象语法树(AST)和执行上下文<ol><li>词法分析</li><li>语法分析</li></ol></li><li>生成字节码<ol><li>解释器Ignition会根据AST生成字节码，并执行字节码</li></ol></li><li>执行代码<ol><li>生成字节码之后，解释器Ignition会逐条解释执行。</li><li>如果发现有热点代码(一段代码被重复执行多次),编译器TurboFan会把这段热点的字节码编译成机器码</li><li>当这段代码再次被执行的时候，执行编译后的机器码就可以了(JIT技术)</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome</title>
      <link href="2021/05/01/browser/chrome/"/>
      <url>2021/05/01/browser/chrome/</url>
      
        <content type="html"><![CDATA[<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>Chrome 包括1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程</p><ul><li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能</li><li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下</li><li>GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程</li><li>网络进程。主要负责页面的网络资源加载.</li><li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>localStorage和sessionStorage</title>
      <link href="2021/05/01/browser/localStorage/"/>
      <url>2021/05/01/browser/localStorage/</url>
      
        <content type="html"><![CDATA[<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><h4 id="localStorage-和-sessionStorage不同点"><a href="#localStorage-和-sessionStorage不同点" class="headerlink" title="localStorage 和 sessionStorage不同点"></a>localStorage 和 sessionStorage不同点</h4><ul><li>localStorage 是没有时间限制的，永久的。除非特定的清除localStorage或者通过浏览器来清除</li><li>sessionStorage 生命周期为当前窗口或者标签页，当窗口或者标签页被清除时，sessionStorage就会被清空。（页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage）</li></ul><h4 id="localStorage的优点："><a href="#localStorage的优点：" class="headerlink" title="localStorage的优点："></a>localStorage的优点：</h4><ol><li>localStorage拓展了cookie的4K限制，扩展到5M</li><li>localStorage会可以将请求的数据直接存储到本地</li><li>遵循同源策略，不同的网站直接是不能共用相同的localStorage</li></ol><h4 id="localStorage的缺点："><a href="#localStorage的缺点：" class="headerlink" title="localStorage的缺点："></a>localStorage的缺点：</h4><ol><li>浏览器的localStorage大小不统一，只有IE8以上的IE版本才支持localStorage这个属性</li><li>localStorage的值类型限定为string类型。即使你存储的是数组和对象，localStorage也会将数组和对象以字符串的形式存储。</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage过大会导致页面卡顿</li><li>localStorage不能被爬虫爬取</li></ol><p>参考</p><p><a href="http://www.manongjc.com/article/35746.html">http://www.manongjc.com/article/35746.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入URL 到页面展示</title>
      <link href="2021/05/01/browser/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
      <url>2021/05/01/browser/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="输入URL-到页面展示"><a href="#输入URL-到页面展示" class="headerlink" title="输入URL 到页面展示"></a>输入URL 到页面展示</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="..%5Cimage%5C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E6%B5%81%E7%A8%8B.png" alt="展示过程"></p><h2 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1. 用户输入"></a>1. 用户输入</h2><ol><li>如果是搜索内容，地址栏会使用浏览器的默认搜索引擎合成搜索关键字的url</li><li>如果输入内容符合url规则，浏览器会根据规则，并加上协议，合成为完整的URL</li></ol><h2 id="2-URL请求过程"><a href="#2-URL请求过程" class="headerlink" title="2. URL请求过程"></a>2. URL请求过程</h2><ol><li>浏览器进程会吧进程间通信(IPC)把URL请求发送倒网络进行</li><li>网络进程接收到URL请求后，会查本地进程是否缓存了该资源，有则直接返回资源给浏览器进程</li><li>如果没有，则进行DNS解析，获取IP地址。如果是HTTPS请求，还需要建立TLS连接</li><li>理网络进程利用IP地址和服务器建立连接，完成后，会根据请求行，请求头等信息，并把和该域名相关的cookie信息附加到请求头，然后向服务器端发送构建请求信息</li><li>服务器接受到请求信息后，根据请求信息生成响应数据(包含响应头，响应行，响应体等信息)并发给网络进程</li><li>网络进程接收到响应行和响应头之后，解析响应头内容</li><li>解析响应头为301或者302，重定向到响应头里面的Location字段的地址</li><li>解析响应头为3202，会解析响应数据类型，解析响应数据类型为text/html，则浏览器会准备渲染进程</li><li>若为其他响应数据类型，则有对应的处理</li></ol><h2 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="3. 准备渲染进程"></a>3. 准备渲染进程</h2><ol><li>每个标签对应一个渲染进程</li><li>如果新页面和当前页面是属于同一个站点的话，那么新页面就会复用父页面的渲染进程</li></ol><h2 id="4-提交文档-URL请求的响应体数据"><a href="#4-提交文档-URL请求的响应体数据" class="headerlink" title="4. 提交文档(URL请求的响应体数据)"></a>4. 提交文档(URL请求的响应体数据)</h2><ol><li>“提交文档消息”由浏览器进程发出，渲染进程接收到提交文档后，会和网络进程建立传输数据的管道</li><li>当数据传输完成后，渲染进程会返回“确认提交”的消息给到浏览器进程</li><li>浏览器进程收到确认提交消息后，会更新浏览器界面状态。包括安全转态、地址栏URL、前进后退的历史状态，并更新web压面</li></ol><h2 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="5. 渲染阶段"></a>5. 渲染阶段</h2><p>页面完成后，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止变迁的图标变化</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的JavaScript的执行机制</title>
      <link href="2021/05/01/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>2021/05/01/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的JavaScript的执行机制"><a href="#浏览器的JavaScript的执行机制" class="headerlink" title="浏览器的JavaScript的执行机制"></a>浏览器的JavaScript的执行机制</h1><h2 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h2><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><ol><li>在代码执行过程汇总，JavaScript引擎将变量的声明部分和函数的声明部分提升到代码开头。</li><li>变量被提升后，会给变量设置默认值</li></ol><h3 id="JavaScript的执行流程"><a href="#JavaScript的执行流程" class="headerlink" title="JavaScript的执行流程"></a>JavaScript的执行流程</h3><p><img src="/images/V8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JavaScript%E4%BB%A3%E7%A0%81.png" alt="JavaScript的执行流程"></p><ol><li>语法检查</li><li>预编译阶段<ol><li>js的运行环境<ol><li>全局环境，代码进入预编译即进入了全局环境</li><li>函数环境，函数执行调用，就进入该函数的函数韩静</li><li>eval环境，(允许执行代码字符串，避免使用)</li><li>每进入一个环境都会创建一个相应的执行上下文。js引擎会以栈的方式对这些执行上下文进行处理，形成函数调用栈</li></ol></li><li>函数调用栈<ol><li>首次运行时，会创建一个全局执行上下文并push到栈中</li><li>每当发生函数调用，就会创建新的函数执行上下文push到栈顶</li><li>函数完成后，对应函数的执行上下文会从栈中pop出，上下文控制权交给下一个执行上下文</li></ol></li><li>执行上下文的创建<ol><li>创建变量对象<ol><li>变量提升，函数声明的优先级高于变量声明的优先级</li><li>此时，变量属性都未赋值，默认为undefined</li></ol></li><li>建立作用域链<ol><li>创建作用域链，就是创建词法环境</li><li>词法环境由两部分组成<ol><li>环境记录：环境变量和函数声明的实际位置</li><li>对外部环境的引用：可以访问其外部词法环境</li></ol></li></ol></li><li>确定this的指向<ol><li>this是和执行上下文绑定的，每个执行上下文都有一个this</li><li>全局中的this是指向window对象的</li><li>this指向完全取决于函数调用的位置</li><li>嵌套函数的this不会从外层函数中继承</li></ol></li></ol></li></ol></li><li>执行阶段</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="2021/05/01/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>2021/05/01/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存流程"><a href="#缓存流程" class="headerlink" title="缓存流程"></a>缓存流程</h1><p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png" alt="浏览器缓存"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染流程</title>
      <link href="2021/05/01/browser/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
      <url>2021/05/01/browser/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p><img src="/images/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="渲染流水线"></p><h2 id="1-HTML-转化成DOM树"><a href="#1-HTML-转化成DOM树" class="headerlink" title="1. HTML 转化成DOM树"></a>1. HTML 转化成DOM树</h2><h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><ol><li>网络进程接收到响应头的content-type字段为html的时候，就会请求选择或创建一个管道</li><li>渲染进程准备好后，会建立一个共享的数据管道</li><li>当网络进程接收到数据以后，就会将数据送入管道中</li><li>渲染进程的动态的从管道中接收字节流，进行词法分析，解析成DOM节点，然后添加到DOM树中</li><li>当包含了CSS的引用的时候，需在先构建CSSOM树，而JS又可以改变CSS，所以执行JS依赖于CSSOM树</li><li>当执行到了JS的脚本，暂停整个DOM的解析，JavaScript引擎介入并执行这段脚本，之后继续解析<h3 id="DOM构建流程图"><a href="#DOM构建流程图" class="headerlink" title="DOM构建流程图"></a>DOM构建流程图</h3><img src="/images/DOM%E6%A0%91%E6%9E%84%E9%80%A0.png" alt="DOM构建流程图"><h3 id="构建中的优化"><a href="#构建中的优化" class="headerlink" title="构建中的优化"></a>构建中的优化</h3></li><li>JS文件下载会阻塞DOM的解析，Chrome在接收到字节流的时候，添加了预解析的流程，开启预解析线程，分析HTML中的JS,CSS文件，然后提前下载JS CSS 文件</li><li>也可以使用CDN，或者压缩JS文件体积来加速JS文件的下载</li><li>如果JS没有操作DOM的代码，可以设置JS脚本设置为异步加载</li><li>对于大的CSS，可能拆分多个不同用途的CSS文件，这样在特定的场景才会加载特定的CSS文件<h2 id="2-构建CSSOM-树"><a href="#2-构建CSSOM-树" class="headerlink" title="2. 构建CSSOM 树"></a>2. 构建CSSOM 树</h2></li><li>将CSS文本转换成styleSheets(样式表)结构中的数据<ul><li>CSS来源<ul><li>通过link引用外部CSS文件</li><li>&lt;style&gt;标记内的CSS</li><li>元素style属性内嵌的CSS</li></ul></li></ul></li><li>转换样式表中的属性值，使其标准化(如将所有的em解析成px，颜色解析成rgb)</li><li>计算出DOM树每个节点的具体样式<ul><li>CSS的继承规则</li><li>CSS的层叠规则<h2 id="3-布局阶段"><a href="#3-布局阶段" class="headerlink" title="3. 布局阶段"></a>3. 布局阶段</h2></li></ul></li><li>创建布局树(渲染树)<ol><li>遍历DOM树中所有可见节点，并将这些节点加到布局树种</li><li>不可见的节点将忽略，如head下面的全部内容</li></ol></li><li>布局计算<ol><li>计算不布局树节点的坐标位置<h2 id="4-分层"><a href="#4-分层" class="headerlink" title="4. 分层"></a>4. 分层</h2></li></ol></li><li>生成图层树<ol><li>拥有层叠上下文属性的元素会被提升为单独一层</li><li>需要剪裁的地方也会被创建为图层<h2 id="5-图层绘制"><a href="#5-图层绘制" class="headerlink" title="5. 图层绘制"></a>5. 图层绘制</h2>渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成待绘制列表<br>(绘制列表只用来记录绘制顺序和绘制指令)<h2 id="6-光栅化"><a href="#6-光栅化" class="headerlink" title="6. 光栅化"></a>6. 光栅化</h2></li></ol></li><li>当图层的绘制列表完成后，主线程会将列表提交给合成线程</li><li>合成线程会将图层划分为图块，然后按照视口附近的图块通知渲染进程生成位图</li><li>渲染进程维护一个栅格化线程池，生成位图的操作是有栅格化线程来执行。而图块是栅格化执行的最小单位</li><li>若有GPU，渲染进程会把生成图块的指令发给GPU，然后GPU生成图块的位图，并保存在GPU中<h2 id="7-合成"><a href="#7-合成" class="headerlink" title="7. 合成"></a>7. 合成</h2></li><li>当所有图块被光栅化之后，合成线程就会生成一个绘制图块的命令(DrawQuad)，然后提交给浏览器进程</li><li>浏览器进程将其页面内容绘制到内存中，最后显示在屏幕上</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟DOM</title>
      <link href="2021/05/01/browser/%E8%99%9A%E6%8B%9FDOM/"/>
      <url>2021/05/01/browser/%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>减少JavaScript对DOM的操作</p><ol><li>将页面改变的内容应用到虚拟DOM上，而不是直接应用到DOM上</li><li>变化被应用到虚拟DOM上时，虚拟DOM并不急着渲染界面，而是调整虚拟DOM的内部状态</li><li>当虚拟DOM收集到足够的改变时，再将这一些变化应用到真实的DOM上</li></ol><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><p>通过JavaScript或者CSS 修改元素的几何位置属性。触发浏览器的重新布局</p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>修改元素的背景色，布局并没有发生改变。相对于重排，省去了布局和分层阶段</p><h3 id="重新合成"><a href="#重新合成" class="headerlink" title="重新合成"></a>重新合成</h3><p>渲染引擎跳过布局和绘制，在非主线程上执行合成动画的操作</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU</title>
      <link href="2021/05/01/composition_principle/CPU/"/>
      <url>2021/05/01/composition_principle/CPU/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h2><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>功能：接受来自控制器宋老的命令并执行相应的动作。</p><p>包含</p><ul><li>ALU 算术逻辑单元</li><li>暂存寄存器</li><li>ACC 累加寄存器</li><li>通用寄存器组</li><li>PSW 程序状态寄存器组</li><li>移位器</li><li>计数器</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>功能：执行指令，每条指令的执行都是由控制器发出的一组微操作实现的。</p><p>工作原理：根据指令操作码、指令的执行步骤（微命令的序列）和条件信号来形成当前计算机各部件要用到的控制信号。</p><p>包含</p><ul><li>PC 程序计数器</li><li>IR 指令寄存器</li><li>指令译码器</li><li>MAR 存储地址寄存器</li><li>MDR 存储数据寄存器</li><li>时序系统</li><li>微操作信号发生器</li></ul><p>控制器分为硬布线控制器和微程序控制器</p><h4 id="硬布线控制器：由复杂的组合逻辑门电路和触发器构成"><a href="#硬布线控制器：由复杂的组合逻辑门电路和触发器构成" class="headerlink" title="硬布线控制器：由复杂的组合逻辑门电路和触发器构成"></a>硬布线控制器：由复杂的组合逻辑门电路和触发器构成</h4><p>原理：根据指令的要求、当时的时序和内外部的状态情况，按时间的顺序发送一系列的微操作控制信号</p><h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p>思想：将每一条机器指令编写成一个微程序</p><p>一个微程序包含若干跳微指令（微操作 = 微命令 &lt; 微指令 &lt; 微程序 &lt; 机器指令 ）</p><p>若有n种机器指令，则微程序数至少是n+2个（增加一个为公共取值的微程序，一个为对应终端周期的微程序）</p><p>微指令的组成：控制寄存器（CM）、微指令寄存器（CMAR）、微地址形成部件、微地址寄存器（CMDR）</p><p>工作过程：</p><ol><li>将微程序的入口地址送到CMAR，并从CM中读取相应的微指令送到CMDR</li><li>机器指令的操作码字段通过微地址形成部件产生微程序的入口地址，送到CMAR</li><li>从CM中读取对应的微指令并执行</li><li>执行完一条机器指令的微程序后又回到微程序的入口地址，继续执行第一步</li></ol><p>微指令的编码方式</p><ol><li>直接编码控制</li><li>字段直接编码方式</li><li>字段间接编码方式</li></ol><p>微指令的格式</p><ol><li>水平型</li><li>垂直型</li><li>混合型</li></ol><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p> 指令周期：执行一条指令所需要的全部时间</p><p>一个指令周期包含多个机器周期，一个机器周期包含多个时钟周期</p><p>取值周期：根据PC的内容从主存中取出指令代码并存放在IR中</p><p>间址周期：取操作数的有效地址存放在MDR中</p><p>执行周期：根据IRde指令操作码和操作数通过ALU操作产生执行结果。</p><p>中断周期：处理中断请求</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O 系统</title>
      <link href="2021/05/01/composition_principle/IO%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/composition_principle/IO%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><ul><li><p>程序查询方式</p><p>CPU和I/O设备串行工作。CPU不断查询I/O设备的状态</p></li><li><p>程序中断方式</p><p>CPU和I/O设备串行工作。</p><p>思想：CPU在程序中安排好在某一时刻启动一台外设，然后CPU继续执行原来的程序，不再等待外设就绪，一旦外设完成数据传输的准备工作，外设再主动向CPU发送中断请求。</p><p>中断处理流程：（1~3由中断隐指令实现，其余由中断程序完成）</p><ol><li>关中断</li><li>保存断点</li><li>中断服务程序寻址</li><li>保存现场和屏蔽字</li><li>开中断</li><li>执行中断服务程序</li><li>关中断</li><li>恢复现场和屏蔽字</li><li>开中断</li><li>中断返回</li></ol></li><li><p>DMA方式</p><p>用于高速设备。DMA传送数据不需要经过CPU。</p><p>DMA的传送方式：</p><ol><li>停止CPU访问主存</li><li>DMA与CPU交替访存</li><li>周期挪用</li></ol><p>DMA传送过程</p><ol><li>预处理<ol><li>请求：CPU 对DMA控制器初始化，并向IO放出操作命令，I/O接口提出DMA请求</li><li>响应：DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。当总线逻辑输出总线应答的时候，表示DMA已经响应，通过DMA控制器通知IO接口开始DMA传输。</li></ol></li><li>数据传送</li><li>后处理<ol><li>完成传输后，DMA释放总线控制权，向IO接口发出结束信号。</li><li>当IO接口收到结束信号后，停止IO设备工作的同时，向CPU提出中断请求，使CPU不介入</li><li>检查本次DMA传输操作的正确性</li></ol></li></ol></li><li><p>通道方式</p></li></ul><h3 id="I-O-接口的功能"><a href="#I-O-接口的功能" class="headerlink" title="I/O 接口的功能"></a>I/O 接口的功能</h3><ul><li>实现主机和外设的通信联络控制</li><li>进行地址译码和设备选择</li><li>实现数据缓冲</li><li>信号格式的转化</li><li>传送控制命令和状态信息</li></ul><h3 id="I-O-接口的编址"><a href="#I-O-接口的编址" class="headerlink" title="I/O 接口的编址"></a>I/O 接口的编址</h3><ul><li>统一编址</li><li>独立编址：需要设置专门的输入/输出指令访问端口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="2021/05/01/composition_principle/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>2021/05/01/composition_principle/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="存储芯片的组成"><a href="#存储芯片的组成" class="headerlink" title="存储芯片的组成"></a>存储芯片的组成</h3><ul><li>存储矩阵</li><li>译码驱动</li><li>读写电路</li><li>读/写控制线</li><li>片选线</li></ul><h3 id="RAM随机存储器"><a href="#RAM随机存储器" class="headerlink" title="RAM随机存储器"></a>RAM随机存储器</h3><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>原理：使用双稳态触发器（六管MOS）作为存储元</p><p>特点：</p><ol><li><p>集成度低，功耗大</p></li><li><p>易失性半导体</p></li><li><p>一般用于高速缓存</p></li></ol><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>原理：使用栅极电容</p><p>特点：</p><ol><li><p>采用地址复用技术。地址信号分行、列两次发送</p></li><li><p>容易集成、功耗低和容量大</p></li><li><p>用于组成大容量系统</p></li><li><p>需要刷新，每隔一段时间必须刷新。通常为2ms</p><ul><li>集中刷新：读写操作不受影响，但刷新时不能访问存储器（死区）</li><li>分散刷新：只刷新一部分，另一部分正常。但会增加存取周期</li><li>异步刷新：刷新周期/行数的时间间隔产生刷新请求<ol><li>对CPU透明，不依赖于外部访问</li><li>刷新安排在译码阶段，不会增加存取周期也不会产生死区</li><li>刷新的单位是按行，刷新时只需要行地址</li><li>刷新时不需要选片，同时刷新。</li></ol></li></ul></li></ol><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><p>非易失性存储器，可靠性高</p><h3 id="存储器的扩展"><a href="#存储器的扩展" class="headerlink" title="存储器的扩展"></a>存储器的扩展</h3><h4 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h4><ol><li>位扩展</li><li>字扩展</li><li>字位同时扩展</li></ol><h4 id="地址分配和片选"><a href="#地址分配和片选" class="headerlink" title="地址分配和片选"></a>地址分配和片选</h4><ol><li>线选</li><li>片选</li></ol><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><ol><li>单体多字</li><li>多提并行<ol><li>高位交叉编址（顺序方式）</li><li>低位交叉编址（交叉方式）</li></ol></li></ol><h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><p>原理：程序访问的局部性</p><p>建立在CPU-主存上</p><p>Cache和CPU之间的数据交换是以字为单位。Cache与内存的交换是以块为单位</p><p>Cache行的标志块包括有效位、一致性维护位(脏位)、替换算法位和标记位</p><h4 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h4><ol><li><p>直接映射</p><p>主存的数据块只能装入Cache的唯一位置。需要主存标记块用于标记主存，因为一个Cache块可能放有不同的主存块。</p><p>地址结构：主存标记块+Cache地址块+字块内地址</p><p>检索流程 </p><ol><li>先通过Cache地址块找到Cache对应的行号。</li><li>使用主存标记块与该Cache的标记位进行对比。</li><li>若符合命中，则通过字内块地址读取所需要的字。否则，读取内存。</li></ol></li><li><p>全相联映射</p><p>主存数据块可以装入Cache的任何位置。</p><p>地址结构：主存块标记+字块内地址</p><p>检索流程：</p><ol><li>直接使用主存块标记和Cache中所有行的标记位进行比较。</li><li>若符合命中，则通过字内块地址读取所需要的字。否则，读取内存。</li></ol></li><li><p>组相连映射</p><p>将Cache分成大小相同的组，主存数据块可以装入组内的任意位置。即组间采取直接映射，组内采取全相联映射。</p><p>地址结构：主存字块地址+组地址+字块内地址</p><p>检索流程</p><ol><li>先用组地址找到对应的Cache组</li><li>再使用主存字块地址与该Cache组的所有行的标记位进行比较。</li><li>若符合命中，则通过字内块地址读取所需要的字。否则，读取内存。</li></ol></li></ol><h4 id="Cache的替换算法"><a href="#Cache的替换算法" class="headerlink" title="Cache的替换算法"></a>Cache的替换算法</h4><p>使用场景：全相联映射和组相联映射</p><ol><li>随机算法</li><li>FIFO</li><li>LRU（近期最少使用算法）</li><li>LFU（最不经常使用算法）</li></ol><h4 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h4><p>Cache写命中时：</p><ol><li><p>全写法</p><p>写命中时写。必须同时写入Cache和主存</p></li><li><p>写回法</p><p>Cache块换出时才写回主存。需要一个脏位来判断此块是否被修改过</p></li></ol><p>Cache写不命中时</p><ol><li><p>写分配法</p><p>加载主存中的块到Cache中，然后更新这个块</p></li><li><p>非写分配法</p><p>只写入主存，不调块</p></li></ol><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>建立在主存-辅存上</p><p>使用离散分配的内存管理方式</p><p>实现方式</p><ol><li><p>页式虚拟存储器</p><p>地址结构：虚页号+页内地址</p><p>地址转换流程：</p><ol><li>使用虚页号和页表基址寄存器的起始地址拼接成页表项地址</li><li>去页表中查找该页表项的实页号。若没有，则从辅存调用主存后再使用</li><li>将实页号与页内地址拼接成实地址</li></ol><p>优点：页面长度固定，页表简单</p><p>缺点：程序不可能正好是页面的整数倍，最后一页的零头无法利用而浪费，同时页不是逻辑上独立的实体。</p></li><li><p>段式虚拟存储器</p><p>地址结构：段号+段号地址</p><p>地址转换流程和页式虚拟存储器类型，只不过查找的是段表而不是页表。</p><p>优点：段分界与程序的自然分界对应，具有逻辑独立性，便于多道程序共享</p><p>缺点：段长度可变，分配空间不便，容易在段间留下碎片</p></li><li><p>段页式虚拟存储器</p><p>地址结构：段号+段内页号|页内地址</p><p>地址转换流程：</p><ol><li>先使用段号和段表基址寄存器得到段表地址，从段表中找出页表起始地址</li><li>再根据段内起始地址和段内页号得到页表地址，从页表中找出实页号</li><li>将实页号与页内地址拼接成实地址</li></ol><p>优点：兼具页式和段式存储器的优点</p><p>缺点：两次查表，开销大</p></li></ol><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>快表放在Cache中，慢表放在内存中。</p><p>在页式存储器和Cache的系统中。访问顺序为TLB-&gt;页表-&gt; Cache-&gt;主存</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统</title>
      <link href="2021/05/01/composition_principle/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/composition_principle/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="存储芯片的组成"><a href="#存储芯片的组成" class="headerlink" title="存储芯片的组成"></a>存储芯片的组成</h3><ul><li>存储矩阵</li><li>译码驱动</li><li>读写电路</li><li>读/写控制线</li><li>片选线</li></ul><h3 id="RAM随机存储器"><a href="#RAM随机存储器" class="headerlink" title="RAM随机存储器"></a>RAM随机存储器</h3><p>易失性存储器</p><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>原理：使用双稳态触发器（六管MOS）作为存储元</p><p>特点：</p><ol><li><p>集成度低，功耗大</p></li><li><p>易失性半导体</p></li><li><p>一般用于高速缓存</p></li></ol><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>原理：使用栅极电容</p><p>特点：</p><ol><li><p>采用地址复用技术。地址信号分行、列两次发送</p></li><li><p>容易集成、功耗低和容量大</p></li><li><p>用于组成大容量系统</p></li><li><p>需要刷新，每隔一段时间必须刷新。通常为2ms</p><ul><li>集中刷新：读写操作不受影响，但刷新时不能访问存储器（死区）</li><li>分散刷新：只刷新一部分，另一部分正常。但会增加存取周期</li><li>异步刷新：刷新周期/行数的时间间隔产生刷新请求<ol><li>对CPU透明，不依赖于外部访问</li><li>刷新安排在译码阶段，不会增加存取周期也不会产生死区</li><li>刷新的单位是按行，刷新时只需要行地址</li><li>刷新时不需要选片，同时刷新。</li></ol></li></ul></li></ol><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><p>非易失性存储器</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="2021/05/01/composition_principle/%E6%80%BB%E7%BA%BF/"/>
      <url>2021/05/01/composition_principle/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>分时</li><li>共享</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><p>片内总线</p><p>用于CPU芯片内部寄存器与寄存器之间</p></li><li><p>系统总线</p><ol><li>数据总线，双向传输总线，位数与机器字长、存储字长有关</li><li>地址总线，单向创术总线，位数与主存地址空间的大小有关</li><li>控制总线</li></ol></li><li><p>通信总线</p><p>用于计算机系统之间或计算机系统与其他系统之间</p></li></ol><h3 id="系统总线结构"><a href="#系统总线结构" class="headerlink" title="系统总线结构"></a>系统总线结构</h3><ol><li><p>单总线结构</p></li><li><p>双总线结构</p><p>分主存总线和I/O总线</p></li><li><p>三总线结构</p><p>分主存总线、I/O总线和DMA总线</p></li></ol><h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h3><ol><li><p>集中仲裁方式</p><ol><li><p>链式查询</p><p>n个设备，1条BR（总线请求线），1条BS（总线忙），1条BG（总线允许）</p></li><li><p>计数器定时查询</p><p>n个设备，1条BR（总线请求线），1条BS（总线忙），logn条BG（总线允许）</p></li><li><p>独立请求方式</p><p>n个设备，n条BR（总线请求线），1条BS（总线忙），n条BG（总线允许）</p></li></ol></li><li><p>分布式仲裁</p><p>每个模块都有自己仲裁号和仲裁器，按照仲裁号的优先级响应</p></li></ol><h3 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h3><h4 id="仲裁周期"><a href="#仲裁周期" class="headerlink" title="仲裁周期"></a>仲裁周期</h4><ol><li>申请分配阶段：主设备想总线提出申请</li><li>寻址阶段：通过总线发出本次要访问的从模块地址及有关命令</li><li>传输阶段：主模块和从模块进行数据交换</li><li>结束阶段：主模块的有关信息撤除，让出总线使用权</li></ol><h4 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h4><p>采用统一的时钟信号来协调发送和接收双方的传输定时关系</p><h4 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h4><ol><li>不互锁</li><li>半互锁</li><li>全互锁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令格式</title>
      <link href="2021/05/01/composition_principle/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/composition_principle/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>包括操作码和地址码</p><ol><li>定长操作码格式</li><li>扩展操作码格式</li></ol><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h4 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h4><ol><li>顺序寻址</li><li>跳跃寻址</li></ol><h4 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h4><ol><li><p>隐含寻址</p></li><li><p>立即数数据寻址</p></li><li><p>直接寻址：EA = A</p></li><li><p>间接寻址 ：EA = （A）</p></li><li><p>寄存器寻址：EA = R</p></li><li><p>寄存器间接寻址： EA = (R)</p></li><li><p>相对寻址：EA = (PC) + A</p></li><li><p>基址寻址：EA = (BR) + C     </p></li><li><p>变址寻址：EA = (IX) + A</p></li><li><p>堆栈寻址：</p><p>EA为真是地址，PC为程序计数器，BR为基址寄存器。IX为变址寄存器</p></li></ol><h4 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h4><p>CSCi：指令数目多，字长不固定，寻址方式多，寄存器数量少。一般为微程序控制</p><p>RISC：指令数目少，字长固定，寻址方式少，寄存器数量多，一般为组合逻辑控制</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示和运算</title>
      <link href="2021/05/01/composition_principle/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
      <url>2021/05/01/composition_principle/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>常用的进制</p><ol><li>二进制</li><li>八进制</li><li>十进制</li><li>十六进制</li></ol><p>每种进制的转换</p><p>常见的BCD码</p><ol><li><p>8421码</p><p>8421码相加大于1001时，需要加0110进行修正</p></li><li><p>余3码</p></li><li><p>2421码</p></li></ol><p>校验码</p><p>原理：通过增加一些冗余码来校验或纠错</p><ol><li>奇偶校验</li><li>海明码</li><li>循环冗余码</li></ol><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><ol><li><p>ASCII码</p></li><li><p>汉字编码</p><p>国标码、区位码和汉字内码。</p><p>转换关系：国标码 = 区位码 + 202H， 汉字内码 = 国标码 + 8080H</p></li></ol><p>字符串的存放方式</p><ol><li><p>小端模式</p><p>先存储低位，后存储高位。</p></li><li><p>大端模式</p><p>先存储高位，后存储低位。</p></li></ol><h4 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h4><ol><li>原码</li><li>补码</li><li>反码</li><li>移码：只能表示整数</li></ol><p>溢出判别方法：</p><ol><li><p>一位符号法</p></li><li><p>双符号位法</p><p>00 正数无溢出 01 正溢出 10 负溢出 11 负数无溢出</p></li></ol><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><p> 数符、阶码、尾数</p><p>IEEE754标准。IEEE754尾数是用补码编码的。</p><p>加减步骤</p><ol><li>对阶：小阶向大阶看齐</li><li>尾数求和</li><li>规格化<ul><li>尾数是原码编码的规格化数的尾数第一位为1</li><li>尾数是补码规格化数的符号位和尾数最高位相反</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU 流水线</title>
      <link href="2021/05/01/composition_principle/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>2021/05/01/composition_principle/%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h3><ol><li><p>结构相关</p><p>解决方法：</p><ol><li>前一指令访存时，使后一条相关指令暂停一个周期</li><li>单独设置数据存储器和指令存储器，使两项操作在不同存储器中运行</li></ol></li><li><p>数据相关</p><p>解决方法：</p><ol><li>把数据相关的指令及后续指令都暂停一到几个时钟周期，直到数据相关解决才继续执行</li><li>设置专用的数据通道，即数据旁路技术</li><li>通过编辑以对指令进行优化</li></ol></li><li><p>控制相关</p><p>解决方法：</p><ol><li>对转移指令进行预测，尽早生成目标转移地址</li><li>对转移指令的分支进行预测</li><li>加快和提前形成条件码</li><li>提高转移方向的猜测率</li></ol></li></ol><h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><ol><li><p>流水线的吞吐率</p><p>单位时间内流水线完成任务的数量</p></li><li><p>流水线的加速比</p><p>完成同一批任务，不使用流水线和使用流水线的时间比值</p></li><li><p>流水线的效率</p><p>流水线设备的利用率</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控项目</title>
      <link href="2021/05/01/monitor/Zabbix/"/>
      <url>2021/05/01/monitor/Zabbix/</url>
      
        <content type="html"><![CDATA[<h1 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h1><h1 id="Zabbix连接方式"><a href="#Zabbix连接方式" class="headerlink" title="Zabbix连接方式"></a>Zabbix连接方式</h1><p>Zabbix-Server 和 Zabbix-Proxy可以通过VPN，SSH,Stunnel连接</p><h2 id="Zabbix监控配置流程"><a href="#Zabbix监控配置流程" class="headerlink" title="Zabbix监控配置流程"></a>Zabbix监控配置流程</h2><p>Host Group(主机组) —&gt; Hosts(主机) —-&gt; Applications(监控项组) —-&gt; Items(监控项) —–&gt; Triggers(触发器) —-&gt; Event(事件) —-&gt; Actions(处理动作) —-&gt; User Groups(用户组) —-&gt; Users(用户) —-&gt;Medias(告警方式) —-&gt; Audit(日志审计)</p><p><img src="/images/zabbix%E8%AD%A6%E5%91%8A%E6%B5%81%E7%A8%8B.png" alt="zabbix警告流程"></p><p>Items:采集数据<br>Trigger：对采集的数据进行阈值判断，触发阈值，产生事件<br>Action：Action对达到阈值的Trigger触发警告</p><p>每一个Trigger必须对应一个Item，但是一个Item可以对应多个Trigger</p><h2 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h2><h3 id="Agent监控方式"><a href="#Agent监控方式" class="headerlink" title="Agent监控方式"></a>Agent监控方式</h3><h3 id="Trapper-监控方式"><a href="#Trapper-监控方式" class="headerlink" title="Trapper 监控方式"></a>Trapper 监控方式</h3><p>Trapper-Server，采用主动推送的方式。Trapper不需要安装客户端，Key的名称可以灵活定义。<br>再Trapper工作模式中，Zabbix数据发送的程序时zabbix-sender。</p><h3 id="SNMP监控方式"><a href="#SNMP监控方式" class="headerlink" title="SNMP监控方式"></a>SNMP监控方式</h3><p><strong>用于监控路由器、交换机、打印机、UPS或者其他开始SNMP的设备</strong><br>SNMP(Simple Network Managment Protocol) 简单网络管理协议包含两个部分：管理进程和被管理设备。SNMP 使用的时UDP协议，采用161端口发送报文，<br>管理端和被管理端的通信方式</p><ul><li>被管理端向管理端发送数据</li><li>管理端向被管理端请求获取数据</li><li>管理端向被管理端请求改变数据</li></ul><p>SNMP网络管理框架是工业上的现行标准，由3个主要部分组成，分别是管理信息结构SMI（Structure ofManagement Information）、管理信息库MIB和管理协议SNMP。<br>SNMP是管理进程（NMS）和代理进程（Agent）之间的通信协议</p><h3 id="IPMI-监控方式"><a href="#IPMI-监控方式" class="headerlink" title="IPMI 监控方式"></a>IPMI 监控方式</h3><p>IPMI(Intelligent Platform Managerment Interface)，即智能平台管理接口，用于监控服务器的物理特性，如温度、电压、电扇工作状态、电源供应和机箱入侵等。</p><p>IPMI独立于CPU BIOS和OS外自行运行，能再缺少操作系统、系统管理软件或者系统关机但有电源的情况下远端管理服务器硬件。</p><h3 id="JMX监控方式"><a href="#JMX监控方式" class="headerlink" title="JMX监控方式"></a>JMX监控方式</h3><p>JMX(Java Manager Extensions) Java扩展管理是Java平台为应用程序、设备、系统植入管理功能的架构。</p><p>JMX监控数据的获取由专门的代理程序Zabbix-Java-Gateway来负责采集。Zabbix-Java-Gateway 和JMX的Java程序通信获取数据。</p><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><h4 id="网络发现"><a href="#网络发现" class="headerlink" title="网络发现"></a>网络发现</h4><p>完成的工作：</p><ul><li>快速发现并添加主机</li><li>简单的管理</li><li>随着环境的改变而快速搭建监控系统</li></ul><p>网络发现基于的信息：</p><ul><li>IP地址段</li><li>基于服务的FTP、SSH、Web、POP3、IMAP、TCP等</li><li>从Zabbix-Agent接收到信息</li><li>从SNMP agent接收到信息<h4 id="主动方式的自动注册"><a href="#主动方式的自动注册" class="headerlink" title="主动方式的自动注册"></a>主动方式的自动注册</h4>Active Agent Auto-Registeration(主动注册功能)主要用于Agent主动且自动的向Server注册</li></ul><h4 id="Low-level-discovery"><a href="#Low-level-discovery" class="headerlink" title="Low level discovery"></a>Low level discovery</h4><p>Low level discovery可以对网卡、文件系统、SNMP OIDS进行自动发现。</p><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>数据断层原因</p><ul><li>系统负载高</li><li>TCP连接数过多</li><li>网络问题</li><li>无法获取到数据</li><li>数据库无法存储数据</li></ul><p><a href="https://blog.csdn.net/weixin_43831670/article/details/90050861">https://blog.csdn.net/weixin_43831670/article/details/90050861</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控系统</title>
      <link href="2021/05/01/monitor/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/monitor/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h1><h2 id="监控系统的实现"><a href="#监控系统的实现" class="headerlink" title="监控系统的实现"></a>监控系统的实现</h2><p>监控系统大体分为两个部分：数据采集端（客户端）和数据存储分析警告展示部分（服务器端）<br>数据采集的工作模式分为主动模式（客户端主动上报数据到服务器端）和被动模式（服务器到客户端收集数据）<br>采集数据的协议分为两种：专用客户端采集协议和公用协议采集(SNMP,SSH,Telnet)</p><h2 id="监控系统的架构"><a href="#监控系统的架构" class="headerlink" title="监控系统的架构"></a>监控系统的架构</h2><ul><li>C/S：适用于监控节点不多，产生数据少，规模较小，处于同一地域</li><li>C/P/S：(Client/Proxy/Server)：适用于被监控节点多，监控类型多</li></ul><h2 id="Web监控原理"><a href="#Web监控原理" class="headerlink" title="Web监控原理"></a>Web监控原理</h2><p>Web监控即对HTTP服务的监控，模拟用户去访问网站，对特定的结果进行比较，如返回状态码，字符串等特定数据进行比较和监控，从而判断网站Web的可用性。</p><h3 id="SNMP监控方式"><a href="#SNMP监控方式" class="headerlink" title="SNMP监控方式"></a>SNMP监控方式</h3><p>使用理由：由于某些设备不能安装Agent或者安装Agent不方便</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控项目</title>
      <link href="2021/05/01/monitor/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/"/>
      <url>2021/05/01/monitor/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="监控项目"><a href="#监控项目" class="headerlink" title="监控项目"></a>监控项目</h3><h4 id="CPU采集项"><a href="#CPU采集项" class="headerlink" title="CPU采集项"></a>CPU采集项</h4><ul><li>cpu.idle：一个或多个CPU空闲且系统没有未完成的磁盘I / O请求的时间百分比。</li><li>cpu.busy：与cpu.idle相对，他的值等于100个cpu.idle。</li><li>cpu.guest：一个或多个CPU运行虚拟处理器所花费的时间百分比。</li><li>cpu.iowait：在系统有未完成的磁盘I / O请求期间，一个或多个CPU空闲的时间百分比。</li><li>cpu.irq：一个或多个CPU服务硬件中断所花费的时间百分比。</li><li>cpu.softirq：CPU花费在服务软件中断上的时间百分比。</li><li>cpu.nice：在具有优先级的用户级别执行时发生的CPU利用率百分比。</li><li>cpu.steal：虚拟机管理程序为另一个虚拟处理器提供服务时，一个或多个虚拟CPU非自愿等待所花费的时间百分比。</li><li>cpu.system：在系统级别（内核）执行时发生的CPU利用率百分比。</li><li>cpu.user：在用户级别（应用程序）执行时发生的CPU利用率百分比。</li><li>cpu.cnt：cpu核数。</li><li>cpu.switches：cpu切换次数，计数器类型。</li></ul><p>ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33293033">理解CPU Steal Time</a></li><li><a href="https://segmentfault.com/a/1190000018471760">cpu分析</a></li></ul><h4 id="磁盘采集项"><a href="#磁盘采集项" class="headerlink" title="磁盘采集项"></a>磁盘采集项</h4><ul><li><p>df.bytes.free：磁盘可用量，int64</p></li><li><p>df.bytes.free.percent：磁盘可用量占总量的百分比，float64，比如32.1</p></li><li><p>df.bytes.total：磁盘总大小，int64</p></li><li><p>df.bytes.used：磁盘已用大小，int64</p></li><li><p>df.bytes.used.percent：磁盘已用大小占总量的百分比，float64</p></li><li><p>df.inodes.total：inode总数，int64</p></li><li><p>df.inodes.free：可用inode数目，int64</p></li><li><p>df.inodes.free.percent：可用inode占比，float64</p></li><li><p>df.inodes.used：已用的inode数据，int64</p></li><li><p>df.inodes.used.percent：已用inode占比，float64</p></li><li><p><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html">理解inode</a></p></li><li><p><a href="https://segmentfault.com/a/1190000018499770">IO分析</a></p></li></ul><h4 id="内存采集项"><a href="#内存采集项" class="headerlink" title="内存采集项"></a>内存采集项</h4><ul><li><p>mem.memtotal：内存总大小</p></li><li><p>mem.memused：使用了多少内存</p></li><li><p>mem.memused.percent：使用的内存占比</p></li><li><p>mem.memfree</p></li><li><p>mem.memfree.percent</p></li><li><p>mem.swaptotal：swap总大小</p></li><li><p>mem.swapused：使用了多少swap</p></li><li><p>mem.swapused.percent：使用的swap的占比</p></li><li><p>mem.swapfree</p></li><li><p>mem.swapfree.percent</p></li><li><p><a href="https://segmentfault.com/a/1190000018553950">内存分析</a></p></li></ul><ul><li><a href="https://rdc.hundsun.com/portal/article/731.html">性能分析工具集</a></li></ul><h4 id="Web监控指标"><a href="#Web监控指标" class="headerlink" title="Web监控指标"></a>Web监控指标</h4><p><img src="/images/web%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87.png" alt="web监控指标"></p><h4 id="常见性能采集指标"><a href="#常见性能采集指标" class="headerlink" title="常见性能采集指标"></a>常见性能采集指标</h4><p><img src="/images/%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%87%87%E9%9B%86%E6%8C%87%E6%A0%87.png" alt="常见性能采集指标"></p><h4 id="监控文章"><a href="#监控文章" class="headerlink" title="监控文章"></a>监控文章</h4><p><a href="https://www.datadoghq.com/blog/monitoring-101-collecting-data/#metrics">monitoring</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="2021/05/01/network/CDN%E5%8A%A0%E9%80%9F/"/>
      <url>2021/05/01/network/CDN%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="CDN-Content-Delivery-Network"><a href="#CDN-Content-Delivery-Network" class="headerlink" title="CDN(Content Delivery Network)"></a>CDN(Content Delivery Network)</h3><ul><li>目的：内容分发网络通过在现有的Internet中添加一层新的缓存，将网站的内容发布到最接近用户的网络边缘节点，时用户能够就近地获取到内容，提高用户访问网站的响应速度。解决由于网络宽带小、用户访问量大、网点分布不均匀等问题。</li></ul><h4 id="优化作用的体现："><a href="#优化作用的体现：" class="headerlink" title="优化作用的体现："></a>优化作用的体现：</h4><ul><li>解决服务器端的“第一公里“的问题</li><li>缓解甚至消除不同运营商之间互联的瓶颈造成的影响</li><li>减轻各省的出口宽带压力</li><li>缓解骨干网的压力</li><li>优化网上热点内容分布</li></ul><h4 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h4><p>传统过程</p><p><img src="..%5Cimage%5CCDN%E4%BC%A0%E7%BB%9F%E8%BF%87%E7%A8%8B.png" alt="传统过程"></p><p>加速过程</p><p><img src="..%5Cimage%5CCDN%E5%8A%A0%E9%80%9F%E8%BF%87%E7%A8%8B.png" alt="传统过程"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/1dae6e1680ff">https://www.jianshu.com/p/1dae6e1680ff</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP和PXE</title>
      <link href="2021/05/01/network/DHCP%E5%92%8CPXE/"/>
      <url>2021/05/01/network/DHCP%E5%92%8CPXE/</url>
      
        <content type="html"><![CDATA[<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><h2 id="DHCP-简介"><a href="#DHCP-简介" class="headerlink" title="DHCP 简介"></a>DHCP 简介</h2><p>动态主机配置协议（Dynamic Host Configuration Protocol），简称DHCP</p><h3 id="DHCP优点"><a href="#DHCP优点" class="headerlink" title="DHCP优点"></a>DHCP优点</h3><ol><li>网络管理员可以验证IP地址和其它配置参数，而不用去检查每个主机</li><li>DHCP不会同时租借相同的IP地址给两台主机</li><li>DHCP管理员可以约束特定的计算机使用特定的IP地址</li><li>可以为每个DHCP作用域设置很多选项</li><li>客户机在不同子网间移动时不需要重新设置IP地址</li></ol><h3 id="DHCP缺点"><a href="#DHCP缺点" class="headerlink" title="DHCP缺点"></a>DHCP缺点</h3><ol><li>DHCP不能发现网络上非DHCP客户机已经在使用的IP地址</li><li>当网络上存在多个DHCP服务器时，一个DHCP服务器不能查出已被其它服务器租出去的IP地址</li><li>DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发<br>（BOOTP全称Bootstrap Protocol，引导程序协议，基于IP/UDP协议，是DHCP的前身，用于无盘工作站的局域网中，可以让无盘工作站从一个中心服务器上获得IP地址）</li></ol><h2 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h2><ol><li>DHCP Discover：新来的机器（DHCP客户机）使用IP地址0.0.0.0发送了一个DHCP discover的广播包，用于寻找DHCP服务器。广播包封装了UDP，UDP封装了BOOTP，目的IP地址为255.255.255.255。网络上每一台安装了TCP/IP协议的主机都会接收到这种广播信息，但只有DHCP服务器才会做出响应。</li><li>DHCP Offer：DHCP服务器收到DHCP discover后，挑选尚未出租的IP地址分配给DHCP客户机。同时，DHCP Server为此客户保留为它提供的IP地址，从而不会为其他DHCP客户分配此IP地址。DHCP Server仍然使用广播地址作为目的地址。此时请求分配IP的新人还没有自己的IP。除此之外，服务器还发送了子网掩码、网关和IP地址租用期等信息。</li><li>DHCP Request：DHCP客户机选择其中一个DHCP offer（可能有多台服务器DHCP服务器响应）,并且会向网络发送一个DHCP Request广播数据包，包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等，并告诉所有DHCP Server它将接受哪一台服务器提供的IP地址.</li><li>Acknowledge：当DHCP Server接收到客户机的DHCP request之后，会广播返回给客户机一个DHCP ACK消息包，表明已经接受客户机的选择，并将这一IP地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机。然后DHCP客户机便将其TCP/IP协议与网卡绑定。同时其他的DHCP服务器都将收回曾提供的IP地址。<br><img src="/images/DHCP%E8%BF%87%E7%A8%8B.png" alt="DHCP过程"></li><li>重新登录：DHCP客户端每次重新登录网络时，就不需要再发送DHCP discover，而是直接发送包含前一次所分配的IP地址的DHCP request请求信息。当DHCP服务器收到这一信息后，它会尝试让DHCP客户机继续使用原来的IP地址，并回答一个DHCP ack确认信息。如果此IP地址已无法再分配给原来的DHCP客户机使用时，则DHCP服务器给DHCP客户机回答一个DHCP nack否认信息。当原来的DHCP客户机收到此DHCP nack否认信息后，它就必须重新发送DHCP discover发现信息来请求新的IP地址。</li><li>更新租约：客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP Server发送DHCP request消息包。客户机接收到该服务器回应的DHCP ACK消息包，会根据包中所提供的新的租期以及其他已经更新的TCP/IP参数，更新自己的配置。这样，IP租用更新就完成了</li></ol><h2 id="DHCP应用：PXE"><a href="#DHCP应用：PXE" class="headerlink" title="DHCP应用：PXE"></a>DHCP应用：PXE</h2><p>PXE(Pre-boot Execution Environment,预启动执行环境)</p><p>PXE协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在BIOS里面。当计算机启动时，BIOS把PXE客户端调入内存里面，就可以连接到服务端做一些操作了</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>第一步是通过DHCP协议向DHCP Server便租给它一个IP地址，同时也给它PXE服务器的地址、启动文件pxelinux.0。</li><li>PXE客户端知道要去PXE服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是TFTP协议。所以PXE服务器上，往往还需要有一个TFTP服务器</li><li>PXE客户端收到这个文件后，就开始执行这个文件。这个文件会指示PXE客户端，向TFTP服务器请求计算机的配置信息pxelinux.cfg。TFTP服务器会给PXE客户端一个配置文件，里面会说内核在哪里、initramfs在哪里。PXE客户端会请求这些文件。</li><li>启动Linux内核<br><img src="/images/PXE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="PXE启动流程"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中继系统</title>
      <link href="2021/05/01/network/%E4%B8%AD%E7%BB%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/network/%E4%B8%AD%E7%BB%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>中继系统</p><ul><li>物理层：中继器,集线器</li><li>数据链路层：网桥或交换机</li><li>网络层：路由器</li><li>网络层以上：网关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="2021/05/01/safety/CSRF(%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/"/>
      <url>2021/05/01/safety/CSRF(%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/</url>
      
        <content type="html"><![CDATA[<h3 id="CSRF-简介"><a href="#CSRF-简介" class="headerlink" title="CSRF 简介"></a>CSRF 简介</h3><p>Cross Site RequestForgery(跨站点请求伪造)，简称CSRF。<br>攻击成功的原因，重要操作的所有参数都可以被攻击者猜测到，只有预测出URL和所有参数和参数值，才能构造一个伪造的请求</p><p>浏览器的cookie策略</p><ul><li>Session Cookie (临时的cookie)</li><li>Third-party Cookie (本地Cookie)<br>区别在于Third-party Cookie是服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效。而Session Cookie没有指定时间，关闭浏览器，就失效了</li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>CSRF往往是用户不知情的情况下构造了网络请求，而验证码可以强制用户必须和应用进行交互，才能完成请求</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h5><p>用户检查请求是否来自于合法的“源”，通过页面与压面之间的逻辑关系，检查referer时候合法来判断用户是否被CSRF攻击<br>而缺点在于，服务器并非什么时候都能去到Referer，很多用户出于隐私的保护，也限制了Referer的发送。</p><h5 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h5><p>在URL添加一个token参数，token参数是随机的，不可以预测的。<br>而Token通常可以放在用户的session中，或者浏览器的Cookie中。<br>在使用时，需要注意</p><ul><li>生成的Token一定要足够随机</li><li>Token应该保存在Cookie中，而不是服务器端的Session中。可以考虑生成多个有效的Token，解决页面共存的场景</li><li>使用Token应该注意Token的保密性，使用时应该把Token放在表单中，将敏感操作由Get改为Post，以form表单或者AJAX的形式提交，避免Token泄露</li><li>预防XSS或者一些跨域漏洞，让攻击者窃取Token的值</li><li>XSS带来的问题。应该使用XSS防御方案解决，否则CSRF的Token防御就是空中楼阁。CSRF和XSS组合可以称为XSRF</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劫持</title>
      <link href="2021/05/01/safety/ClickJacking(%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81)/"/>
      <url>2021/05/01/safety/ClickJacking(%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81)/</url>
      
        <content type="html"><![CDATA[<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>ClickJacking(点击劫持)是一种是觉得欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，用户将在不知情的情况下点击透明的iframe页面。</p><p>与CSRF一样，都是在用户不知情的情况下诱使用户完成一些动作，不同的是，点击劫持利用的是与用户交互产生的页面</p><p>例子：</p><ul><li>图片覆盖攻击</li><li>拖拽劫持</li><li>触屏劫持</li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><h5 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h5><p>即禁止iframe嵌套，</p><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p>在HTTP头中添加X-Frame-Options<br>X-Frame-Options 有三个值可选</p><ul><li>DENY：浏览器会拒绝当前页面加载任何frame页面</li><li>SAMEORIGIN：则frame页面的地址只能为同源域名下的页面</li><li>AL-LOW-FROM: 允许frame加载的页面地址</li></ul><p>Firefox的“Content Security Police”以及No-Script扩展也能够有效防御ClickJacking</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDos</title>
      <link href="2021/05/01/safety/DDos/"/>
      <url>2021/05/01/safety/DDos/</url>
      
        <content type="html"><![CDATA[<h1 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DDOS攻击指分布式拒绝服务攻击，即处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。</p><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><ol><li>消耗带宽资源：通过大量请求消耗正常的带宽和协议栈处理资源的能力，从而达到服务端无法正常工作。</li><li>耗尽服务器资源：服务器的连接数、cpu数量、提供域名解析的DNS服务器,都属于资源。通过占用服务器的资源，使服务器无法对外提供服务。</li></ol><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>了解攻击目标：包括不局限于被攻击目标的主机数，地址情况，配置，宽带性能等指标。</li><li>攻占傀儡机(肉鸡)：尽量控制多的傀儡机，安装攻击程序。</li><li>实施攻击：通过主控机向傀儡机发送攻击指令，实施攻击</li></ol><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="1-攻击网络宽带资源"><a href="#1-攻击网络宽带资源" class="headerlink" title="1. 攻击网络宽带资源"></a>1. 攻击网络宽带资源</h3><ol><li>直接攻击<ol><li><strong>ICMP/UDP洪水攻击</strong>：攻击者使用受控主机向被攻击目标发送大量的ICMP/IGMP报文，进行洪水攻击以消耗目标的宽带资源</li><li><strong>UDP洪水攻击</strong>：<ol><li>小包攻击：小包是指64字节大小的数据包，这是以太网上传输数据帧的最小值，在相同流量下，单包体积越小，数据包的数量就越多。由于交换机、路由器等网络设备需要对没一个数据包进行检查和校验，因此<strong>使用UDP小包攻击能够最有效的增大网络设备处理数据包的压力</strong>，造成处理速度的缓慢和传输延迟等拒绝服务攻击的效果。</li><li>大包攻击：大包是指1500字节以上的数据包，其大小超过了以太网的最大传输单元，<strong>使用UDP大包攻击，能够有效的占用网络接口的传输宽带，并迫使被攻击目标在接受到UDP数据时进行分片重组，造成网络拥堵</strong>，服务器响应速度变慢。</li></ol></li></ol></li><li>发射和放大攻击(利用服务器或者路由器多个地方call目标服务器)<ul><li>发射攻击又被称为DRDoS（分布式反射拒绝服务）攻击，是指<strong>利用路由器、服务器等设施对请求产生应答，从而反射攻击流量并隐藏攻击来源的一种分布式拒绝服务攻击技术</strong>。</li><li>放大攻击是一种特殊的反射攻击，<strong>其特殊之处在于反射器对于网络流量具有放大作用</strong>，因此我们也可以将这种反射器成为放大器，进行放大攻击的方式与反射攻击的方式也是基本一致的</li></ul><ol><li><strong>ACK反射攻击</strong>：攻击者利用TCP握手的ACK应答，将SYN的源IP地址伪造成被攻击目标的IP地址，服务器的应答也就会直接发送给被攻击目标。由于使用TCP协议的服务在互联网上广泛存在，<strong>攻击者可以通过受控主机向大量不同的服务器发送伪造源IP地址的SYN请求，从而使服务器响应的大量ACK应答数据涌向被攻击目标</strong>，占用目标的网络宽带资源并拒绝服务。</li><li><strong>DNS放大攻击</strong>：与ACK反射攻击类似，发动DNS放大攻击也需要先进行扫描，以获得大量的开放DNS解析器的地址，并向这些开放DNS解析器发送伪造源地址的查询命令来放大攻击流量</li><li><strong>NTP放大攻击</strong>：NTP(网络时间协议)是用来使计算器时间同步化的一种协议，他可以使计算机与时钟源进行同步化并提供高精准度的时间校正。<strong>与ACK反射攻击和DNS放大攻击类似</strong>，发动NTP放大攻击也需要先进行网络扫描，以获取大量的NTP服务器，并向这些NTP服务器发送伪造源地址的请求来放大攻击流量，<strong>相比于DNS放大攻击，NTP放大攻击的放大倍数更大</strong>，因此其危害也更加严重</li><li><strong>SNMP放大攻击</strong>:SNMP(简单网络管理协议)是目前网络中应用最为广泛的网络管理协议，他提供了一个管理框架来监控和维护互联网的设备.利用SNMP协议中的默认通信字符串和GetBulk请求.<strong>getbulk请求数据包约为60字节，而请求的响应数据能够达到1500字节以上</strong>。攻击者向广泛存在并开启了SNMP服务的网络设备发送getbulk请求，使用默认通信字符串作为认证凭据，并将源IP地址伪造成攻击目标的IP地址，<strong>设备收到getbulk请求后，会将响应结果发送给攻击目标，当大量的响应结果涌向攻击目标时，就会导致攻击目标网络拥堵和缓慢</strong>，造成拒绝服务攻击。</li></ol></li><li><strong>攻击链路</strong>：攻击者通过traceroute等手段来判断各个僵尸主机和将要攻击的链路之间的位置关系，并根据结果将僵尸主机分为两个部分，然后，<strong>攻击者控制僵尸主机，使其与链路另一侧的每一台僵尸主机进行通信并收发大量数据</strong>，这样，大量的网络数据包就会经过骨干网上的被攻占链路，造成网络拥堵和延时。<h3 id="2-攻击系统资源"><a href="#2-攻击系统资源" class="headerlink" title="2. 攻击系统资源"></a>2. 攻击系统资源</h3></li><li>攻击TCP连接（耗尽TCP连接表，使缓冲区不断清空，强制断开TCP）<ol><li><strong>TCP连接洪水攻击</strong>：在三次握手进行的过程中,服务器会创建并保存TCP连接的信息，这个信息通常被保存在连接表结构中，但是，连接表的大小是有限的，一旦服务器接收到的连接数量超过了连接表能存储的数量，<strong>服务器就无法创建新的TCP连接了</strong></li><li><strong>SYN洪水攻击</strong>: 攻击者利用受控主机发送大量的TCP SYN报文，<strong>使服务器打开大量的半开连接，占满服务器的连接表</strong>，从而影响正常用户与服务器建立会话，造成拒绝服务</li><li><strong>PSH+ACK洪水攻击</strong>:在TCP数据传输的过程中，<strong>PSH标志位来表示当前数据传输结束</strong>。<strong>由于带有PSH标志位的TCP数据包会强制要求接收端将接收缓冲区清空并将数据提交给应用服务进行处理</strong>，因此当攻击者利用受控主机向攻击目标发送大量的PSH+ACK数据包时，<strong>被攻击目标就会消耗大量的系统资源不断地进行接收缓冲区的清空处理</strong>，导致无法正常处理数据，从而造成拒绝服务。</li><li><strong>RST洪水攻击</strong>：<strong>无法正常完成TCP四次握手以终止连接时，就会使用RST报文将连接强制中断</strong>攻击者设法获取客户端的IP地址和端口号，而服务端的IP地址和端口号是已知的。攻击者可以利用RST报文<strong>发送伪造的带有RST标志位的TCP报文，强制中断客户端与服务端的TCP连接</strong>。</li><li><strong>Sockstress攻击(慢速)<strong>：Sockstress攻击首先会完成建立TCP连接后，攻击者将其TCP窗口大小设置为0。攻击目标在传输数据时，发现接收端的TCP窗口大小为0，就会停止传输数据，并发出TCP窗口探测包，询问攻击者其TCP窗口是否有更新，由于攻击者没有更改TCP窗口的大小，被攻击目标就会一直维持TCP连接等待数据发送，并不断进行窗口更新的探测。大量的受控主机进行Sockstress攻击，</strong>被攻击目标会一直维持大量的TCP连接并进行大量窗口更新探测，其TCP连接表会逐渐耗尽，无法连接新的连接而导致拒绝服务</strong>。</li></ol></li><li>攻击SSL连接（利用SSL解密验证消耗性能）<ol><li><strong>THC SSL DOS攻击</strong>：这样的SSL握手过程只需要进行一次即可，但是在SSL协议中有一个Renegotiation选项，通过它可以进行秘钥的重新协商以建立新的秘钥。就是利用Renegotiation选项，造成被攻击目标资源耗尽，在进行SSL连接并握手之后，攻击者反复不断的进行秘钥重新协商过程，<strong>而秘钥重新协商过程需要服务器投入比客户端多15倍的CPU计算资源，攻击者只需要一台普通的台式机就能拖慢一台高性能服务器</strong>，而如果有大量主机同时进行攻击，则会使服务器忙于协商秘钥而完全停止响应</li><li><strong>SSL洪水攻击</strong>：在SSL握手的过程中，服务器会消耗较多的CPU计算资源进行加解密，并进行数据的有效性检验，对于客户端发过来的数据，服务器需要先花费大量的计算资源进行解密，之后才能对数据的有效性进行检验，重要的是，<strong>不论数据是否是有效的，服务器都必须先进行解密才能够做检查，攻击者可以利用这个特性进行SSL洪水攻击</strong>。攻击者并不需要完成SSL握手和秘钥交换，而只需要在这个过程中让服务器去解密和验证，就能够大量的消耗服务器的计算资源<h3 id="3-攻击应用资源"><a href="#3-攻击应用资源" class="headerlink" title="3. 攻击应用资源"></a>3. 攻击应用资源</h3></li></ol></li><li>攻击DNS服务<ol><li> DNS QUERY洪水攻击</li><li> DNS NXDOMAIN洪水攻击</li></ol></li><li>攻击web服务<ol><li> HTTP洪水攻击</li><li> Slowloris攻击（慢速）</li><li> 慢速POST请求攻击</li><li> 数据处理过程攻击</li></ol></li></ol><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><h3 id="硬抗"><a href="#硬抗" class="headerlink" title="硬抗"></a>硬抗</h3><h3 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h3><p>流量清洗是通过业务流量进行实时监测，精准识别其中的异常攻击流量，在不影响正常业务的前提下，清洗掉异常流量，实现服务器的流量限流，减轻攻击流量对服务器造成的损害，保证服务正常可用</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.maixj.net/ict/ddos-13728?replytocom=21393">https://www.maixj.net/ict/ddos-13728?replytocom=21393</a><br>常见攻击方式：<a href="https://zhuanlan.zhihu.com/p/30635804">https://zhuanlan.zhihu.com/p/30635804</a><br>流量清洗原理：<a href="https://dun.163.com/news/p/4e52c024c7c94220b3f7201498a388c6">https://dun.163.com/news/p/4e52c024c7c94220b3f7201498a388c6</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 安全</title>
      <link href="2021/05/01/safety/HTML5%E5%AE%89%E5%85%A8/"/>
      <url>2021/05/01/safety/HTML5%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="HTML5-安全"><a href="#HTML5-安全" class="headerlink" title="HTML5 安全"></a>HTML5 安全</h3><h4 id="新的标签"><a href="#新的标签" class="headerlink" title="新的标签"></a>新的标签</h4><p>HTML5 定义了很多先标签和新事件，可能会带来新的XSS攻击。如果建立一个黑名单的话，则可能不会覆盖到HTML5新增的标签和功能，从而发生XSS</p><h5 id="iframe-的sandbox"><a href="#iframe-的sandbox" class="headerlink" title="iframe 的sandbox"></a>iframe 的sandbox</h5><p>HTML5专门为iframe定义新的属性，叫sandbox。使用这一个属性，iframe标签加载的内容将会被视为一个独立的源，其中的脚本被静置执行，表单被禁止提交，插件被禁止加载，指向其他浏览器对象的链接也被禁止</p><ul><li>allow-same-origin：允许同源访问</li><li>allow-top-navigation:允许访问顶层窗口</li><li>allow-forms：允许提交表单</li><li>allow-scripts:允许执行脚本</li></ul><h5 id="Link-Types-noreference"><a href="#Link-Types-noreference" class="headerlink" title="Link Types:noreference"></a>Link Types:noreference</h5><p>为&lt;a&gt;和&lt;area&gt;标签定义一个新的LinkTypes:noreference<br>标签指定noreference后，浏览器在请求该标签指定的地址时将不在发送Referer。<br>这是出于保护敏感信息和隐私考虑。因为通过Refer，可能会泄露一些敏感信息</p><h5 id="Canvas-破解验证码"><a href="#Canvas-破解验证码" class="headerlink" title="Canvas 破解验证码"></a>Canvas 破解验证码</h5><p>可以通过JavaScript操作Canvas中的每个像素点，成功自动化识别验证码</p><h5 id="Origin-Header"><a href="#Origin-Header" class="headerlink" title="Origin Header"></a>Origin Header</h5><p>Origin Header 用户标记HTTP发起的源，服务器通过识别浏览器自动带上的这个OriginHeader，来判断浏览器的请求是否来自一个合法的源，这样可以用来防御CSRF，它也不想Referer那么容易被清空</p><h5 id="WEB-Storage"><a href="#WEB-Storage" class="headerlink" title="WEB Storage"></a>WEB Storage</h5><p>浏览器存储的信息方法有三种</p><ul><li>Cookie : 用户保存登录凭证和少量信息。有长度限制不能够存储太多信息</li><li>Flash Shared Object 和 IE userDate： 并非一个通用化的标准</li><li>Web Storage</li></ul><p>Web Storage 分为Session Storage 和 LocalStorage。<br>Session Storage 会在关闭浏览器的时候失效，而LocalStorage则一直会存在<br>Web Storage就像一个非关系型数据库，由Key-Value对组成，可以通过JavaScript对戏进行操作<br>Web Storage也会受到同源策略的约束，每个域所拥有的信息只会保存在自己的域下</p><p>而攻击者可能将而已代码保存在Web Storage 中，从而实现跨页面攻击</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL</title>
      <link href="2021/05/01/safety/SSL/"/>
      <url>2021/05/01/safety/SSL/</url>
      
        <content type="html"><![CDATA[<h3 id="SSL-Secure-Socket-Layer"><a href="#SSL-Secure-Socket-Layer" class="headerlink" title="SSL(Secure Socket Layer)"></a>SSL(Secure Socket Layer)</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>解决问题</p><ol><li>窃听风险，加密机制</li><li>篡改风险，校验机制</li><li>冒充风险，身份证书</li></ol></li><li><p>SSL位于应用层和TCP层之间。</p></li><li><p>使用的的算法</p><ul><li>密钥交换算法：DH算法(Diffie-Hellman)，RSA加密算法</li><li>散列算法：MD5，SHA-1</li></ul></li><li><p>三个特性</p><ul><li>保密性</li><li>鉴别</li><li>完整性</li></ul></li></ul><h4 id="SSL的三个子协议"><a href="#SSL的三个子协议" class="headerlink" title="SSL的三个子协议"></a>SSL的三个子协议</h4><ul><li><p><a href="https://blog.csdn.net/hherima/article/details/52469674">握手协议</a></p><ol><li><p>建立安全能力：商量SSL版本，交换随机数，选择密码套件（密钥交换算法，加密算法和散列算法）和压缩方法。</p></li><li><p>服务器鉴别和密钥交换：客户端校验服务器端发的证书，接收公钥。可能还有一些服务器要求客户进行自身验证的请求。（密钥和证书都使用基础密钥交换方法）</p></li><li><p>客户机鉴别与密钥交换：服务器接受客户端使用公钥加密的预备主密钥（client_key_exchange）和协商完成的信息（change cipher sped）。服务器校验客户端发送的证书信息。</p></li><li><p>握手完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Client-&gt;Server:随机数A，支持的密码套件</span><br><span class="line">Server-&gt;Client:随机数B，选择Client支持的加密算法，服务器证书</span><br><span class="line">Server-&gt;Client:服务器密钥交换</span><br><span class="line">Client-&gt;Client:证书校验</span><br><span class="line">Client-&gt;Server:用server公钥加密预备主密钥，协商信息，证书信息</span><br><span class="line">Server-&gt;Client:握手成功通知</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p><a href="https://blog.csdn.net/chengqiuming/article/details/83095673">记录协议</a></p><p>在完成握手协议以后，使用记录协议。记录协议向SSL连接提供两种服务：</p><ol><li>保密性：使用握手协议定义的密钥实现</li><li>完整性：使用握手协议定义的MAC，用于保持消息的完整性</li></ol></li><li><p>警报协议</p><p>客户机和服务器发现错误时，就会向对方发送一个劲爆消息。如果是致命错误，就会关闭SSL链接，删除相关的会话。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/sunfb/p/3443221.html">https://www.cnblogs.com/sunfb/p/3443221.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="2021/05/01/safety/XSS(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB)/"/>
      <url>2021/05/01/safety/XSS(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB)/</url>
      
        <content type="html"><![CDATA[<h3 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h3><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS。攻击者往Web页面里插入恶意的Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><p>本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><p>分类：存储型XSS,反射型XSS,DOM型XSS</p><h4 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h4><p>将用户输入的数据“反射”给浏览器。往往需要诱使用户点击一个恶意链接，才能攻击成功。又称“非持久性XSS”</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>将用户输入的数据“存储”在服务器端。如写下一篇包含恶意JavaScript代码的博客</p><h4 id="DOM-型XSS"><a href="#DOM-型XSS" class="headerlink" title="DOM 型XSS"></a>DOM 型XSS</h4><p>类似于反射性XSS，用户点击时，修改页面的DOM节点形成XSS</p><p>通常来说风险：存储型 &gt; 反射性<br>攻击过程来说：反射性 &gt; 存储型</p><h3 id="XSS攻击进阶"><a href="#XSS攻击进阶" class="headerlink" title="XSS攻击进阶"></a>XSS攻击进阶</h3><h4 id="XSS-Payload"><a href="#XSS-Payload" class="headerlink" title="XSS Payload"></a>XSS Payload</h4><p>XSS Payload：攻击者能够对用户当前浏览器的页面植入恶意脚本，进而控制用户的浏览器。这种恶意脚本就称为”XSS Payload”</p><p>常见的 XSS Payload: 读取浏览器的cookie对象，从而发起“Cookie劫持”攻击</p><h4 id="构造GET-和POST请求"><a href="#构造GET-和POST请求" class="headerlink" title="构造GET 和POST请求"></a>构造GET 和POST请求</h4><p>通过JavaScript 模拟浏览器发包<br>通过GET执行某些操作<br>通过JavaScript发出Post请求，通过提交表单或者通过XMLHttpRequest</p><h4 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h4><p>XSS的攻击都是通过浏览器的JavaScript脚本自动进行的，缺少和用户交互的过程。<br>比如：修改用户密码时需要用户输入旧密码，这样就可以通过钓鱼 </p><h4 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(navigator.userAgent);</span><br></pre></td></tr></table></figure><p>更高级的识别技巧：利用不同浏览器之间的是独有的对象判断</p><h4 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h4><p>如识别firefox的拓展</p><h4 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h4><p>如果客户安装了Java环境，XSS就可以通过调用JavaApplet的接口获取本机IP地址</p><h4 id="XSS构造技巧"><a href="#XSS构造技巧" class="headerlink" title="XSS构造技巧"></a>XSS构造技巧</h4><ul><li>利用字符编码</li><li>绕过长度限制<ul><li>利用 location,hash 藏代码</li><li>远程加载JS</li><li>利用注释符</li></ul></li><li>使用&lt;base&gt;标签<ul><li>作用是定义页面上所有使用相对路径标签的host地址</li></ul></li><li>window.name 实现跨域、跨页面请求数据</li></ul><h3 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h3><p>XSS本质是“HTML 注入”</p><h4 id="HTTP-only"><a href="#HTTP-only" class="headerlink" title="HTTP only"></a>HTTP only</h4><p>通过Set-Cookie给关键Cookie植入HTTPOnly标识，解决XXS后的Cookie劫持攻击<br>防御：</p><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>前后端都对输入进行检查，检查用户输入的数据是否包含一些特殊的字符。这种方式成为“XSS Filter”</p><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>变量输出到HTML页面时，可以使用编码或者转义的方式防御XSS</p><ul><li>使用安全的编码函数，需要注意的是安全编码后的长度可能发生改变，影响某些功能</li><li>可以考虑不止使用一种编码</li></ul><h4 id="处理富文本"><a href="#处理富文本" class="headerlink" title="处理富文本"></a>处理富文本</h4><p>禁止危险标签：&lt;iframe&gt;,&lt;script&gt;,&lt;base&gt;,&lt;form&gt;<br>标签应使用白名单，避免黑名单。如只允许使用&lt;a&gt;,&lt;img&gt;,&lt;div&gt;等安全标签<br>白名单同时应用于属性与事件的选择</p><h4 id="防御DOM-based-XSS"><a href="#防御DOM-based-XSS" class="headerlink" title="防御DOM based XSS"></a>防御DOM based XSS</h4><p>尽量避免用户的输入，关注会修改HTML的语句，如</p><ul><li>xxx.innerHTML= </li><li>document.write …..</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全基础</title>
      <link href="2021/05/01/safety/safety%E5%9F%BA%E7%A1%80/"/>
      <url>2021/05/01/safety/safety%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="安全三个要素"><a href="#安全三个要素" class="headerlink" title="安全三个要素"></a>安全三个要素</h3><ul><li>机密性(Confidentially)<ul><li>保证数据内容不能泄露</li><li>常见手段：加密</li></ul></li><li>完整性(Integrity)<ul><li>保护数据内容的完整，没有被篡改</li><li>常见手段：数字签名</li></ul></li><li>可用性(Availability)<ul><li>保护资源是“随需可得”</li><li>Dos攻击就是破坏可用性的<h3 id="安全评估"><a href="#安全评估" class="headerlink" title="安全评估"></a>安全评估</h3>四个阶段<br>（上一个阶段决定下一个阶段的目标，需要实施到什么程度）</li></ul></li></ul><ol><li>资产等级划分<ul><li>明确目标是什么，要保护什么</li></ul></li><li>威胁分析<ul><li>确定危险来自于哪里</li><li>一般采用头脑风暴或者进行威胁建模(STRIDE模型)<ul><li>Spoofing(伪装) 冒充他人身份 认证</li><li>Tampering(篡改) 修改代码或者数据 完整性</li><li>Repudiation(抵赖) 否认做过的事情 不可抵赖性</li><li>Information(信息泄露) 机密信息泄露 机密性</li><li>Denial of Service(拒绝服务) 拒绝服务 可用性</li><li>Elevation of Privilege(提升权限) 未经授权获得许可 授权</li></ul></li></ul></li><li>风险分析<ul><li>Risk = Probability * Damage Potential</li><li>DREAN 模型<ul><li>Damage Potential 获取完整权限，执行管理员操作  泄露敏感信息 泄露其他信息</li><li>Reproducibility 攻击者可随意攻击 攻击者可重复攻击，但有时间限制 攻击者很难重复攻击</li><li>Exploitability 初学者短期内可掌握攻击方法 熟练攻击者才能完成攻击 漏洞利用条件非常苛刻</li><li>Affected users 所有用户，默认配置，关键用户 部分用户，非默认配置 极少数用户，匿名用户</li><li>Discoverability 漏洞显眼，攻击条件容易获得 在私有区域，部分人看得到，需要深入挖掘漏洞 发现漏洞极其困难</li></ul></li></ul></li><li>确认解决方案<ul><li>针对前三点结果，进行针对性解决</li><li>将安全作为产品的一个属性，不能过多干涉业务流程，在性能上也不能拖后腿</li><li>好的方案应该是对客户透明的，尽可能不改变用户的习惯</li><li>好的安全模块在设计上也有做到高聚合、低耦合和易扩展</li></ul></li></ol><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ol><li>“Secure by Default”<ol><li>白名单思想</li><li>最小权限原则：只授予主体必要权限，不过度授权</li></ol></li><li>“Defense in Depth”<ol><li>要在不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案需要相互配合</li><li>要在正确的地方做正确的事情</li></ol></li><li>数据和代码分离原则<ol><li>从漏洞的成因上看问题</li></ol></li><li>不可预测性原则</li></ol><h2 id="商务交易安全-保证可信任，数据不可见，"><a href="#商务交易安全-保证可信任，数据不可见，" class="headerlink" title="商务交易安全(保证可信任，数据不可见，)"></a>商务交易安全(保证可信任，数据不可见，)</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>对称加密</li><li>非对称加密</li></ul><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><ul><li>数字签名</li><li>数字证书</li></ul><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><ul><li>安全套接层协议SSL</li><li>安全电子交易协议SET</li></ul><h2 id="安全技术"><a href="#安全技术" class="headerlink" title="安全技术"></a>安全技术</h2><ul><li>物理措施：采取防辐射、防火以及安装不间断电源（UPS）等措施</li><li>访问控制</li><li>数据加密</li><li>网络隔离</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限管理</title>
      <link href="2021/05/01/safety/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2021/05/01/safety/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h4><p><a href="https://www.zhihu.com/question/19786827">cookie和session的区别</a></p><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>优势</p><ol><li>无状态，可扩展</li><li>跨服务器</li><li>性能提升</li><li>可携带其他信息</li><li>跨域</li><li>配合移动端</li><li>防止CSRF</li></ol><p>JWT(Json web token)</p><p><a href="https://www.cnblogs.com/lihuanqing/p/8485071.html">token VS session</a></p><h4 id="常用Java权限框架"><a href="#常用Java权限框架" class="headerlink" title="常用Java权限框架"></a>常用Java权限框架</h4><ul><li>shiro</li><li>Spring Security</li><li>light Security</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全基础</title>
      <link href="2021/05/01/safety/%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
      <url>2021/05/01/safety/%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h2><p>注入攻击是应用违背了“数据与代码分离原则的”结果</p><p>注入攻击的两个条件</p><ol><li>用户能够控制数据的输入</li><li>原本要执行的代码，拼接了用户的输入，把数据当做代码执行了<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3></li><li>要避免Web服务器开启错误回显，将错误信息直接返回</li><li>还可以盲注，比如注入 “and 1=2”</li><li>Timing Attach，用BENCHMARK函数造成延迟，如果不为真，则该语句很快就执行完</li><li>BENCHMARK()函数，可以让同一个函数执行若干次，使得结果返回的时间比平常要场，通过时间长短的变化，判断出注入语句是否执行成功。</li></ol><h4 id="防御SQL注入"><a href="#防御SQL注入" class="headerlink" title="防御SQL注入"></a>防御SQL注入</h4><p>要做的事情</p><ul><li><p>找到所有SQL注入漏洞</p></li><li><p>修补这些漏洞</p></li><li><p>使用预编译语句<br>如使用？代替变量</p></li><li><p>使用存储过程<br>尽量避免在存储过程内使用动态的sql，如果无法避免，应该使用严格的输入过滤或者编码函数来处理用户的输入数据</p></li><li><p>检查数据类型</p></li><li><p>使用安全函数</p></li><li><p>数据库应该使用最小权限原则，避免web应用直接使用root、dbowner等高权限账户直接连接数据库</p></li></ul><h3 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h3><p>与HTML类似，对用书输入数据包含语言本身的保留字符进行转义</p><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>多吗注入多见于脚本语言<br>JSP的动态include也能导致代码注入</p><h3 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h3><p>CR(\r),LF(\n)<br>\r\n：换行</p><p>通过注入CRLF可能会改变原有的语义，HTTP就是通过“\r\n”来分割的。如果服务器端没有过滤“\r\n”，又把用户输入的数据放在HTTP头中，则有可能导致安全隐患</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全基础</title>
      <link href="2021/05/01/safety/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>2021/05/01/safety/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略介绍</a></p><p>同源策略解决的问题：CSRF</p><p>CSRF（cross-site request forgery) 通过伪装成受信任用户的请求来利用受信任的网站。</p><p><a href="https://blog.csdn.net/stpeace/article/details/53512283">CSRF攻防简介</a></p><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">如何防止CSRF攻击</a><br>防止手段</p><ul><li>CSRF自动防御策略：同源检测（Origin和Referer验证）</li><li>CSRF主动防御措施：Token验证，双重Cookie验证以及配合Samesite Cookie</li><li>保证页面的幂等性，后端接口不在GET页面做用户操作</li></ul><p>CORS(跨域资源共享标准)<br>CORS 提供了一种设置你的页面可以访问指定的域名下的资源（API）的方法。当然这些域名是你受信任的。从而避免了 CRSF 攻击。CORS 就像是一个过滤器</p><p>跨域问题的解决方案</p><ol><li><p>将Vue 编译后的代码放到 Spring-boot 的 <code>resources/static</code> 目录下。前后端使用一个服务</p></li><li><p>CORS</p><p>2.1 使用注解</p><p>2.2 在配置类中设置CORS（设置全局跨域）</p></li></ol><p>配置跨域问题的注意事项:</p><p>不要设置@CrossOrigin(‘*’)。虽然达到跨域访问的问题，但是不能达到CORS的意义。因为这个操作是信任所有域名</p><p><a href="https://zhuanlan.zhihu.com/p/66276472">SpringBoot+vue跨域问题实例</a></p><h1 id="同源策略的表现"><a href="#同源策略的表现" class="headerlink" title="同源策略的表现"></a>同源策略的表现</h1><ol><li>DOM层面：限制了不同源的JavaScript脚本对当前DOM对象读写操作</li><li>数据层面：限制不同源的站点读取当前站点的Cookie，IndexDB，LocalStorage等数据</li><li>网络层面：限制通过XMLHttpRequest等方式将站点的数据发送给不同源的站点</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jest跑测试文件</title>
      <link href="2021/05/01/vue/Jest%E8%B7%91%E5%8D%95%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
      <url>2021/05/01/vue/Jest%E8%B7%91%E5%8D%95%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Jest跑单个测试文件"><a href="#Jest跑单个测试文件" class="headerlink" title="Jest跑单个测试文件"></a>Jest跑单个测试文件</h1><blockquote><p>问题背景：当我们使用vue框架进行测试时，使用的是直接运行jest，就会直接测试所有在__tests__目录下的所有测试文件。但往往有时候，我们不需要执行所有的测试文件，那么如何使用jest运行单个测试文件或者是运行非__tests__目录下的文件</p></blockquote><p>遇到第一个问题的第一反应，我就查看官方提供的文档。<br>官方文档是这样描述的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run unit tests with Jest. Default testMatch is &lt;rootDir&gt;&#x2F;(tests&#x2F;unit&#x2F;**&#x2F;*.spec.(js|jsx|ts|tsx)|**&#x2F;__tests__&#x2F;*.(js|jsx|ts|tsx)) which matches:</span><br><span class="line"></span><br><span class="line">Any files in tests&#x2F;unit that end in .spec.(js|jsx|ts|tsx);</span><br><span class="line">Any js(x)&#x2F;ts(x) files inside __tests__ directories.</span><br></pre></td></tr></table></figure><p>通过文档描述，使用jest测试有三个要求</p><ul><li>测试文件名要以spec结果</li><li>测试文件后缀为js，jsx，ts，tsx</li><li>测试文件需要放在tests/unit/目录下或者是/__tests__/目录下<br>只要满足这三个要求的测试文件，使用运行jest时就会自动执行</li></ul><p>同时官方用例提供了一种方式告诉你如何使用jest进行单个文件测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jest my-test #or</span><br><span class="line">jest path&#x2F;to&#x2F;my-test.js</span><br></pre></td></tr></table></figure><p>我们也可以打开jest的执行文件的源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">basedir=$(dirname <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$0</span>&quot;</span> | sed -e &#x27;s,\\,/,g&#x27;)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> `uname` <span class="keyword">in</span></span><br><span class="line">    *CYGWIN*) basedir=`cygpath -w <span class="string">&quot;<span class="variable">$basedir</span>&quot;</span>`;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$basedir</span>/node&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$basedir</span>/node&quot;</span>  <span class="string">&quot;<span class="variable">$basedir</span>/../jest/bin/jest.js&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  ret=$?</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  node  <span class="string">&quot;<span class="variable">$basedir</span>/../jest/bin/jest.js&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  ret=$?</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$ret</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现jest文件可以接受一个参数列表，而这一个参数列表就是我们需要执行测试的文件或者需要执行的文件目录。</p><p>&emsp;&emsp;到这里我们可以很顺利的运用jest执行我们需要执行的文件。但是我们还是没有改变需要执行的目录，测试文件仍然还需要在__tests__目录下。想到竟然这一个目录被定死了，那么肯定有它的配置文件，那么就看一下它的配置文件。  很容易知道他的配置文件就是package.json。然而这个文件没有我们需要寻找的jest路径的相关信息。然后就去找最顶级的默认配置文档。发现有testMatch这一个属性。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;jest&quot;: &#123;</span><br><span class="line">  &quot;testEnvironment&quot;: &quot;node&quot;,</span><br><span class="line">  &quot;setupFiles&quot;: [</span><br><span class="line">    <span class="string">&quot;&lt;rootDir&gt;/scripts/testSetup.js&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  &quot;testMatch&quot;: [</span><br><span class="line">    <span class="string">&quot;**/__tests__/**/*.spec.js&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这里很清晰的说明了jest的测试目录，只要修改这一个“testMatch的值”，就可以随心所欲地运行某个我们想运行的文件。</p><hr><p>&emsp;&emsp;如果仅仅需要测试单个文件。可以使用Node.js提供了一个运行文件的方法(同时也是VSCode的Jest Runner插件使用的方法).该方法提供两个参数，第一个参数为jest.js文件的绝对路径，第二个文件为测试文件的绝对路径。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node &quot;d:&#x2F;Smith_Peng&#x2F;project&#x2F;node_modules&#x2F;jest&#x2F;bin&#x2F;jest.js&quot; &quot;d:&#x2F;Smith_Peng&#x2F;project&#x2F;all&#x2F;main-spec.js&quot;</span><br></pre></td></tr></table></figure><hr><p>Reference :<br>vue默认配置文档：<a href="https://github.com/vuejs/vue-cli/blob/dev/package.json">https://github.com/vuejs/vue-cli/blob/dev/package.json</a><br>官方文档：<a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-unit-jest">https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-unit-jest</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue路由周期</title>
      <link href="2021/05/01/vue/Vue%E8%B7%AF%E7%94%B1%E5%91%A8%E6%9C%9F/"/>
      <url>2021/05/01/vue/Vue%E8%B7%AF%E7%94%B1%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903924760051725">https://juejin.cn/post/6844903924760051725</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue版本更换</title>
      <link href="2021/05/01/vue/vue%20%E7%89%88%E6%9C%AC%E6%9B%B4%E6%8D%A2/"/>
      <url>2021/05/01/vue/vue%20%E7%89%88%E6%9C%AC%E6%9B%B4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="查看Vue-版本"><a href="#查看Vue-版本" class="headerlink" title="查看Vue 版本"></a>查看Vue 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure><p>若不是2.9.6</p><h3 id="卸载Vue-版本"><a href="#卸载Vue-版本" class="headerlink" title="卸载Vue 版本"></a>卸载Vue 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure><h3 id="安装2-9-6版本"><a href="#安装2-9-6版本" class="headerlink" title="安装2.9.6版本"></a>安装2.9.6版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli@2.9.6</span><br></pre></td></tr></table></figure><p>有其他问题，重启大法</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueX</title>
      <link href="2021/05/01/vue/vuex/"/>
      <url>2021/05/01/vue/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="Vuex的本质"><a href="#Vuex的本质" class="headerlink" title="Vuex的本质"></a>Vuex的本质</h2><p>Vuex本质上是一个Vue插件，是一个状态管理器。<br>核心就是一个Store对象，他是一个全局并且是单例的对象<br>这个对象通过state保存数据，里面getter和mutation和action的操作方式</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State就是状态数据，而Actions、Mutations都是对这些状态数据进行处理</p><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>Mutation是更改state的唯一方法。Mutation唯一的触发方式就是commit，mutation非常类似于事件注册，mutation必须是同步函数</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>用法和Mutations一样，但是可以是异步函数，action处理函数所做的事情则是commit mutation</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>module 实际上就是对Store对象的切割。可以理解为对Store进行水平切分和垂直切分独立的模块。每个模块可以看做为一个命名空间。而最外层的Store则是全局命名空间。</p><h2 id="Vuex的状态管理"><a href="#Vuex的状态管理" class="headerlink" title="Vuex的状态管理"></a>Vuex的状态管理</h2><p><img src="/images/Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.png" alt="Vuex"><br>View</p><ol><li>Vue组件通过dispatch的方法调用Actions</li><li>在Actions中，使用commit的方法调用mutations</li><li>mutations更改了state之后重新渲染到Vue组件</li></ol><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>本质是一个快捷映射，作用是简化开发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">    countAlias: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引用mapState以后，我们就可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.count 来代替 <span class="built_in">this</span>.$store.count</span><br></pre></td></tr></table></figure><p>都有对应的辅助函数<br>state —&gt; mapState<br>getters —&gt; mapGetters</p><h3 id="为什么Mutation必须为同步"><a href="#为什么Mutation必须为同步" class="headerlink" title="为什么Mutation必须为同步"></a>为什么Mutation必须为同步</h3><p>Mutation唯一的限制就是同步Mutation,作用的为了能用devtools追踪变化</p><p><a href="https://mobilesite.github.io/2016/12/18/vuex-introduction/">https://mobilesite.github.io/2016/12/18/vuex-introduction/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 设计</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/Restful/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/Restful/</url>
      
        <content type="html"><![CDATA[<h3 id="Restful-设计"><a href="#Restful-设计" class="headerlink" title="Restful 设计"></a>Restful 设计</h3><ul><li> 资源</li><li>表现层：资源的表现形式：如以json表现。HTTP请求头中的accept和content-type字段控制</li><li>状态转化(get,post,put,delete)<br>原则：</li><li>每一种URI 代表一种资源</li><li>服务器和客户端之间传递的资源的表现层</li><li>客户端通过四个HTTP动词，对服务器词源进行操作，实现表现层状态转化 <h4 id="设计误区"><a href="#设计误区" class="headerlink" title="设计误区"></a>设计误区</h4></li></ul><ol><li>URI出现动词。<h3 id="Hypermedia-API-HATEOAS"><a href="#Hypermedia-API-HATEOAS" class="headerlink" title="Hypermedia API(HATEOAS)"></a>Hypermedia API(HATEOAS)</h3>简单来讲就是告诉别人有什么API可以调用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式实例</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>模板设计模式：servlet的继承：oneServlet extends HttpServlet<br>观察者模式：servlet的Listener<br>组合模式：Tomcat Catalina模块</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>任何基类可以出现的地方，子类一定可以出现</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>开闭原则的基础，针对接口编程，依赖抽象而不依赖于具体</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>使用多个接口，比使用单个接口要好，降低类之间的耦合度</p><h2 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h2><p>一个实体应当尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>对扩展开放，对修改关闭。对程序进行扩展的时候，不应该去修改原有的代码</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发原则</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/WAa4ezth4CGwyjJD7FcP6w">https://mp.weixin.qq.com/s/WAa4ezth4CGwyjJD7FcP6w</a></p><h2 id="软件开发原则"><a href="#软件开发原则" class="headerlink" title="软件开发原则"></a>软件开发原则</h2><ol><li>剔除无效状态</li><li>数据一致性让系统更简单</li><li>数据设计先行</li><li>杀鸡不要用牛刀</li><li>避免为了局部简单性而增加全局复杂性</li><li>识别内在的复杂性</li><li>使用的技术越少，系统就越简单</li><li>集中精力学习概念，而不是技术</li><li>代码一致性很重要</li><li>分享原则很重要</li></ol><h2 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h2><ul><li>N+1设计：保证每个组件都应该做到没有单点故障</li><li>回滚设计：确保系统可以向前兼容，在出现故障的时候能够快速下线</li><li>禁用设计：在设计阶段就要考虑监控手段</li><li>多活数据中心设计：若系统要极高的可用性，应考虑在多地实施数据中心进行多活，至少在一个机房断点的情况下系统依旧可用</li><li>采用成熟的技术</li><li>架构应能水平扩展：才能有效避免瓶颈问题</li><li>非核心则购买</li><li>使用商业硬件</li><li>快速迭代</li><li>无状态设计</li></ul><h2 id="如何把控自己的程序员生涯"><a href="#如何把控自己的程序员生涯" class="headerlink" title="如何把控自己的程序员生涯"></a>如何把控自己的程序员生涯</h2><p><a href="https://coolshell.cn/articles/20977.html">https://coolshell.cn/articles/20977.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/arthas/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/arthas/</url>
      
        <content type="html"><![CDATA[<h2 id="查看JVM-信息"><a href="#查看JVM-信息" class="headerlink" title="查看JVM 信息"></a>查看JVM 信息</h2><ul><li>sysprop：打印所有的System Properties信息</li><li>sysenv：获取到环境变量</li><li>jvm：打印出JVM的各种详细信息</li><li>dashboard：查看当前系统的实时数据面板</li></ul><h2 id="查看已加载的类"><a href="#查看已加载的类" class="headerlink" title="查看已加载的类"></a>查看已加载的类</h2><ul><li>sc：查找到所有JVM已经加载到的类</li><li>sm: 查找类的具体函数</li></ul><h2 id="反编译指令-Jad"><a href="#反编译指令-Jad" class="headerlink" title="反编译指令 Jad"></a>反编译指令 Jad</h2><h2 id="动态执行代码-ognl"><a href="#动态执行代码-ognl" class="headerlink" title="动态执行代码 ognl"></a>动态执行代码 ognl</h2><p>ognl ‘@<a href="mailto:&#106;&#97;&#x76;&#97;&#46;&#x6c;&#97;&#110;&#103;&#46;&#83;&#121;&#x73;&#x74;&#101;&#x6d;&#64;&#111;&#117;&#x74;&#46;&#112;&#114;&#x69;&#110;&#x74;&#x6c;&#x6e;">&#106;&#97;&#x76;&#97;&#46;&#x6c;&#97;&#110;&#103;&#46;&#83;&#121;&#x73;&#x74;&#101;&#x6d;&#64;&#111;&#117;&#x74;&#46;&#112;&#114;&#x69;&#110;&#x74;&#x6c;&#x6e;</a>(“hello ognl”)’</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 查询优化</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E4%BC%98%E5%8C%96%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E4%BC%98%E5%8C%96%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84.png" alt="查询执行路径"></p><h2 id="客户端-服务器端通信协议"><a href="#客户端-服务器端通信协议" class="headerlink" title="客户端/服务器端通信协议"></a>客户端/服务器端通信协议</h2><p>使用半双工的通信方式。使用的是无控制流的协议。</p><p>查询线程的状态</p><ul><li>Sleep：线程等待客户端发请求</li><li>Query：正在执行查询语句或者返回结果给客户端</li><li>Locked：等待锁（表锁或者行锁）</li><li>Analyzing and statistics：搜集存储引擎的统计信息，生成查询计划</li><li>Copying to tmp table（on disk）：正在执行查询，并且将结果集复制到一个临时表。这状态一般是GROUP BY、文件排序或者是UNION操作。如果后面有on disk则表示正在对临时表进行持久化操作</li><li>Sorting result：线程正在对表进行排序</li><li>Sending data：可能为线程在多个状态传送数据或者生成结果集，或者向客户端返回结果集</li></ul><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>包括：</p><h3 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h3><p>对SQL进行解析，并生成解析树。校验是否使用错误的关键字或者关键字的顺序是否一致。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>校验解析树是否合法。检验数据表和数据是否存在。解析名字和别名，判断是否有歧义</p><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>一条执行语句可以有多重执行方式，最后都返回同样的结果。优化器的作用就是找出最好的一种。</p><p>MySQL使用的是基于成本的优化器。成本的单位使用一个随机读取4字节的页数来表示。数值是基于每个表或者是索引的页数、索引的基数、索引和数据行的长度和分布情况等统计信息来估计的。在计算的时候并不考虑缓存，假设读取任何数据都需要一次磁盘IO。</p><p>查询优化器在服务器层，但是没有保存数据和索引的统计信息。统计信息是存储引擎提供给优化器的，因此如何统计是有存储引擎实现的</p><h4 id="MySQL优化器选择错误的执行计划的原因"><a href="#MySQL优化器选择错误的执行计划的原因" class="headerlink" title="MySQL优化器选择错误的执行计划的原因"></a>MySQL优化器选择错误的执行计划的原因</h4><ul><li>统计信息不准确</li><li>执行计划的成本不等于实际执行的成本</li><li>MySQL的最优是成本的最优，而不是时间的最优</li><li>MySQL不考虑并发执行的查询</li><li>不总是基于成本优化。如使用MATCH()子句，则存在全文索引的时候就会使用全文索引</li><li>不考虑不受其控制的操作，如执行存储过程和用户自定义函数</li></ul><h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><ul><li><p>静态优化</p><p>对解析树进行分析并优化。类似于编译时优化</p></li><li><p>动态优化</p><p>动态优化和查询上下文有关。在每次查询时都要重新评估。类似于运行时优化</p></li></ul><h4 id="MySQL能够处理的优化类型"><a href="#MySQL能够处理的优化类型" class="headerlink" title="MySQL能够处理的优化类型"></a>MySQL能够处理的优化类型</h4><ul><li><p>重新定义关联表的顺序</p></li><li><p>将外连接转换为内连接</p></li><li><p>使用等价变换规则</p></li><li><p>对COUNT，MIN和MAX进行优化</p><p>如找某一列的最小值，则只需要查询对应的B树索引最左端的记录</p></li><li><p>预估并转化为常量表达式</p><p>如知道一个表达式可以转化为常数时，就会一直把该表达式转化为常数</p></li><li><p>覆盖索引扫描</p></li><li><p>子查询优化</p></li><li><p>提前终止查询</p><p>当发现一个不成立的条件，就可以立刻返回空结果。使用LIMIT子句直接返回结果</p></li><li><p>等值传播</p></li><li><p>列表IN()的比较</p></li></ul><h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><h5 id="MySQL执行关联的策略"><a href="#MySQL执行关联的策略" class="headerlink" title="MySQL执行关联的策略"></a>MySQL执行关联的策略</h5><p>任何关联都执行嵌套循环关联操作。</p><p>MySQL会先从一个表中循环去取单条数据，然后嵌套循环到下一个表中寻找匹配的行。然后根据各个表匹配的行，返回查询需要的各个列。MySQL会尝试在最优一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行，就会返回到上一层次关联表。以此类推迭代执行。通俗来讲就是for循环嵌套。</p><p>关联查询不一定是要查询两张表。每一个子查询或者是每一个select的结果都会产生一张表</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p><p>当关联的表的数量超过optimizer_search_depth的值时，优化器就会使用贪婪搜索的方式查找最优的关联顺序</p><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p>两种排序算法</p><ol><li><p>两次传输排序</p><p>首先读取行指针和需要排序的字段，然后对其排序。再根据排序结果读取所需要的数据行。缺点是两次IO操作。优点是节省内存</p></li><li><p>单次传输排序</p><p>读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。优缺点与两次传输排序相反</p></li></ol><h2 id="优化器的缺陷"><a href="#优化器的缺陷" class="headerlink" title="优化器的缺陷"></a>优化器的缺陷</h2><ol><li>MySQL的子查询实现得非常糟糕。where中包含IN()的子查询。一般会优先执行IN()。但是MySQL可能会将外层表压到子查询当中。可以用exist函数改写。</li><li>MySQL无法将限制条件从外层下推到内层</li><li>无法利用多核特性来并行执行查询</li><li>不支持hash关联</li><li>不支持松散索引扫描。如索引(a,b)。不支持直接使用b进行扫描</li><li>如果没有索引，使用MIN和MAX会进行一次全表扫描。可以使用limit1代替</li><li>不能再同一个表上查询和更新。可以通过生成表的方式解决</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 缓存</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E7%BC%93%E5%AD%98/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>查询缓存机制</p><p>缓存是放在内存当中的。</p><h4 id="如何查询命中缓存的"><a href="#如何查询命中缓存的" class="headerlink" title="如何查询命中缓存的"></a>如何查询命中缓存的</h4><p>缓存查询策略：全局扫描。</p><p>不放入缓存的情况：使用不确定的值。如NOW()，CURRTEN_DATE()等</p><p>使用缓存会有额外的开销：</p><ul><li>读之前要查询缓存是否命中</li><li>将结果存储缓存</li><li>在写数据的时候，需要将相关的缓存设置失效</li><li>事务机制会使缓存失效</li></ul><h4 id="查询缓存如何使用内存"><a href="#查询缓存如何使用内存" class="headerlink" title="查询缓存如何使用内存"></a>查询缓存如何使用内存</h4><p>查询缓存分为两部分，一部分是管理结构，大约为40KB，一部分是缓存块。</p><p>数据是一条一条地放入缓存中的。</p><h4 id="什么时候使用缓存"><a href="#什么时候使用缓存" class="headerlink" title="什么时候使用缓存"></a>什么时候使用缓存</h4><p>适合那一些消耗大量资源但是占用存储空间小的操作。如COUNT()</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 高级特性</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="查询缓存机制"><a href="#查询缓存机制" class="headerlink" title="查询缓存机制"></a>查询缓存机制</h3><p>缓存是放在内存当中的。</p><h4 id="如何查询命中缓存的"><a href="#如何查询命中缓存的" class="headerlink" title="如何查询命中缓存的"></a>如何查询命中缓存的</h4><p>缓存查询策略：全局扫描。</p><p>不放入缓存的情况：使用不确定的值。如NOW()，CURRTEN_DATE()等</p><p>使用缓存会有额外的开销：</p><ul><li>读之前要查询缓存是否命中</li><li>将结果存储缓存</li><li>在写数据的时候，需要将相关的缓存设置失效</li><li>事务机制会使缓存失效</li></ul><h4 id="查询缓存如何使用内存"><a href="#查询缓存如何使用内存" class="headerlink" title="查询缓存如何使用内存"></a>查询缓存如何使用内存</h4><p>查询缓存分为两部分，一部分是管理结构，大约为40KB，一部分是缓存块。</p><p>数据是一条一条地放入缓存中的。</p><h4 id="什么时候使用缓存"><a href="#什么时候使用缓存" class="headerlink" title="什么时候使用缓存"></a>什么时候使用缓存</h4><p>适合那一些消耗大量资源但是占用存储空间小的操作。如COUNT()</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>目的：将数据按照一个较粗的粒度分在不同的表中。这样可以将相关的数据放在一起。</p><p>使用场景：</p><ol><li>表非常大</li><li>分区表的数据更容易维护</li><li>分区表的数据可以分布在不同的设备上</li><li>避免某些特殊瓶颈，如InnoDB的单个索引互斥访问</li><li>可以备份和恢复独立的分区。</li></ol><p>限制：</p><ol><li>一个表最多有1024个分区</li><li>分区表达式必须是整数或者是返回整数的表达式</li><li>如果分区字段有主键或者唯一索引的列，则所有主键和唯一索引列都必须包含起来</li><li>分区表无法使用外键约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 访问优化</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="优化数据库访问"><a href="#优化数据库访问" class="headerlink" title="优化数据库访问"></a>优化数据库访问</h3><h4 id="确认检索的数据超过需求的数据"><a href="#确认检索的数据超过需求的数据" class="headerlink" title="确认检索的数据超过需求的数据"></a>确认检索的数据超过需求的数据</h4><p>几种典型不好的操作</p><ol><li>查询不需要的数据</li><li>多表关联时获取所有列</li><li>获取所有的列</li><li>重复查询相同的数据</li></ol><h4 id="确认MySQL服务器扫描的数据超过需求的数据"><a href="#确认MySQL服务器扫描的数据超过需求的数据" class="headerlink" title="确认MySQL服务器扫描的数据超过需求的数据"></a>确认MySQL服务器扫描的数据超过需求的数据</h4><p>三个指标</p><ul><li>执行时间</li><li>扫描的行数</li><li>检查的行数</li></ul><p>where的应用：（由好到坏）</p><ol><li>在索引中使用WHERE条件过滤不匹配的行数（发生在存储引擎层）</li><li>使用覆盖索引来避免行访问和过滤掉不匹配的行（发生在服务器层）</li><li>从数据表中返回数据，然后过滤不满足的数据（发生在服务器层）</li></ol><p>在大量数据中返回少量的行。可以考虑</p><ol><li>使用覆盖索引</li><li>改变数据库结构，添加单独的汇总表</li><li>重写复杂的查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 特殊查询优化</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E4%BC%98%E5%8C%96%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E4%BC%98%E5%8C%96%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h3><h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><ul><li>确保ON或者USING子句中的列有索引</li><li>确保GROUP BY和ORDER BY中的表达式只涉及到一个表中的列</li></ul><h4 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h4><p>采用查找的标识列分组的效率会比其他列高</p><h4 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h4><p>如果分页偏移量过大的时候可以使用主键筛选一部分，然后再限制条数。</p><h4 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h4><p>除非需要消除重复的行，否则一定要使用UNION ALL。如果没有UNION ALL，MySQL会对临时表做唯一性检查。</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>不能使用的场景</p><ul><li>使用自定义变量就无法查询缓存</li><li>不能再常量或者标识符的地方使用</li><li>不能用于做连接间的通信</li><li>避免在使用连接池或者持久化连接使用</li><li>大小写敏感</li><li>不能显示地声明自定义变量的类型</li><li>某些场景可能将变量优化</li><li>赋值的顺序和赋值时间不固定，依赖于优化器</li><li>赋值符号的优先级非常低</li><li>使用未定义的变量不回产生任何语法错误</li></ul><p>使用场景</p><ul><li>优化排名语句</li><li>可以避免重复查询刚刚更新的数据</li><li>统计更新和插入的数量</li><li>确认取值的顺序</li></ul><h3 id="优化查询原则"><a href="#优化查询原则" class="headerlink" title="优化查询原则"></a>优化查询原则</h3><ul><li>尽量少做事。尽可能不要使用轮询，否则会增加负载，带来很多低产出工作</li><li>尽可能得完成需要做的事情。事务提交得越快，持有锁的时间就越短</li><li>在不要求精度的情况下使用近似值</li><li>一些计算可以通过应用程序计算。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB瓶颈的发现</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E5%8F%91%E7%8E%B0%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E5%8F%91%E7%8E%B0%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/</url>
      
        <content type="html"><![CDATA[<h3 id="Benchmarking（基准测试）"><a href="#Benchmarking（基准测试）" class="headerlink" title="Benchmarking（基准测试）"></a>Benchmarking（基准测试）</h3><p>作用：测量系统的性能</p><p>功能：</p><ol><li>测量当前应用的性能</li><li>检验系统的可扩展性</li><li>规划扩展。估计未来需要多少的硬件，网络资源等</li><li>测试应用在不断变化的环境中的承受能力</li><li>可以比较不同硬件上、软件和操作系统上的性能比较</li></ol><h4 id="Benchmarking-Strategies（基准策略"><a href="#Benchmarking-Strategies（基准策略" class="headerlink" title="Benchmarking Strategies（基准策略)"></a>Benchmarking Strategies（基准策略)</h4><p>对整个应用进行测试而不是仅仅对MySQL单独测试的好处</p><ol><li>关注的是整个应用，而不是仅仅是MySQL</li><li>MySQL不总是应用的性能瓶颈</li><li>测试整个应用可以每个部分的缓存行为方式</li><li>性能瓶颈在实际应用行为中比较容易复现</li></ol><p>只有当仅仅想关注数据库的瓶颈时才只对MySQL进行测试，如</p><ol><li>比较不同的shemas 或者 queries</li><li>对在应用中看到的特定问题进行基准测试</li><li>想进行较短的基准测试，更快地进行和评估变更周期</li></ol><p>测试的内容</p><ol><li>单位时间的事务量</li><li>响应时间或者延迟</li><li>可扩展性</li><li>并发量</li></ol><h4 id="Benchmarking-Tactics（基准措施）"><a href="#Benchmarking-Tactics（基准措施）" class="headerlink" title="Benchmarking Tactics（基准措施）"></a>Benchmarking Tactics（基准措施）</h4><p>在进行测试应该避免的情况</p><ol><li>使用真实数据的子集</li><li>使用不正确分布的数据</li><li>使用不真实的分布式参数</li><li>对多用户应用程序使用单用户方案</li><li>在一个服务器上测试分布式的应用</li><li>循环使用相同的查询</li><li>没有匹配真实用户的行为</li><li>没有检测错误</li><li>忽视系统系统未预热的性能（如系统重启时的性能）</li><li>使用默认的系统配置</li></ol><h5 id="Designing-and-Planning-a-Benchmark"><a href="#Designing-and-Planning-a-Benchmark" class="headerlink" title="Designing and Planning a Benchmark"></a>Designing and Planning a Benchmark</h5><ol><li>确定问题和目标</li><li>确定使用标准的基准测试还是设计自己的基准测试<ul><li>使用基准测试要选择符合需求的测试</li><li>使用自定义的基准测试首先需要备份数据集，接下来根据数据查询。可以将行文记录在日志上。</li><li>即使不能建立自定义的基准测试，也要将基准测试的计划记录下来</li><li>设计一些方法参数的文档和结果</li></ul></li></ol><h5 id="Getting-Accurate-Results"><a href="#Getting-Accurate-Results" class="headerlink" title="Getting Accurate Results"></a>Getting Accurate Results</h5><p>没有得到正确的结果需要检查</p><ol><li>是否选择核实的基准测试</li><li>是否获取到了你解决问题所需要的数据</li><li>是否使用了错误的标准进行基准测试</li></ol><h4 id="Benchmarking-Tools"><a href="#Benchmarking-Tools" class="headerlink" title="Benchmarking Tools"></a>Benchmarking Tools</h4><ol><li>全栈工具<ul><li>ab（Apache HTTP server benchmarking tools）</li><li>http_load </li><li>JMeter</li></ul></li><li>单独组件工具<ul><li>mysqlap</li><li>sysbench</li><li>Database Test Suite</li><li>MySQL Benchmark Suite</li><li>Super Smack</li></ul></li></ol><h3 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h3><p>作用：找出应用的哪一部分花费时间多，消耗资源大</p><p>分类：application profiling，server profiling，database profiling</p><p>功能：</p><ol><li>测试函数调用的次数</li><li>IO操作的次数</li><li>数据查询的测试</li></ol><p>瓶颈产生的原因：</p><ol><li>加载额外的资源</li><li>操作需要处理大量的数据</li><li>循环中的昂贵操作，如滥用正则表达式</li><li>糟糕的优化算法</li></ol><p>测量的指标</p><ol><li>总执行时间</li><li>每一个查询的执行时间</li><li>每一次调用额外的资源</li><li>潜在的昂贵的函数调用</li><li>用户和系统的CPU时间</li></ol><h4 id="MySQL-profiling"><a href="#MySQL-profiling" class="headerlink" title="MySQL profiling"></a>MySQL profiling</h4><p>可以搜集到的信息</p><ol><li>可以查看哪一个数据MySQL访问最多</li><li>MySQL最经常执行哪种查询</li><li>MySQL线程花费最多时间的原因是什么</li><li>MySQL最长使用哪一些子系统执行查询</li><li>查询MySQL期间会访问哪种数据</li><li>MySQL执行了多少种活动。如索引扫描</li></ol><h4 id="日志查询"><a href="#日志查询" class="headerlink" title="日志查询"></a>日志查询</h4><p>MySQL包含两种日志查询</p><ol><li>general log。general log 包含了所有执行过的语句（成功或者失败），但是不记录执行时间或者在查询结束后的任何信息。</li><li>slow log。用于记录MySQL中响应超过阈值的语句。</li></ol><p>查询slow log的缺点</p><ol><li>只能按照秒级的时间粒度进行查询</li><li>无法将所有的查询记录记录到日志</li></ol><p>查询日志主要观察的对象</p><ol><li>长查询。</li><li>高影响力的查询。查找服务器大部分执行时间的查询</li><li>新的查询。之前不在但是现在在排行榜上的查询</li></ol><p>日志分析工具</p><ol><li>mysqldumpslow</li><li>mysql_slow_log_filter</li><li>mysql_slow_log_parser</li><li>mysqlsla</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 引擎</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>mysql使用文件系统存储表名和表的。 使用.frm文件存储表</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ol><li>myISAM提供了全文检索，压缩和空间函数等功能。但是不提供事务支持和行级锁</li><li>存储方面使用了数据文件和索引文件分离模式。使用.MYD记录数据，.MYI记录索引</li><li>支持数据库的行数由硬盘空间和系统允许创建的文件大小所确定的。默认最大可以处理256TB的数据</li><li>MyISAM使用的是表锁。支持自动/手动检查和修复表。</li><li>支持全文检索，允许为BLOB和TEXT类型的前500个字符创建索引</li><li>支持延迟写。</li><li>支持压缩表。用于压缩一些不常修改的表以提高性能</li></ol><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ol><li>使用一系列的一个或多个的独立文件存储数据，我们称之为表空间（tablespace）</li><li>使用MVCC(多版本并发控制)来实现高并发</li><li>使用行级锁</li><li>InnoDB不能够对索引进行排序，MyISAM可以</li><li>可以建立主键<a href="https://www.imooc.com/article/22915">聚集索引</a>。提供快速的主键查询</li><li>不可以在写入的时候通过排序创建索引，MyISAM可以</li><li>InnoDB提供各种内部优化，包括预读优化，适用性的哈希索引，插入缓存</li><li>InnoDB提供外键，MyISAM不提供</li></ol><h4 id="Memory-Engine"><a href="#Memory-Engine" class="headerlink" title="Memory Engine"></a>Memory Engine</h4><ol><li>使用哈希索引</li><li>不支持TEXT 和BLOB类型。当有这两种类型时，会转换为使用MyISAM</li><li>用于存储搜索的中间表</li><li>不支持索引统计</li><li>数据不能持久化</li></ol><h4 id="Archive-Engine"><a href="#Archive-Engine" class="headerlink" title="Archive Engine"></a>Archive Engine</h4><ol><li>只支持INSERT和SELECT操作</li><li>不支持索引</li><li>适用于logging 和数据获取</li><li>支持行级锁和高并发插入</li></ol><h4 id="CSV-Engine"><a href="#CSV-Engine" class="headerlink" title="CSV Engine"></a>CSV Engine</h4><ol><li>可以将CSV文件作为表</li><li>允许在服务运行过程中复制文件进行读写操作</li><li>常用于数据转换或者是特定类型的日志</li></ol><h4 id="Federated-Engine"><a href="#Federated-Engine" class="headerlink" title="Federated Engine"></a>Federated Engine</h4><ol><li>不在本地存储数据，每一个Federated 表关联到远程的MySQL服务器</li></ol><h4 id="Blackhole-Engine"><a href="#Blackhole-Engine" class="headerlink" title="Blackhole Engine"></a>Blackhole Engine</h4><ol><li>没有任何存储机制。丢弃任何INSERT操作。用于查找和存储引擎无关的性能瓶颈</li><li>通过启用和不启用二进制日志记录的Blackhole engine的性能来测量日志记录的开销</li></ol><h4 id="NDB-Cluster-Engine"><a href="#NDB-Cluster-Engine" class="headerlink" title="NDB Cluster Engine"></a>NDB Cluster Engine</h4><ol><li>具有实时，冗余和加载平衡的特点</li><li>支持事务机制</li><li>同事将数据存储到磁盘和内容</li><li>优化主键查询</li><li>包括数据节点，管理节点和SQL节点。</li><li>每个数据节点都有数据片段而片段是重复的。一段数据在不同节点上有多个副本</li><li>管理节点用于检索集中式配置。监视和管理聚集节点</li></ol><h4 id="Falcon-Engine"><a href="#Falcon-Engine" class="headerlink" title="Falcon Engine"></a>Falcon Engine</h4><ol><li>在内容中使用MVCC和事务机制</li><li>为64位的处理器设计</li><li>可能成为网络应用</li></ol><h4 id="SolidBD-Engine"><a href="#SolidBD-Engine" class="headerlink" title="SolidBD Engine"></a>SolidBD Engine</h4><ol><li>事务引擎</li><li>使用MVCC</li><li>支持权限控制和乐观并发控制</li><li>与InnoDB一样，使用聚集索引</li><li>SolidBD 产品是由solidBD存储引擎，MyISAm存储引擎和MySQL服务器组成的</li></ol><h4 id="PBXT-Engine"><a href="#PBXT-Engine" class="headerlink" title="PBXT Engine"></a>PBXT Engine</h4><ol><li>使用事务日志和数据文件避免预写记录，减少事务提交的开销</li><li>能够处理高写并发</li><li>使用MVCC</li><li>支持外键</li><li>使用持久化的事务机制</li></ol><h4 id="Maria-Storage-Engine"><a href="#Maria-Storage-Engine" class="headerlink" title="Maria Storage Engine"></a>Maria Storage Engine</h4><ol><li>是MyISAM的替代品</li><li>支持事务或者非事务机制</li><li>紧急恢复</li><li>行级锁和MVCC</li><li>更好的BLOB的处理</li></ol><h4 id="使用数据要考虑的因素"><a href="#使用数据要考虑的因素" class="headerlink" title="使用数据要考虑的因素"></a>使用数据要考虑的因素</h4><ol><li>事务</li><li>并发</li><li>备份机制</li><li>紧急恢复</li><li>特殊功能</li></ol><p>附：MVCC：多版本并发控制。MVVC基于快照隔离机制，用以解决读-写冲突的无锁并发控制。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql范式</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>使用范式的好处：</p><ol><li>更新操作通常要比不使用范式的要快</li><li>几乎不存在重复的数据</li><li>规范化的表通常更小，拥有更好的性能</li><li>当查询列表的值，不需要使用DISTINCE 和 GROUP BY 进行分组</li></ol><p>使用范式缺点：</p><ol><li>很多情况下都要联表查询</li><li>可能会一些索引策略无效</li></ol><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>表列具有原子性，不能再分解</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>在第一范式的基础上，要求数据库表中的每个实例或者行可以被唯一区分。通常涉及一个主键来实现</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>在第二范式的基础上，要求一个数据表中不包含已在其他表中已包含的非主键字段。即尽量使表的信息能够推导出来，能用外键就用外键。</p><h4 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h4><p>在第三范式的基础上，要求不存在关键字段决定关键字段。</p><h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>优点：</p><ol><li>尽可能避免联表操作</li><li>全表扫描可以尽量避免随机IO操作</li><li>一个表可以使用更加高效的索引策略</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 数据类型</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="选择最佳的数据类型"><a href="#选择最佳的数据类型" class="headerlink" title="选择最佳的数据类型"></a>选择最佳的数据类型</h3><p>原则：</p><ol><li>Smaller is usually better</li><li>Simple is good</li><li>avoid null if possible<ol><li>null列需要更多的存储空间以及需要特殊的处理</li><li>当null列作为索引的时候，将会使固定长度的索引转换为长度可变的</li></ol></li></ol><p>步骤：</p><ol><li>为列选择合适数据类型。如数字，字符</li><li>选择特殊的类型。如datatime 和 timestamp都可以存储时间。后者用的存储空间只有前者的一半，且是自动更新的。</li></ol><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table><thead><tr><th>类型</th><th align="left">字节数</th></tr></thead><tbody><tr><td>TINYINT</td><td align="left">8</td></tr><tr><td>SMALLINT</td><td align="left">16</td></tr><tr><td>MEDIUINT</td><td align="left">24</td></tr><tr><td>INT</td><td align="left">32</td></tr><tr><td>BIGINT</td><td align="left">64</td></tr></tbody></table><h4 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h4><table><thead><tr><th>类型</th><th>字节数</th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td></tr><tr><td>DOUBLE</td><td>8</td></tr><tr><td>DECIMAL</td><td>依赖于（M，D），M&gt;D时，为M+2，否则为D+2</td></tr></tbody></table><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><h5 id="VARHCAR-和-CHAR"><a href="#VARHCAR-和-CHAR" class="headerlink" title="VARHCAR 和 CHAR"></a>VARHCAR 和 CHAR</h5><p>varchar使用1到2个字节记录长度。因此最大长度不能超过65535。</p><p>varchar节省存储空间。如保存‘132’，对于varchar（100）和varchar（200），存储的空间都是一样的。但是内存的消耗不一样。</p><p>char是固定长度的。当使用char（100）保存‘132’时，会用空字符填充后面的剩余空间。</p><p>char是存储MD5值得最好选择。存储短的字符串时，最好使用char，效率也更高</p><p>什么时候应该使用char</p><ol><li>某个字段的字符长度比较短时使用char</li><li>字段长度固定或相近时</li></ol><h5 id="BOLB和TEXT类型"><a href="#BOLB和TEXT类型" class="headerlink" title="BOLB和TEXT类型"></a>BOLB和TEXT类型</h5><p>用于存储大量的二进制和字符串。MySQL将BOLB和TEXT视为对象。</p><p>BOLB和TEXT的查询不是通过整个字符串的匹配进行查询的。而且根据匹配其子字符串。该子字符串的长度可以用max_sort_length进行设置。</p><p>内存引擎是不支持这两种数据类型的。因此如果要查询这两种类型的数据需要建立磁盘上的临时表。所以尽量避免使用BLOB和TEXT类型。如果无法避免，可以使用order by substring转换成子串的形式转换成表存在内存中。</p><h5 id="使用枚举类型代替字符串"><a href="#使用枚举类型代替字符串" class="headerlink" title="使用枚举类型代替字符串"></a>使用枚举类型代替字符串</h5><p>不适合使用枚举类型的情景：当字符串在未来可能会发生改变</p><p>MySQL将每一个枚举值保存为整数。这样能够节省空间。我们在设定主键的时候，也应该使用整数来作为主键。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><ul><li><p>DATETIME：</p><p>格式：YYYYMMDDHHMMSS</p><p>长度：8个字节</p><p>与时区无关。</p></li><li><p>TIMESTAMP</p><p>14位的TIMESTAMP的格式为YYYYMMDDHHMMSS</p><p>长度：4个字节</p><p>时间从1970年1月1日开始算起，与时区相关</p></li></ul><p>尽量使用TIMESTAMP，因为它更节省空间。对于精确到毫秒的时间，可以使用BIGINT存储或者使用DOUBLE储存小数部分。</p><h4 id="比特封装类型"><a href="#比特封装类型" class="headerlink" title="比特封装类型"></a>比特封装类型</h4><ul><li><p>BIT</p><p>BIT能够存储一个或者多个布尔值。但是MySQL将BIT当做字符串处理。</p><p>应该尽量避免这种类型。如果需要存储一个布尔值的话，可以使用CHAR(0)，可以保存NULL或者是长度为0的字符串。</p></li><li><p>SET</p><p>SET能够保存多个布尔值，用以表示一系列位的集合</p></li></ul><h4 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h4><ol><li><p>整数类型通常是标识列的最好选择</p></li><li><p>尽量避免使用ENUM和SET类型作为标识列</p></li><li><p>也尽量避免使用字符串类型。</p><ul><li>因为他们很消耗空间，而且慢。如果使用的是MyISAM表，MyISAM会对字符串使用压缩索引，会更慢。</li><li>对于随机的字符串如MD5的也要注意，因为随机值分布在很大空间，会随机索引到不同职位。会使得insert和select变得很慢。</li></ul></li><li><p>在使用ORM(对象关系映射)时，要注意自动生成的schema。有时候会为每个对象的每个属性使用单独的行，导致单个属性会有多个版本的存在。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 索引</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引优点：</p><ul><li>减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机的IO变成顺序的IO</li></ul><p>索引的类型：</p><ul><li><p>B树索引（B+树）</p></li><li><p>Hash索引</p></li><li><p>空间索引(R-Tree)</p></li><li><p>全文索引</p></li></ul><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>B树对索引列的顺序组织存储的，因此适合查找范围数据。适用于全键值，键值范围和键前缀查找。键前缀查找只适用于最左前缀的查找。</p><p>B树索引的限制</p><ol><li>如果不是按照索引的最左列开始查找，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果查询中有某个列的方位查询，则其右边所有列都无法使用索引优化查询</li></ol><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>在MySQL中，只有支持Memory的引擎显示支持哈希索引。</p><p>Hash索引的限制</p><ol><li>Hash索引只包含哈希值和行指针，不存储字段值。因此不能用索引中的值来避免读取行</li><li>不能使用Hash索引进行排序，因为其存储的时候就不是按照行顺序进行存储</li><li>Hash索引不支持部分索引值顺序存储。</li><li>Hash索引只支持等值比较的查询</li><li>如果存在很多Hash collisions（冲突），会导致速度访问速度变慢。同事维护操作代价会很高</li></ol><p>InnoDB会创建自适应哈希索引，当某个索引值使用频繁时，就会在B树索引上建立一个Hash索引。</p><p>切记不要使用SHA1 和MD5 作为Hash函数。这两函数计算出来的Hash值比较长，会浪费大量空间，降低比较速度。不过因为这两函数在设计上可以最大程度上消除冲突。当CRC32（循环冗余）出现大量冲突的时候，可以自定义Hash函数。</p><p>如何处理Hash冲突？当使用Hash索引进行查询的时候，必须在where子句中包含常量值</p><h4 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h4><p>MyISAM支持空间索引。空间索引常用于地理数据存储。这类索引会从所有维度来索引数据。查询时能够有效地使用任意维度来组合查询。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引类似于搜索引擎。不是简单的where条件匹配</p><h3 id="额外扩展"><a href="#额外扩展" class="headerlink" title="额外扩展"></a>额外扩展</h3><p>《Relational Database index Design and the Optimizers》</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 索引策略</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AD%96%E7%95%A5/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="索引的策略"><a href="#索引的策略" class="headerlink" title="索引的策略"></a>索引的策略</h3><p>索引的星级</p><ul><li>一星索引：索引将相关记录放在一起</li><li>二星索引：索引中的数据顺序和查找中的排序顺序一致</li><li>三星索引：索引中的列包含查询中需要的全部列</li></ul><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>如果查询中的列不是独立的，那么MySQL就不会使用索引</p><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>索引的选择性：不重复的索引值和数据表的记录总数的壁纸。索引选择性的值越高意味着可以过滤掉更多的行，意味着查询效率更高。</p><ul><li>使用索引的前缀字符来代替整一个字符串。但是会降低索引选择性</li><li>如果是BLOB和TEXT数据或者是长字符串，必须定义前缀索引，因为MySQL不允许索引全文</li><li>最好尽可能使用足够长的前缀来提高索引选择性，不过短的省空间</li><li>MySQL无法使用前缀索引进行ORDER BY 和 GROUP BY 操作 </li></ul><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引是一种数据存储方式。它规定了数据在表中的物理存储顺序。意思是说索引项的顺序和表中记录的物理顺序一致。真实数据的物理顺序只能有一种，因此一张表最多只能穿件一个聚簇索引。</p><p>优点：</p><ol><li>把相关的数据保存在一起。</li><li>数据访问更快。聚簇索引将索引和数据保存在同一个B树当中</li><li>使用覆盖索引的查询可以直接使用叶节点的主键值</li></ol><p>缺点：</p><ol><li>提高了IO密集型应用的性能。但是如果数据全部放在内存当中，访问的顺序就没有那么重要了</li><li>插入的速度严重依赖于插入顺序。</li><li>更新聚簇索引列的代价很高</li><li>基于聚簇索引的表插入新行或者主键被更新导致需要移动行时，可能会产生页分裂的问题。</li><li>可能导致全表扫描变慢</li><li>二级索引（非聚簇索引）可能比想象的要大</li><li>二级索引访问需要两次索引查找</li></ol><p>最好避免使用随机的聚簇索引。在使用InnoDB的时候尽可能按主键顺序插入数据，并尽可能使用单调增加的聚簇键的值来插入新行</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：一个索引包含了所有要查询的字段的值。</p><p>优点：</p><ol><li>索引整体要比整一行数据行要小</li><li>相比于随机从磁盘读取每一行的数据，IO密集型查询需要更少的IO操作</li><li>许多数据引缓存索引的效率要比缓存数据的效率要高</li><li>覆盖索引有助于InnoDB表，因为其包含了聚簇索引。</li></ol><p>缺点：</p><ol><li>只能适用于B树索引，因为Hash索引，空间索引和全文索引都不存储键值。</li><li>不是索引的引擎都支持</li><li>可能会导致无法实现优化</li></ol><h4 id="索引作为排序"><a href="#索引作为排序" class="headerlink" title="索引作为排序"></a>索引作为排序</h4><p>条件：</p><ol><li>索引的列顺序和ORDER BY 子句的顺序完全一致</li><li>所有列的排序方向都一样</li><li>如果需要关联多张表，ORDER BY子句的字段必须全部为第一张表</li><li>ORDER BY必须满足索引的最左前缀要求（除非where或者Join子句中对列指定了常量）</li><li>索引列不能是范围条件或者是多个等于条件</li></ol><h4 id="包（前缀压缩）索引"><a href="#包（前缀压缩）索引" class="headerlink" title="包（前缀压缩）索引"></a>包（前缀压缩）索引</h4><p>MyISAM使用前缀索引来减少索引的大小。</p><p>压缩索引块的方式：先完全的存储第一个值，然后存储同样的前缀的字节数和不同的后缀的部分</p><p>前缀压缩的方式虽然能减少占用空间，但是会使某些操作变慢。MyISAM不支持二进制的二分查找，因此只能进行全局扫描。</p><p>对于CPU密集型的应用需要和磁盘之间进行权衡。对于IO密集型的应用，带来的好处更多</p><h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p>重复的索引应该避免。如显式地为主键创建索引。因为MySQL默认会为主键建立索引，因此无需显式地为主键创建索引。</p><p>冗余索引，有索引（A，B），则索引（A，C）为冗余索引。索引多会导致插入，更新，删除数据变慢。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以减少查询锁。这样会带来两个好处。</p><ol><li>减少锁定行时带来的开销</li><li>减少锁争用和提高并发性</li></ol><h4 id="设置索引的技巧"><a href="#设置索引的技巧" class="headerlink" title="设置索引的技巧"></a>设置索引的技巧</h4><h5 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h5><p>考虑表中的所有选项。设计索引时，不要只为现有的查询考虑需要哪一些索引，还要考虑对查询的优化。如发现某些查询需要建立新的索引，但是这个索引又会降低另一个查询的效率。这时就应该考虑是否能优化原来的索引。应该同时优化查询和索引。</p><h5 id="多范围查询"><a href="#多范围查询" class="headerlink" title="多范围查询"></a>多范围查询</h5><ol><li>尽量将需要使用范围查询的列放在索引的最后面（如果只存在一个范围查询条件）。也可以使用IN来代替范围查询。</li><li>如果有多个范围查询条件，可以考虑将范围查询转化为一个简单的等值比较。如为过去七天登录过的用户设置active列，active为1表示过去七天登录过。</li></ol><h5 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h5><ol><li>对于选择性非常低的列，可以添加特殊索引进行排序。</li><li>使用延迟关联，使用覆盖索引返回需要的主键，然后根据主键关联原表获取需要的行</li></ol><h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ol><li>单行访问时很慢的。</li><li>按顺序访问范围数据是很快的</li><li>索引覆盖查询是很快的</li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.cnblogs.com/qlqwjy/p/7770580.html">聚簇索引和非聚簇索引</a></p><p><a href="https://www.cnblogs.com/aspwebchh/p/6652855.html">数据库索引原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 表和索引维护</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%BB%B4%E6%8A%A4%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A1%A8/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E7%BB%B4%E6%8A%A4%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="维护表和索引"><a href="#维护表和索引" class="headerlink" title="维护表和索引"></a>维护表和索引</h3><h4 id="找到和修复表"><a href="#找到和修复表" class="headerlink" title="找到和修复表"></a>找到和修复表</h4><p>使用CHECK TABLE 来查找表是否损坏</p><p>使用REPAIR TABLE 来修复损坏的表</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><h4 id="减少碎片"><a href="#减少碎片" class="headerlink" title="减少碎片"></a>减少碎片</h4><p>碎片的类型：</p><ul><li>行碎片</li><li>行间碎片</li><li>剩余空间碎片</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 重构查询</title>
      <link href="2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>2021/05/01/SQL/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="重构查询的方法"><a href="#重构查询的方法" class="headerlink" title="重构查询的方法"></a>重构查询的方法</h3><h4 id="1-切分查询"><a href="#1-切分查询" class="headerlink" title="1. 切分查询"></a>1. 切分查询</h4><p>使用分而治之的思想。将大的查询切分成小的查询。</p><p>如果使用一个大的语句删除大量数据。很可能一次性锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小而重要的查询。如果将其切分成多个小的查询，可以尽可能小地影响服务器，减少锁的持有时间。</p><h4 id="2-分解关联查询"><a href="#2-分解关联查询" class="headerlink" title="2. 分解关联查询"></a>2. 分解关联查询</h4><p>分解关联的查询的好处：</p><ol><li>提高缓存效率</li><li>减少表锁的竞争</li><li>可以将表放在不同的服务器上，更好地扩展数据库</li><li>提高本身的查询效率</li><li>可以减少冗余行的查询</li><li>这样相当于在应用中实现了哈希关联，而不是嵌套循环关联</li></ol><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><a href="https://www.zhihu.com/question/68258877">复杂单表查询和多表关联查询</a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 简介</title>
      <link href="2021/05/01/middleware/Nginx/Nginx/"/>
      <url>2021/05/01/middleware/Nginx/Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="为什么使用Nginx"><a href="#为什么使用Nginx" class="headerlink" title="为什么使用Nginx"></a>为什么使用Nginx</h2><p>核心是支持高并发请求的同时保持高效的服务</p><ul><li>快：Nginx可以比其他Web服务器更快地响应请求</li><li>高扩展：它完全是由多个不同功能、 不同层次、 不同类型且耦合度极<br>低的模块组成</li><li>高可靠：Nginx的高可靠性来自于其核心框架代码<br>的优秀设计、 模块设计的简单性</li><li>低内存：10000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存</li><li>单机支持10w以上的并发连接</li><li>热部署：master管理进程与worker工作进程的分离设计， 使得Nginx能够提供热部署功能。支持不停止服务就更新配置项、 更换日志文件等功能。</li></ul><h2 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h2><ul><li>Nginx可以行的二进制文件</li><li>Nginx.conf 配置文件：控制Nginx的行为</li><li>access.log 访问日志：记录每一条http请求信息</li><li>error.log 错误日志：定位问题</li></ul><h2 id="Nginx进程间的关系"><a href="#Nginx进程间的关系" class="headerlink" title="Nginx进程间的关系"></a>Nginx进程间的关系</h2><p>Nginx时使用一个master进程来管理多个worker进程。 一般情况下， worker进程的数量与服务器上的CPU核心数相等。 每一个worker进程都是繁忙的， 它们在真正地提供互联网服务。master进程则很“清闲”， 只负责监控管理worker<br>进程。<strong>worker进程之间通过共享内存、 原子操作等一些进程间通信机制</strong>来实现负载均衡等功能</p><p><img src="/images/nginx%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="nginx进程间的关系"></p><h2 id="Nginx进程间的通讯方式"><a href="#Nginx进程间的通讯方式" class="headerlink" title="Nginx进程间的通讯方式"></a>Nginx进程间的通讯方式</h2><ol><li>信号</li><li>共享内存<ol><li>rbtree(红黑树)会用到(限速等)<ol><li>ngx_stream_limit_conn_module</li><li>ngx_http_limit_conn_module</li><li>ngx_stream_limit_req_module</li><li>http cache</li><li>ssl</li></ol></li><li>单链表会用到<ol><li>Ngx_http_upstream_zone_module</li><li>ngx_stream_upstram_zone_module</li></ol></li></ol></li></ol><p>引入的问题：</p><ol><li>锁</li><li>Slab内存管理器<h3 id="为什么需要按照masterworker方式配置同时启动多个进程呢"><a href="#为什么需要按照masterworker方式配置同时启动多个进程呢" class="headerlink" title="为什么需要按照masterworker方式配置同时启动多个进程呢"></a>为什么需要按照masterworker方式配置同时启动多个进程呢</h3></li><li>master进程可以是唯一的， 它仅专注于自己的纯管理工作， 为管理员提供命令行服务，包括诸如启动服务、 停止服务、 重载配置文件、 平滑升级程序等。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性。可以<strong>充分利用现在常见的SMP多核架构， 从而实现微观上真正的多核并发处理</strong>。当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心） ， 进程间切换的代价是最小的</li></ol><h4 id="为什么建议Nginx上的进程数与CPU核心数相等时"><a href="#为什么建议Nginx上的进程数与CPU核心数相等时" class="headerlink" title="为什么建议Nginx上的进程数与CPU核心数相等时"></a>为什么建议Nginx上的进程数与CPU核心数相等时</h4><p>若worker进程的数量多于CPU内核数， 那么会增大进程间切换带来的消耗（Linux是抢占式内核）。同时worker进程绑定指定的CPU内核</p><h4 id="为什么需要绑定到指定的内核"><a href="#为什么需要绑定到指定的内核" class="headerlink" title="为什么需要绑定到指定的内核"></a>为什么需要绑定到指定的内核</h4><p>假定每一个worker进程都是非常繁忙的， 如果多个worker进程都在抢同一个CPU， 那么这就会出现同步问题。 反之， 如果每一个worker进程都独享一个CPU， 就在内核的调度策略上实现了完全的并发。</p><h2 id="Nginx-Hash表使用的注意"><a href="#Nginx-Hash表使用的注意" class="headerlink" title="Nginx Hash表使用的注意"></a>Nginx Hash表使用的注意</h2><ol><li>只为静态的，不变的内容服务</li><li>hash表的bucket_size 需要考虑cpu cache line 的对齐问题</li></ol><h2 id="日志分析（goaccess）"><a href="#日志分析（goaccess）" class="headerlink" title="日志分析（goaccess）"></a>日志分析（goaccess）</h2><h2 id="Nginx文件缓存"><a href="#Nginx文件缓存" class="headerlink" title="Nginx文件缓存"></a>Nginx文件缓存</h2><p>文件缓存会在内存中存储以下3种信息：</p><ul><li>文件句柄，文件大小和修改次数</li><li>已经打开过的目录结构</li><li>没有找到或者没有权限操作的文件信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx反向代理</title>
      <link href="2021/05/01/middleware/Nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>2021/05/01/middleware/Nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><h2 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h2><p><img src="/images/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B.png"></p><h2 id="Proxy-pass模块规则"><a href="#Proxy-pass模块规则" class="headerlink" title="Proxy_pass模块规则"></a>Proxy_pass模块规则</h2><ul><li>URL必须以http://或者https://开头，接下来时域名，IP，unix socket地址或者upstream的名字。可以在域名或者IP之后加端口，最后可选的时URI</li><li>Nginx会根据当前URL参数当中携带URI与否，会导致发至上游请求的URL不同，<ul><li>不携带URI时，则直接将客户端请求中的URL直接发送到上游服务器。location参数后使用正则表达式、@名字时，应采用这种方式</li><li>携带URI时，会将location参数匹配上的一段替换为该URI</li></ul></li><li>更复杂的URL替换，可以在location内配置添加rewrite break语句</li></ul><h2 id="发送给上游的http请求头部包体处理"><a href="#发送给上游的http请求头部包体处理" class="headerlink" title="发送给上游的http请求头部包体处理"></a>发送给上游的http请求头部包体处理</h2><ul><li>请求行<ul><li>proxy method</li><li>proxy_http_version 1.0|1.1</li></ul></li><li>请求头部<ul><li>proxy_set_header</li><li>proxy_pass_request_headers on|off:是否把请求头部发给上游，默认时开启的</li></ul></li><li>请求体<ul><li>proxy_set_body</li><li>proxy_pass_request_body on|off:是否把请求体发给上游，默认时开启的</li></ul></li></ul><h2 id="接受客户端请求的包体"><a href="#接受客户端请求的包体" class="headerlink" title="接受客户端请求的包体"></a>接受客户端请求的包体</h2><h3 id="proxy-request-buffering-on-off"><a href="#proxy-request-buffering-on-off" class="headerlink" title="proxy_request_buffering on|off"></a>proxy_request_buffering on|off</h3><p>决定包体收完再转发还是边收边转发，默认时on</p><ul><li><p>on使用情景</p><ul><li>客户端网速较慢</li><li>上游服务并发处理能力地</li><li>适应高吞吐量场景</li></ul></li><li><p>off使用情景</p><ul><li>更及时的响应</li><li>降低Nginx读写磁盘的消耗</li><li>一旦发送内容，proxy_next_upstream功能失败</li></ul></li></ul><h3 id="客户端包体的接收"><a href="#客户端包体的接收" class="headerlink" title="客户端包体的接收"></a>客户端包体的接收</h3><h4 id="客户端包体的内存分配"><a href="#客户端包体的内存分配" class="headerlink" title="客户端包体的内存分配"></a>客户端包体的内存分配</h4><ul><li>若接收头部时已经接收完全部的包体，则不分配</li><li>若剩余待接收包体的长度小于client_body_buffer_size，则仅分配所需大小</li><li>分配client_body_buffer_size大小内存接收包体<ul><li>关闭包体缓存时，该内存上的内容及时发送给上游</li><li>打开包体缓存，该端内存用完时，写入临时文件，释放内存<h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3></li></ul></li><li>client_body_buffer_size：缓存body长度</li><li>client_max_body_size: 最大包体长度限制</li><li>client_body_temp_path：包体临时文件路径</li><li>client_body_in_file_only：包体必须保存在文件中</li><li>client_body_timeout：读取包体时超时</li></ul><h3 id="和上游服务器建立连接"><a href="#和上游服务器建立连接" class="headerlink" title="和上游服务器建立连接"></a>和上游服务器建立连接</h3><ul><li>TCP keepalive</li><li>HTTP keepalive</li></ul><h3 id="处理上游的响应头部"><a href="#处理上游的响应头部" class="headerlink" title="处理上游的响应头部"></a>处理上游的响应头部</h3><h4 id="proxy-ignore-headers"><a href="#proxy-ignore-headers" class="headerlink" title="proxy_ignore_headers"></a>proxy_ignore_headers</h4><p>作用：禁用某些响应头部改变Nginx的行为<br>可禁用功能的头部：</p><ul><li>X-Accel-Redirect: 由上游服务指定nginx内部重定向，控制请求的执行</li><li>X-Accel-Limit-Rate：由上游设置发往客户端的速度限制</li><li>X-Accel-Buffering：由上游控制是否缓存上游的响应</li><li>X-Accel-Charset：由上游控制Content-Type的Charset</li><li>缓存相关：<ul><li>X-Accel-Expires：设置响应在Nginx中缓存时间</li><li>Expires：控制Nginx缓存时间</li><li>Cache-Control：控制Nginx缓存时间</li><li>Set-cookie：响应中出现Set-Cookie则不缓存</li><li>Vary：响应中出现Vary：*则不缓存</li></ul></li></ul><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><h3 id="Nginx如何解决缓存失效时上游服务器的压力"><a href="#Nginx如何解决缓存失效时上游服务器的压力" class="headerlink" title="Nginx如何解决缓存失效时上游服务器的压力"></a>Nginx如何解决缓存失效时上游服务器的压力</h3><h4 id="合并回源请求，减轻峰值流量下的压力"><a href="#合并回源请求，减轻峰值流量下的压力" class="headerlink" title="合并回源请求，减轻峰值流量下的压力"></a>合并回源请求，减轻峰值流量下的压力</h4><p>使用proxy_cache_lock on|off，同一个时间，仅第一个请求发向上游，其他请求等待第一个响应返回或者超时后，使用缓存响应客户端。<br>可以通过proxy_cache_lock_timeout设置第一个返回响应的最大时间，到达时间后，直接向上游发送请求，<br>Proxy_cache_lock_age 上游请求返回响应的时间，到达该时间后再放行一个请求发送上游。</p><p><img src="//images/Nginx%E5%90%88%E5%B9%B6%E5%9B%9E%E6%BA%90%E8%AF%B7%E6%B1%82.png" alt="Nginx合并回源请求"></p><h4 id="减少回源请求，使用stale陈旧的缓存"><a href="#减少回源请求，使用stale陈旧的缓存" class="headerlink" title="减少回源请求，使用stale陈旧的缓存"></a>减少回源请求，使用stale陈旧的缓存</h4><p><img src="//images/Nginx%E5%90%88%E5%B9%B6%E5%9B%9E%E6%BA%90%E8%AF%B7%E6%B1%82.png" alt="Nginx合并回源请求"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 操作</title>
      <link href="2021/05/01/middleware/Nginx/Nginx%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/01/middleware/Nginx/Nginx%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -S reload 或</span><br><span class="line">kill -HUP 主进程号</span><br></pre></td></tr></table></figure><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><ol><li><p>备份旧的可执行文件</p></li><li><p>给主进程发USER2信号：执行完后新的主进程和旧的同时存在，会将新的请求/连接给到新的主进程中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 9944</span><br></pre></td></tr></table></figure></li><li><p>给旧的主进程发送WINCH信号：通知旧的主进程优雅的关闭旧的work进程(执行完任务后关闭)，旧的主进程还在，以便做版本回退。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 9944</span><br></pre></td></tr></table></figure></li><li><p>给旧的主进程发送QUIT信号，使其关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT 9944</span><br></pre></td></tr></table></figure></li><li><p>如果需要进行版本回退，可以给旧的主进程发HUP命令，nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。然后再优雅的关闭新的主进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP 9944</span><br><span class="line">kill -QUIT 新的主进程pid</span><br></pre></td></tr></table></figure></li></ol><h2 id="重启日志文件（日志文件分割）"><a href="#重启日志文件（日志文件分割）" class="headerlink" title="重启日志文件（日志文件分割）"></a>重启日志文件（日志文件分割）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reopen </span><br><span class="line">或者 kill -USR1 2030</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 负载均衡</title>
      <link href="2021/05/01/middleware/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2021/05/01/middleware/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h1><h2 id="Nginx-负载均衡特点"><a href="#Nginx-负载均衡特点" class="headerlink" title="Nginx 负载均衡特点"></a>Nginx 负载均衡特点</h2><p>Nginx并不会立刻转发到上游服务器，而是先把用户的请求（包括HTTP包体） 完整地接收到Nginx所在服务器的硬盘或者内存中，然后再向上游服务器发起连接， 把缓存的客户端请求转发到上游服务器。（接收到完整的客户端请求（如1GB的文件） 后， 才会与上游服务器建立连接转发请求）。</p><p>缺点：延长了一个请求的处理时间，并增加了用于缓存请求内容的内存和磁盘空间<br>优点：降低了上游服务器的负载， 尽量把压力放在Nginx服务器上<br><img src="/images/%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84Nginx.png" alt="作为静态Web服务器与反向代理服务器的Nginx"></p><p><img src="/images/Nginx%E4%BD%9C%E4%B8%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="Nginx作为反向代理服务器时转发请求的流程"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>upstream块：upstream块定义了一个上游服务器的集群， 便于反向代理中的proxy_pass使用</li><li>ip_hash：我们可能会希望来自某一个用户的请求始终落到固定的一台上游服务器中。如果同一个用户的请求任意地转发到集群中的任一台上游服务器中， 那么每一台上游服务器都有可能会缓存同一份信息， 这既会造成资源。的浪费， 也会难以有效地管理缓存信息，这样确保了<strong>同一个客户端的请求只会转发到指定的上游服务器中</strong>。</li><li>proxy_pass:此配置项将当前请求反向代理到URL参数指定的服务器上， URL可以是主机名或IP地址加端口的形式。</li><li>proxy_method:配置项表示转发时的协议方法名</li><li>proxy_hide_header:Nginx会将上游服务器的响应转发给客户端， 可以任意地指定哪些HTTP头部字段不能被转发。</li><li>proxy_pass_header:与proxy_hide_header 相反</li><li>proxy_pass_request_headers：作用为确定是否转发HTTP头部。</li><li>proxy_redirect：当上游服务器返回的响应是重定向或刷新请求（ 如HTTP响应码是301或者302） 时，proxy_redirect可以重设HTTP头部的location或refresh字段</li><li>proxy_next_upstream：此配置项表示当向一台上游服务器转发请求出现错误时， 继续换一台上游服务器处理这个请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 配置</title>
      <link href="2021/05/01/middleware/Nginx/Nginx%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
      <url>2021/05/01/middleware/Nginx/Nginx%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h1><h2 id="配置语法："><a href="#配置语法：" class="headerlink" title="配置语法："></a>配置语法：</h2><ol><li>配置文件由指令和指令块构成</li><li>每条指令以; 解为，指令与参数之前用空格分割</li><li>指令块以{}大括号将多条指令组织在一起</li><li>include语句允许组合多个配置文件以提升可维护性</li><li>使用#符号添加注释，提高可读性</li><li>使用$符号使用变量</li><li>部分指令的参数支持正则表达式</li></ol><h2 id="优化性能的配置项"><a href="#优化性能的配置项" class="headerlink" title="优化性能的配置项"></a>优化性能的配置项</h2><ol><li>worker进程个数：worker_processes number</li><li>worker进程绑定指定CPU：worker_cpu_affinity cpumask[cpumask…(0001)]</li><li>SSL硬件加速：ssl_engine device</li><li>系统调用gettimeofday的执行频率[^1]:timer_resolution t</li><li>worker进程优先级：worker_priority nice</li></ol><h2 id="事件类配置项"><a href="#事件类配置项" class="headerlink" title="事件类配置项"></a>事件类配置项</h2><ol><li>是否打开accept锁：accept_mutex[on|off][^2]</li><li>accept锁后到真正建立连接之间的延迟时间：accept_mutex_delay 500ms</li><li>批量建立新连接：multi_accept[on|off]</li><li>选择事件模型：use[kqueue|rtsig|epoll|/dev/poll|select|poll|eventport] [^3]</li><li>每个worker的最大连接数:worker_connections number</li></ol><h2 id="请求转发配置"><a href="#请求转发配置" class="headerlink" title="请求转发配置"></a>请求转发配置</h2><h3 id="配置块-server"><a href="#配置块-server" class="headerlink" title="配置块 server"></a>配置块 server</h3><ol><li>监听端口</li><li>主机名称：server_name name[…]</li><li>service name散列桶的大小[^4]：server_names_hash_bucket_size</li><li>service name散列的大小：server_names_hash_max_size</li><li>重定向主机名称的处理：server_name_in_redirect on|off</li><li>Location:</li></ol><h2 id="内存及磁盘资源的分配配置"><a href="#内存及磁盘资源的分配配置" class="headerlink" title="内存及磁盘资源的分配配置"></a>内存及磁盘资源的分配配置</h2><ol><li>HTTP包体只存储到磁盘文件中：client_body_in_file_only on|clean|off;</li><li>HTTP包体尽量写入到一个内存buffer中[^5]：client_body_in_single_buffer on|off;</li><li>存储HTTP头部的内存buffer大小：client_header_buffer_size size</li><li>存储超大HTTP头部的内存buffer大小[^6]：large_client_header_buffers number size</li><li>存储HTTP包体的内存buffer大小[^7]：client_body_buffer_size 8k/16k</li><li> HTTP包体的临时存放目录</li><li> connection_pool_size</li><li> request_pool_size</li></ol><h2 id="网络连接设置"><a href="#网络连接设置" class="headerlink" title="网络连接设置"></a>网络连接设置</h2><ol><li>读取HTTP头部的超时时间：client_header_timeout time</li><li>读取HTTP包体的超时时间：client_body_timeout time</li><li>发送响应的超时时间：send_timeout time</li><li>reset_timeout_connection[^8]：reset_timeout_connection on|off</li><li>lingering_close[^9]：lingering_close off|on|always</li><li>lingering_timeout</li><li>lingering_time</li><li>对某些浏览器禁用keepalive功能:keepalive_disable[msie6|safari|none]</li><li>keepalive超时时间:keepalive_timeout time</li><li>一个keepalive长连接上允许承载的请求最大数:keepalive_requests n</li><li>确定对keepalive连接是否使用TCP_NODELAY选项:tcp_nodelay on|off</li><li>按HTTP方法名限制用户请求:limit_except method…{…}</li><li>HTTP请求包体的最大值:client_max_body_size size</li><li> 对请求的限速:limit_rate speed</li><li> limit_rate_after:Nginx向客户端发送的响应长度超过limit_rate_after后才开始限速</li></ol><h2 id="文件操作设置"><a href="#文件操作设置" class="headerlink" title="文件操作设置"></a>文件操作设置</h2><ol><li>sendfile系统调用[^10]：sendfile on|off;</li><li>AIO系统调用[^11]:aio on|off;</li><li>directio[^12]：directio size|off;</li><li>directio对齐：directio_alignment size</li><li>打开文件缓存：open_file_cache max=N[inactive=time]|off;</li><li>是否缓存打开文件错误的信息：open_file_cache_errors on|off;</li><li>不被淘汰的最小访问次数：open_file_cache_min_uses number;</li><li>检验缓存中元素有效性的频率：open_file_cache_valid time;</li></ol><h2 id="客户端请求的特殊处理"><a href="#客户端请求的特殊处理" class="headerlink" title="客户端请求的特殊处理"></a>客户端请求的特殊处理</h2><ol><li>忽略不合法的HTTP头部：ignore_invalid_headers on|off</li><li>HTTP头部是否允许下划线：underscores_in_headers on|off;</li><li>对If-Modified-Since头部的处理策略[^13]：if_modified_since[off|exact|before]</li><li>文件未找到时是否记录到error日志:log_not_found on|off;</li><li>是否合并相邻的“/”：merge_slashes on|off;</li><li>设置DNS名字解析服务器的地址：resolver address…;</li><li>DNS解析的超时时间：resolver_timeout time;</li><li>是否在响应的Server头部中标明Nginx版本：server_tokens on|off;</li></ol><p>[^1]:gettimeofday:每次内核的事件调用（如epoll、 select、 poll、 kqueue等） 返回时， 都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟<br>[^2]:accept_mutex是Nginx的负载均衡锁,ccept_mutex这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。<br>[^3]:Nginx会自动使用最适合的事件模型<br>[^4]:server name是存储在散列表里的<br>[^5]:如果HTTP包体超过了client_header_buffer_size的大小，包体还是会写入到磁盘文件<br>[^6]:如果HTTP请求行的大小超过配置值，则返回”Request URI too large”(414)<br>[^7]:HTTP包体会先接收到指定的这块缓存中， 之后才决定是否写入磁盘<br>[^8]:连接超时后将通过向客户端发送RST包来直接重置连接。 这个选项打开后， Nginx会在某个连接超时后， 不是使用正常情形下的四次握手关闭TCP连接， 而是直接向用户发送RST重置包， 不再等待用户的应答， 直接释放Nginx服务器上关于这个套接字使用的所有缓存.一般关闭<br>[^9]:该配置控制Nginx关闭用户连接的方式。 always表示关闭用户连接前必须无条件地处理连接上所有用户发送的数据。 off表示关闭连接时完全不管连接上是否已经有准备就绪的来自用户的数据。 on是中间值， 一般情况下在关闭连接前都会处理连接上的用户发送的数据<br>[^10]:启用Linux上的sendfile系统调用来发送文件， 它减少了内核态与用户态之间的两次内存复制， 这样就会从磁盘中读取文件后直接在内核态发送到网卡设备<br>[^11]:表示是否在FreeBSD或Linux系统上启用内核级别的异步文件I/O功能,与sendfile功能是互斥的<br>[^12]:在FreeBSD和Linux系统上使用O_DIRECT选项去读取文件， 缓冲区大小为size，通常对大文件的读取速度有优化作用。与sendfile功能是互斥的。<br>[^13]:Web浏览器一般会在客户端本地缓存一些文件，并存储当时获取的时<br>间。 这样，下次向Web服务器获取缓存过的资源时， 就可以用If-Modified-Since头部把上次获取的时间捎带上， 而if_modified_since将根据后面的参数决定如何处理If-Modified-Since头部.</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 问题集</title>
      <link href="2021/05/01/middleware/Nginx/Nginx%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/01/middleware/Nginx/Nginx%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-如何保证所有worker进程之上的客户端请求数尽量接近。"><a href="#Nginx-如何保证所有worker进程之上的客户端请求数尽量接近。" class="headerlink" title="Nginx 如何保证所有worker进程之上的客户端请求数尽量接近。"></a>Nginx 如何保证所有worker进程之上的客户端请求数尽量接近。</h2><p><strong>使用accept_mutex锁</strong>。accept_mutex是Nginx的负载均衡锁,accept_mutex这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接,当某一个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时， 会大大地减小该worker进程试图建立新TCP连接的机会， 以此实现所有worker进程之上处理的客户端请求数尽量接近。</p><h2 id="Nginx-如何处理一个HTTP请求"><a href="#Nginx-如何处理一个HTTP请求" class="headerlink" title="Nginx 如何处理一个HTTP请求"></a>Nginx 如何处理一个HTTP请求</h2><p>Nginx会取出header头中的Host， 与每个server中的。server_name进行匹配， 以此决定到底由哪一个server块来处理这个请求。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>如果Host与多个server块中的server_name都匹配， 这时就会根据匹配优先级来选择实际处理的server块。<br>匹配优先级：</p><ol><li>首先选择所有字符串完全匹配的server_name</li><li>其次选择通配符在前面的server_name</li><li>再次选择通配符在后面的server_name</li><li>最后选择使用正则表达式才匹配的server_name</li></ol><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>Nginx对于每个建立成功的<strong>TCP连接</strong>会预先分配一个内存池.connection_pool_size配置项将指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。<br>Nginx开始处理HTTP请求时， 将会为<strong>每个请求</strong>都分配一个内存池，request_pool_size指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。<br>TCP连接关闭时会销毁connection_pool_size指定的连接内存池， HTTP请求结束时会销毁request_pool_size指定的HTTP请求内存池， 但它们的创建、 销毁时间并不一致， </p><h2 id="Nginx-location"><a href="#Nginx-location" class="headerlink" title="Nginx location"></a>Nginx location</h2><p>location会尝试根据用户请求中的URI来匹配上面的/uri表达式。location是有顺序的， 当一个请求有可能匹配多个location时， 实际上这个请求会被第一个location处理。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ol><li>= 表示把URI作为字符串， 以便与参数中的uri做完全匹配</li><li>~ 表示匹配URI时是字母大小写敏感的。</li><li>~* 表示匹配URI时忽略字母大小写问题。</li><li>^~ 表示匹配URI时只需要其前半部分与uri参数匹配即可。</li><li>@ 表示仅用于Nginx服务内部请求之间的重定向， 带有@的location不直接处理用户请求</li></ol><h2 id="alisa和root的差别"><a href="#alisa和root的差别" class="headerlink" title="alisa和root的差别"></a>alisa和root的差别</h2><ol><li>使用alias时，目录名后面一定要加”/“。</li><li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用</li><li>alias只能位于location块中</li><li>root的处理结果是：root路径 ＋ location路径，而alisa会使用alias路径替换location路径</li></ol><h2 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h2><ol><li>Nginx 事件循环机制</li><li>Nginx 处理Http请求流程</li><li>Nginx 如何做热部署</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 简介</title>
      <link href="2021/05/01/middleware/Redis/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>2021/05/01/middleware/Redis/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis优缺点"><a href="#Redis优缺点" class="headerlink" title="Redis优缺点"></a>Redis优缺点</h2><p>Redis的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过10万次读写操作。Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><p>优点：</p><ul><li>读写性能优异，Redis能读的速度是110000次/s，写的速度是81000次/s</li><li>支持数据持久化，AOF和RDB两种持久化方式</li><li>支出事务，Redis所有操作都是原子性的</li><li>数据结构丰富，除了支持String类型外，还支持hash、set、zset、list等数据结构</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li></ul><p>缺点：</p><ul><li>数据库容量受物理内存限制，不能用作海量数据的高性能读写，使用场景局限于较小数据量的高性能操作和运算</li><li>不具有自动容错和恢复功能，主机从机宕机会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复</li><li>主机宕机，宕机前游部分数据未能及时同步到从机，切换IP后会引入数据不一致性问题，降低系统可用性</li><li>Redis较难支持在线扩容，在容量达到在线扩容会变得很复杂，因此在上线时必须确保有足够的空间，这样会对空间造成很大的浪费</li></ul><h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul><li>计数器</li><li>缓存(会话缓存，全页缓存)</li><li>查找表</li><li>消息队列(不推荐)</li><li>分布式锁</li><li>内存数据库</li><li>请求限流，redis+lua<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2>|数据类型|可以存储的值|应用场景|<br>|String|字符串、整数或者浮点数| 适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等|<br>|List|列表|因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等，类似粉丝列表，文章的评论列表|<br>|Set|无序集合|可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作，比如交集，可以把两个人的粉丝列表整一个交集|<br>|Hash|包含键值对的无序散列表|一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等|<br>|Zset|有序集合|去重但可以排序，如获取排名前几名的用户|<h2 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h2>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制.当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3>RDB：是Redis DataBase缩写快照，是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。<br>优点：</li><li>只有一个文件dump.rdb，方便持久化</li><li>容灾性号，一个文件可以保存到安全的磁盘</li><li>性能最大化，fork子进程赖完成写操作，主进程继续处理命令</li><li>相对于数据集大时，比AOF的启动效率更高</li></ul><p>缺点：</p><ol><li>数据安全性低，RDB时间隔一段时间持久化，如果持久化期间，Redis发生故障，会使得数据丢失。<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</li></ol><p>优点：</p><ul><li>数据安全，aof 持久化可以配置使得每进行一次命令操作就记录到aof文件中一次</li><li>通过append模式写文件，即使中途宕机，可以用过redis-check-aof工具解决数据一致性问题</li><li>AOF机制的rewrite模式及，AOF 文件没被 rewrite 之前可以删除其中的某些命令</li></ul><p>缺点：</p><ul><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低</li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>可以设置Redis中缓存Key的过期时间<br>过期策略分为一下三种</p><ul><li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量</li><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存</li><li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><h3 id="全局键空间选择性移除"><a href="#全局键空间选择性移除" class="headerlink" title="全局键空间选择性移除"></a>全局键空间选择性移除</h3><p>当内存不足以容纳新写入数据时，会根据策略进行对应的处理</p><ul><li>noeviction：，<strong>新写入操作会报错</strong></li><li>allkeys-lru：在键空间中，移除最近最少使用的key</li><li>allkeys-random：在键空间中，随机移除某个key</li></ul><h3 id="设置过期时间的键空间选择性移除"><a href="#设置过期时间的键空间选择性移除" class="headerlink" title="设置过期时间的键空间选择性移除"></a>设置过期时间的键空间选择性移除</h3><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，会根据策略进行对应的处理</p><ul><li>volatile-lru：<strong>移除最近最少使用的过期key</strong></li><li>volatile-random：，<strong>随机移除某个设置了过期时间key</strong></li><li>volatile-ttl：当<strong>有更早过期时间的key优先移除</strong></li></ul><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结就是<strong>redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令</strong></p><h3 id="事务的三个阶段"><a href="#事务的三个阶段" class="headerlink" title="事务的三个阶段"></a>事务的三个阶段</h3><ol><li>事务开始MULTI：开启一个事务，MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行</li><li>命令入队</li><li>事务执行EXEC：执行所有事务块内的命令。</li></ol><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>事务原语：MULTI、EXEC、DISCARD和WATCH<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li>redis 不支持回滚</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行</li></ol><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令</li><li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil</li><li>调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出</li><li>UNWATCH命令可以取消watch对所有key的监控</li></ul><h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="哨兵-sentinel-模式"><a href="#哨兵-sentinel-模式" class="headerlink" title="哨兵(sentinel)模式"></a>哨兵(sentinel)模式</h3><p><img src="/images/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="Redis哨兵模式"><br>哨兵具有以下功能</p><ul><li>集群监控：负责监控 redis master 和 slave 进程是否正常工作</li><li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果 master node挂掉了，会自动转移到 slave node上。判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master地址</li></ul><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性</li><li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性</li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><h3 id="服务端路由查询-官方Redis-Cluster方案"><a href="#服务端路由查询-官方Redis-Cluster方案" class="headerlink" title="服务端路由查询(官方Redis Cluster方案)"></a>服务端路由查询(官方Redis Cluster方案)</h3><p>Redis Cluster是一种服务端Sharding技术。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p><p> redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是加1w的端口号。用于节点通信，进行故障检测、配置更新、故障转移授权，比如16379</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点</li><li>同一分片多个节点间的数据不保持一致性</li><li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li><li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li></ol><h4 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 问题集</title>
      <link href="2021/05/01/middleware/Redis/Redis%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/01/middleware/Redis/Redis%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-问题集"><a href="#Redis-问题集" class="headerlink" title="Redis 问题集"></a>Redis 问题集</h1><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol><li>完全基于内存，绝大部分请求时纯粹的基于内存操作</li><li>数据结构简单，对数据的操作也相对简单</li><li>采用单线程，避免不必要的上下文切换和竞争条件，不存在多进程或者多线程的切换消耗CPU，不必考虑各种锁的问题，不存在加锁释放锁的操作，同时避免因为死锁而导致的性能消耗</li><li>使用多路I/O，非阻塞IO</li><li>Redis直接构建里VM机制。如果使用一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ol><h2 id="持久化数据和缓存如何扩容"><a href="#持久化数据和缓存如何扩容" class="headerlink" title="持久化数据和缓存如何扩容"></a>持久化数据和缓存如何扩容</h2><ul><li>如果Redis被当做缓存使用，使用<strong>一致性哈希</strong>实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h2 id="Redis事务支持隔离性吗？"><a href="#Redis事务支持隔离性吗？" class="headerlink" title="Redis事务支持隔离性吗？"></a>Redis事务支持隔离性吗？</h2><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p><h2 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h2><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2021/05/01/operation_system/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
      <url>2021/05/01/operation_system/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>功能</p><ul><li>内存空间的分配和回收</li><li>地址转换</li><li>内存空间的扩充</li><li>存储保护<h3 id="用户源程序变为内存中的执行程序的步骤"><a href="#用户源程序变为内存中的执行程序的步骤" class="headerlink" title="用户源程序变为内存中的执行程序的步骤"></a>用户源程序变为内存中的执行程序的步骤</h3></li></ul><ol><li>编译</li><li>链接<ol><li>静态链接</li><li>装入时动态链接</li><li>运行时动态链接</li></ol></li><li>装入<ol><li>绝对装入</li><li>可重定位装入</li><li>动态运行时装入</li></ol></li></ol><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响</p><ol><li>在CPU设置一对上下限寄存器，存放用户作业主存的上下限</li><li>采用重定位寄存器(基址寄存器)和界地址寄存器(限长寄存器)来实现。冲顶文寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值<br><img src="/images/%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="重定位"></li></ol><h3 id="扩充内存的方法"><a href="#扩充内存的方法" class="headerlink" title="扩充内存的方法"></a>扩充内存的方法</h3><ol><li>覆盖<ul><li>目的：在较小的可用内存中运行较大的程序<br>用于同一进程或程序中的</li></ul></li><li>交换<ul><li>目的：增加并发运行的程序数目，并给用户提供适当的响应时间<br>作用在不同进程之间的</li></ul></li></ol><h3 id="内存的分配方式"><a href="#内存的分配方式" class="headerlink" title="内存的分配方式"></a>内存的分配方式</h3><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ol><li>单一连续分配<br>有内部碎片</li><li>固定分区分配<br>有内部碎片</li><li>动态分区分配<br>通过紧凑来解决外部碎片，没有内部碎片<br>算法：<ol><li>首次适应。找第一个满足要求的分区</li><li>最佳适应。按容量递增，找第一个满足要求的分区</li><li>最坏适应。找满足要求的最大分区</li><li>邻近适应。从上次查找的位置开始找第一个满足要求的分区</li></ol></li></ol><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h5 id="基本分页存储管理方式-页式存储管理"><a href="#基本分页存储管理方式-页式存储管理" class="headerlink" title="基本分页存储管理方式(页式存储管理)"></a>基本分页存储管理方式(页式存储管理)</h5><ol><li>基本地址变换机构<br>借助页表实现(实质上是页号地址转化为块号地址)<br><img src="/images/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="基本地址变换机构"><br>存在问题：<ol><li>地址转换必须足够快，否则访存速度会降低</li><li>页变不能太大，否则内存利用率回降低</li></ol></li><li>具有快表的地址变换机构<br><img src="/images/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="快表地址变换机构"><br>快表相当于页表的一个缓存，拿到页号之后，先查找快表</li><li>两级页表<h5 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h5></li><li>基本分段地址变换机构(实质上通过基址和偏移量寻找物理地址)<br><img src="/images/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="基本分段地址变换机构"></li><li>段页式内存管理方式<br><img src="/images/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="段页式内存管理方式"><ol><li>通过段表查到页表的其实地址和长度，然后通过页表找到页帧号，最后形成物理地址</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="2021/05/01/operation_system/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>2021/05/01/operation_system/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>内存管理策略的缺陷</p><ol><li>作业必须一次性全部装入内存</li><li>作业被装入内存后，一直驻留在内存中。</li></ol><p>虚拟内存的大小决定因素</p><ol><li>虚拟内存的大小小于内存容量和外存容量之和</li><li>虚拟内存的大小小于计算机的地址位数能容纳的最大容量</li></ol><h3 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h3><p>原理：采用连续分配方式时，会使部分内存空间处于暂时或者“永久”的空闲状态，造成内存资源的浪费，也无法重逻辑上扩大内存容量。因此虚拟内存建立在离散分配的内存管理方式上<br>实现方式：</p><ol><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ol><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>页表：将虚拟地址空间映射到物理地址空间的数据结构结构<br>不同于基本分页系统的页表。请求分页系统在一个作业运行前不要求全部一次性调入内存。必然会出现访问的页面不在内存的情况。因此在请求页表项中添加了四个字段<br><img src="/images/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" alt="请求分页系统页表项"><br>新增的字段为</p><ul><li>状态位P：指示该页是否调入内存</li><li>访问字段A：记录本页在一段时间内被访问的次数</li><li>修改位M：标识该页在调入内存后是否有被修改过</li><li>外存地址：指出该页的外存上的地址</li></ul><h3 id="换页的置换算法"><a href="#换页的置换算法" class="headerlink" title="换页的置换算法"></a>换页的置换算法</h3><ol><li>最佳置换算法(OPT)</li><li>先进先出算法(FIFO)</li><li>最近最久未使用算法(LRU)</li><li>时钟置换算法(CLOCK)，也叫最近未用算法(NRU)<ul><li>简单CLOCK算法，添加一个使用位</li><li>改进的CLOCK算法<br>每一帧的情况有四种<ul><li>最近未被访问，也未被修改</li><li>最近未被访问，但被修改</li><li>最近被访问，但未被修改</li><li>最近被访问，被修改<br>置换的优先级越来越低</li></ul></li></ul></li></ol><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ol><li>驻留集大小<ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul></li><li>调入页面时机<ul><li>预调页策略</li><li>请求调页策略</li></ul></li><li>从何处调页页面<br>外存分为两个部分：采用连续分配方式的对换区，采用离散分配方式的文件区<ul><li>系统拥有足够的对换区空间</li><li>系统缺少足够的对换区空间</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="2021/05/01/operation_system/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6/"/>
      <url>2021/05/01/operation_system/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>文件的结构</p><ul><li>数据项</li><li>记录</li><li>文件</li></ul><p>文件的结构</p><ol><li>无结构文件</li><li>有结构文件<ol><li>顺序文件<ol><li>串结构</li><li>顺序结构：与关键字有关</li></ol></li><li>索引文件</li><li>索引顺序文件</li><li>直接文件或散列文件</li></ol></li></ol><p>目录的结构<br>组成</p><ol><li>文件控制块(FCB)<br>作用，存放控制文件需要的各种信息的数据结构<br>主要包括<ul><li>基本信息：文件名，文件的物理位置、逻辑结构、物理结构</li><li>存取控制信息：存取权限</li><li>使用信息：文件建立的时间、修改时间</li></ul></li><li>索引节点<br>目录结构</li><li>单机目录结构</li><li>两级目录结构</li><li>多级目录结构</li><li>无环图目录结构</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理机调度</title>
      <link href="2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>调度的原因：合理的处理计算机软件硬件资源</p><h3 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h3><p>调度层次</p><ul><li>作业调度</li><li>中级调度(内存调度)</li><li>进程调度</li></ul><p>调度层次的关系<br>作业调度为进程活动做准备，中级调度将不能运行的进程挂起。中级调度处于作业调度和进程调度之间。</p><p>不能进行进程调度和切换的情况</p><ol><li>处理中断</li><li>处于操作系统内核程序的临界区，且破坏临界资源的使用规则</li><li>完全屏蔽中断的原子操作<br>应该进行进程调度和切换的情况</li><li>引起调度条件，且当前进程无法继续运行下去时</li><li>当中断处理结束或自陷处理结果后，返回中断进程的用户态程序执行现场前。</li></ol><p>调度方式</p><ol><li>非剥夺调度方式</li><li>剥夺调度方式</li></ol><h3 id="调度的原则"><a href="#调度的原则" class="headerlink" title="调度的原则"></a>调度的原则</h3><p>考虑因素： CPU利用率，系统吞吐量，周转时间，等待时间，响应时间<br>调度算法</p><ol><li>先来先服务(FCFS).属于不可剥夺</li><li>短作业优先(SJF)<br>对长作业不利</li><li>优先级调度算法。可剥夺也可不剥夺</li><li>高响应比优先调度算法<br>$$ 响应比R = \frac{等待时间 + 要求服务时间}{要求服务时间}$$</li><li>时间片轮转调度算法<br>确定时间片的长短的因素：系统响应时间、就绪队列中的进程数目和系统的处理能力</li><li>多级反馈队列调度算法<br>优点：<ul><li>终端型作业：短作业优先</li><li>短批处理作业：周转时间优先</li><li>长批处理作业：经过前几个队列得到部分执行，不会长期得不到处理。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%AD%BB%E9%94%81/"/>
      <url>2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是不安全状态的一种。系统进入不安全状态就有可能回进入死锁状态</p><h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ol><li>系统资源的竞争</li><li>进程推进顺序非法</li><li>死锁产生的必要条件<ol><li>互斥条件<br>解决：允许系统资源共享使用</li><li>不可剥夺条件<br>解决：释放已经保持的所有资源，待以后需要再重新申请</li><li>请求和保持条件<br>解决：采用预先静态分配方法</li><li>循环等待条件<br>解决：采用顺序资源分配法</li></ol></li></ol><h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><ol><li>预防死锁<br>破坏死锁的四个条件</li><li>避免死锁<br>允许进程动态地申请资源，但在资源分配前，先计算此次资源分配的安全性<br>算法：<strong>银行家算法</strong></li><li>死锁的检测<br>死锁的条件是当前资源分配图是不可完全简化的<br>死锁定理：(简化当前资源分配图)<ol><li>找出即不阻塞又不孤点的进程</li><li>该进程释放所有资源</li></ol></li><li>死锁的解除<ol><li>资源剥夺法</li><li>撤销进程法</li><li>进程回退法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>目的：为了更好的使多道程序并发执行，提高资源利用率和系统吞吐量，增加程序的并发性<br>线程是处理机执行的最基本的执行单元</p><h3 id="线程的属性："><a href="#线程的属性：" class="headerlink" title="线程的属性："></a>线程的属性：</h3><ol><li>线程是一个轻型实体，不拥有资源。但每个线程都应有一个唯一标识符和一个线程控制块</li><li>不同的线程可以执行相同的程序。同一个服务程序被不同的用户调用时，会创建不同的线程</li><li>同一进程中的各个线程共享该进程的所有资源</li><li>线程是处理机的独立调度单位</li></ol><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><p>用户级线程和内核级线程<br>多线程模型：</p><ul><li>多对一：多个用户级线程银蛇到一个内核级线程</li><li>一对一</li><li>多对多</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>目的：更好地描述和控制程序并发执行<br>主要部分</p><ul><li>程序段：进程完成的功能。类似于工人</li><li>数据：程序在执行时所需要的数据。类似于原材料</li><li>PCB：包含进程的描述信息和控制信息。是进程存在的唯一标志。类似于管理员</li><li>进程是系统进行资源分配和调度的一个独立单位。这里的系统资源是指处理机、存储器和其他设备服务于进程的“时间”。<br>进程是一个动态的、过程性的概念</li></ul><p>特征：</p><ol><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ol><p>进程的状态</p><ol><li>运行态</li><li>就绪态</li><li>阻塞态</li><li>创建态</li><li>结束态</li></ol><p>进程状态之间的转换<br><img src="/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"></p><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p>父进程与子进程</p><ul><li>子进程被撤销时，资源归还给父进程</li><li>父进程被撤销时，必须同时撤销所有子进程<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4>PCB是进程实体的一部分，是进程唯一存在的唯一个标志。<br>过程</li></ul><ol><li>为新进程分配一个唯一的进程标识号(PID)，并申请空白的PCB</li><li>为进程分配资源，分配程序和数据以及用户栈分配必要的内存空间</li><li>初始化PCB，包括初始化标志信息、处理机状态信息和控制信息。设置进程优先级</li><li>如果就绪队列能接纳新进程，就插入到就绪队列中</li></ol><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ol><li>根据终止进程的标识号，检索PCB，读出改进程的状态</li><li>若进程处理执行状态，立即终止该进程的执行，将处理机分配给其他进程</li><li>若还有子进程，则应该将所有子进程终止</li><li>将所有资源归还给父进程或者是操作系统</li><li>将PCB从所在队列里删除</li></ol><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ol><li>找到被阻塞进程的标记号对应的PCV</li><li>若进程处于运行状态，则保留现场，将其转态转为阻塞状态。</li><li>将PCB插入响应时间的等待等待队列中</li></ol><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><ol><li>在等待队列中找到相应进程的PCB</li><li>将其在等待队列一出去，并置为就绪状态</li><li>将该PCB插入就绪序列中。<h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4></li><li>保存现场</li><li>更新PCB信息</li><li>将PCB移入相应队列</li><li>选择另外一个进程，更新PCB</li><li>更新内存管理的数据结构</li><li>恢复现场</li></ol><h3 id="进程通信-IPC，InterProcess-Communication"><a href="#进程通信-IPC，InterProcess-Communication" class="headerlink" title="进程通信(IPC，InterProcess Communication)"></a>进程通信(IPC，InterProcess Communication)</h3><p>方式</p><ol><li>共享存储：允许两个或多个进程共享一个给定的存储区</li><li>信号量：它是一个计数器，用于为多个进程提供共享数据对象的访问</li><li>消息队列</li><li>管道<br>通信道使用的是半双工机制,管道通信必须提供的能力： 互斥、同步和确定对方的存在。<ol><li>无名管道<br>管同时管道只能在具有公共祖先的两个进程之间使用。</li><li>命名管道(FIFO)<br>客户进程-服务器进程应用程序中，FIFO用作汇聚点，在客户进程和服务器进程二者之间传递数据。</li></ol></li><li>Socket</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程同步</title>
      <link href="2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>2021/05/01/operation_system/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>对临界资源的访问必须需要互斥地进行<br>访问过程</p><ol><li>进入区。检查是否可以进入临界区。可以则设置访问临界区的标志</li><li>临界区。访问临界资源的代码</li><li>退出区。将访问临界区的标志清除</li><li>剩余区</li></ol><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><p>同步也称为直接制约关系。指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某个位置上协调他们的工作次序而等待、传递信息所产生的制约关系</p><p>互斥也成为简介制约关系。当一个进程进入临界区使用临界资源，另外一个进程必须等待占用临界资源的进程退出临界区后，才能去访问</p><h4 id="同步机制的准则"><a href="#同步机制的准则" class="headerlink" title="同步机制的准则"></a>同步机制的准则</h4><ol><li>空闲让进</li><li>忙则等待</li><li>有限等待。保证有限时间内可以进入临界区</li><li>让权等待。不能进入临界区应该立即释放处理器，防止进程忙等待</li></ol><h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><h4 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h4><ol><li>单标志法：违背空闲让进</li><li>双标志先检查法：违背忙则等待</li><li>双标志后检查法：两个进程同时想进入临界区时，会互相谦让。导致“饥饿”现象。</li><li>皮特森算法Peterson’s Algorithm：结合单标志法和双标志后检查法。利用flag解决临界资源的互斥访问，利用turn解决饥饿现象。</li></ol><h4 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h4><ol><li>中断屏蔽<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断；</span><br><span class="line">临界区；</span><br><span class="line">开中断；</span><br></pre></td></tr></table></figure></li><li>硬件指令<ol><li>TestAndSet<br> 即采用原子操作</li><li>Swap指令<br>硬件方法不能实现让权等待</li></ol></li></ol><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>用以解决互斥和同步问题。标准原语wait(S)和signal(S)。记为P操作和V操作(对应荷兰语的pass和release)</p><h3 id="实现同步"><a href="#实现同步" class="headerlink" title="实现同步"></a>实现同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = 0;</span><br><span class="line">p1()&#123;</span><br><span class="line">    x;</span><br><span class="line">    V(S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行P1，再执行P2</p><h3 id="实现互斥"><a href="#实现互斥" class="headerlink" title="实现互斥"></a>实现互斥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = 1;</span><br><span class="line">p1()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    x;</span><br><span class="line">    V(S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    x;</span><br><span class="line">    V(S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是一组数据以及定义这组数据之上的对这组数据操作组成的软件模块。可实现同步和互斥(类比于抽象类)<br>组成</p><ol><li>局部于管程的共享结构数据说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li></ol><h3 id="经典的同步问题"><a href="#经典的同步问题" class="headerlink" title="经典的同步问题"></a>经典的同步问题</h3><ol><li>生产者-消费者问题</li><li>读写者问题</li><li>哲学家进餐问题</li><li>吸烟者问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/spring/Servlet/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/spring/Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Servlet-规范"><a href="#Servlet-规范" class="headerlink" title="Servlet 规范"></a>Servlet 规范</h2><ol><li>Servlet规范是JavaEE规范的一种</li><li>作用<ol><li>在Servlet规范中，指定<strong>动态资源文件</strong>的开发步骤</li><li>在Servlet规范中，指定Http服务器调用动态资源文件的规则</li><li>在Servlet规范中，指定Http服务器管理动态资源文件的规则(如何管理servlet)</li></ol></li></ol><h2 id="Servlet-接口实现类"><a href="#Servlet-接口实现类" class="headerlink" title="Servlet 接口实现类"></a>Servlet 接口实现类</h2><ol><li>在Servlet规范中认为，Http能调用的动态资源文件必须是Servlet接口的实现类，也就是说，只有Servlet接口的实现类才是动态资源文件</li><li>Servlet接口是Servlet规范下的一个接口，这个接口存在于Http服务器提供的jar包</li><li>在Tomcat服务器下的lib文件中，有一个servlet-api.jar的jar包，里面存放着Servlet接口</li></ol><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><ol><li>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器来创建，程序员不能手动创建</li><li>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时自动创建这个Servlet接口实现类的实例对象</li><li>在手动配置的情况下，可以要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</li></ol><h2 id="HttpServletResponse接口和HttpServletRequest接口"><a href="#HttpServletResponse接口和HttpServletRequest接口" class="headerlink" title="HttpServletResponse接口和HttpServletRequest接口"></a>HttpServletResponse接口和HttpServletRequest接口</h2><ul><li>两者接口皆来自于Servlet规范中</li><li>两者接接口实现类由Http服务器负责提供</li><li>HttpServletResponse接口负责将doGet/doPost方法执行结果写入到【响应体】交给浏览器，HttpServletRequest接口负责在doGet()，doPost()等方法运行时读取Http请求协议包中信息</li><li>习惯于将HttpServletResponse接口对象称为响应对象，HttpServletRequest接口修饰的对象称为【请求对象】</li></ul><h3 id="HttpServletResponse功能"><a href="#HttpServletResponse功能" class="headerlink" title="HttpServletResponse功能"></a>HttpServletResponse功能</h3><ol><li>将执行结果以二进制形式写入到响应体</li><li>设置响应头content-type属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令等】</li><li>置响应头【location】属性值，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求（setRedirect()）</li></ol><h3 id="HttpServletRequest功能"><a href="#HttpServletRequest功能" class="headerlink" title="HttpServletRequest功能"></a>HttpServletRequest功能</h3><ol><li>可以读取Http请求协议包中请求行信息</li><li>可以读取保存在Http请求协议包中请求头或者请求体中参数信息</li><li>可以替代浏览器向Http服务器申请资源文件调用</li></ol><h3 id="请求对象和响应对象的生命周期"><a href="#请求对象和响应对象的生命周期" class="headerlink" title="请求对象和响应对象的生命周期"></a>请求对象和响应对象的生命周期</h3><ol><li>在Http服务器接收到浏览器发送的Http请求协议包之后，会自动为当前请求协议包生成一个请求对象和响应对象</li><li>在Http服务器调用doGet或doPost方法时，负责将请求对象和响应对象作为参数传递进去</li><li>在Http服务器准备推送Http响应包之前，负责将本次请求关联的请求对象和响应对象销毁<br>注：请求对象和响应对象生命周期贯穿一次请求的处理过程始末</li></ol><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><ol><li>监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】</li><li>作用域对象：在Servlet规范中，认为在服务端内存中可以在某些条件下认为两个Servlet之间提供数据共享方案，被称为【作用域对象】<ol><li>ServletContext： 全局作用域对象</li><li>HttpServlet：会话作用域对象</li><li>HttpServletRequest：请求作用域对象</li></ol></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ol><li>Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</li><li>具体作用：<ol><li>拦截Http服务器，帮助Http服务器检测当前请求合法性</li><li>拦截Http服务器，对当前请求进行增强操作</li></ol></li></ol><p><a href="https://qiankunli.github.io/2019/11/26/tomcat_source.html#%E4%BB%8E%E5%90%84%E4%B8%AA%E8%A7%86%E8%A7%92%E7%9C%8Btomct">https://qiankunli.github.io/2019/11/26/tomcat_source.html#%E4%BB%8E%E5%90%84%E4%B8%AA%E8%A7%86%E8%A7%92%E7%9C%8Btomct</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/spring/SpringIOC/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/spring/SpringIOC/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈Spring-IOC"><a href="#浅谈Spring-IOC" class="headerlink" title="浅谈Spring IOC"></a>浅谈Spring IOC</h1><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><p>在Java中，我们通常创建对象都是通过new Object 的形式来创建一个新的对象的，然后通过这个对象的set方法对一个对象里面的属性进行赋值。<br>譬如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User()</span><br><span class="line">user.setName = <span class="string">&#x27;Liming&#x27;</span></span><br></pre></td></tr></table></figure><p>除了通过new的方式以外，我们也可以通过反射的方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clz.getConstructor(String.class, String.class);</span><br><span class="line">Object object = constructor.newInstance(<span class="string">&quot;Liming&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以拆解这个步骤，可以分为实例化和初始化两步：</p><ol><li>实例化：所谓的实例化就是new Object()这种这一种操作，这一行为在内存中为开辟了创建对象的空间</li><li>初始化：所谓的初始化，就是对已经实例化的对象，填充其内部的属性。</li></ol><p>每一次都需要这么创建，那么有没有什么方式可以帮助我们创建对象呢？Spring IOC就是为了解决我们这个难点的</p><h2 id="Spring-IOC-是如何创建对象的"><a href="#Spring-IOC-是如何创建对象的" class="headerlink" title="Spring IOC 是如何创建对象的"></a>Spring IOC 是如何创建对象的</h2><p>Spring 是如何帮我们创建对象的？使用过spring的都应该有过一个这样的体会，我们通过xml或者是注解来描述一个Bean,就像这样。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.AppConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 根据我们对Bean的描述，转换成统一的Bean定义信息，然后根据这些信息创建一个对应的对象。如果我们需要使用这个对象，我们就可以通过getBean的方法，获取到这个对象。这样子就不用重新创建了，同时也省下了我们写一大串创建对象的方式</p><p>整一个流程可以简化成下图<br><img src="..%5Cimage%5CIOC1.png" alt="IOC1"></p><p>对于一个对象是如此，对于多个不同对象而言，我们就需用引入工厂模式来解决这个问题。所有的对象由工厂统一生产。在这里回到我们上述说的Java中创建的方法，一是new，二是反射，而针对不同对象的创建，最好的方式就是通过反射的方式创建对象，而spring里面也同样是通过这种方式的</p><p>同时我们也将对Bean的不同描述，抽象出转换层。这样如果以后出现XML，注解外其他的Bean描述形式，我们只需接入这个转换层就可以了。</p><p>整一个流程可以如下图所示<br><img src="..%5Cimage%5CIOC2.png" alt="IOC2"></p><h2 id="Spring-IOC对对象进行操作"><a href="#Spring-IOC对对象进行操作" class="headerlink" title="Spring IOC对对象进行操作"></a>Spring IOC对对象进行操作</h2><p>从spring IOC创建的流程我们可以发现，对象创建的流程变长了，从new然后set value的两步，引申出了Bean的定义信息，实例化和初始化。那么我们可以在如此长的flow当中对对象进行不同的操作。</p><ol><li><p>首先我们可以在Bean定义信息到BeanFactory的时候进行处理。此时，对象并没有被创建，我们可以对Bean的定义信息进行处理，比如修改Bean定义信息里面的属性值。<br>在Spring中，这一步是使用一个BeanFactoryPostProcessor(后置处理器/增强器)进行处理。</p></li><li><p>当对象创建完以后，我们但是仍然还没有初始化以前，我们也可以对其进行操作。在初始化前和初始化后，我们都可以对创建完的对象进行处理。Spring这一步使用的是BeanPostProcessor进行处理。</p></li></ol><p>整一个流程可以如下图所示<br><img src="..%5Cimage%5CIOC3.png" alt="IOC3"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="单片应用"><a href="#单片应用" class="headerlink" title="单片应用"></a>单片应用</h1><p>好处</p><ul><li>方便测试，容易部署<br>所带来的问题</li><li>应用膨胀，过于巨大</li><li>使得后续的开发人员难以完全理解整个应用。难以修bug或者添加新的功能</li><li>减缓开发进度，启动应用的时间变长</li><li>单机应用启动的是一个进程</li><li>难以使用新的框架和语言</li></ul><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="微服务的先决条件"><a href="#微服务的先决条件" class="headerlink" title="微服务的先决条件"></a>微服务的先决条件</h2><ul><li>快速配置，能够几个小时内配置并启动全新的设备 （使用云服务和容器技术）</li><li>基础运维和监控</li><li>快速部署(CI/CD)</li></ul><h2 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h2><ul><li>会带来复杂性，需要选择消息传递或者RPC进程通信</li><li>分区数据库体系</li><li>测试上的困难</li><li>跨服务更改</li></ul><h2 id="API网关的特性"><a href="#API网关的特性" class="headerlink" title="API网关的特性"></a>API网关的特性</h2><ul><li>优点：封装了应用程序的内部结构，客户端不必调用特定的服务，只需要和网关进行对话</li><li>缺点：必须开发、部署和管理高可用性的组件</li></ul><p>微服务带来的复杂性</p><ul><li>服务依赖管理：服务间直接调用，依赖混乱</li><li>服务调用统计：调用记录无处可寻，调用统计和分析无从谈起</li><li>服务接口规范：环境与接口规范缺失，维护困难</li><li>服务安全管理：安全靠白名各自为战</li><li>服务治理能力：大量代码实现路由，分级，熔断，降级   </li><li>服务接口测试：拆分过程中接口行为不一致</li><li>服务灰度发布：上线功能借助大量if else</li><li>服务压力测试：对于峰值压力无历史数据</li><li>服务调用链分析：当服务请求缓慢，难以定位问题</li><li>测试环境治理：测试环境多，难管理</li></ul><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>起因：<br>一是 增加了整个链路的请求时间<br>二是 下游系统本身就出现了问题，不断的请求又把系统问题加重了，恢复困难。<br>作用<br>熔断模式可以防止应用程序不断地尝试 可能超时和失败的服务，能达到应用程序执行而不必等待下游服务修正错误服务。<br>熔断器模式最牛的是能让应用程序自我诊断下游系统的错误是否已经修正，如果没有，不放量去请求，如果请求成功了，慢慢的增加请求，再次尝试调用。</p><p>强调服务之间的调用实现自我恢复状态</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>降级就是为了解决资源不足和访问量增加的矛盾.<br>在有限的资源情况下，为了能抗住大量的请求，就需要对系统做出一些牺牲，有点“弃卒保帅”的意思。放弃一些功能，保证整个系统能平稳运行</p><p>牺牲<br>强强一致性变成最终一致性：<br>干掉一些次要功能：停止访问不重要的功能，从而释放出更多的资源</p><p>注意点：对业务进行仔细的梳理和分析<br>什么指标下能进行降级：吞吐量、响应时间、失败次数等达到一个阈值才进行降级处理<br>如何降级：降级最简单的就是在业务代码中配置一个开关或者做成配置中心模式，直接在配置中心上更改配置，推送到相应的服务。</p><p>维护系统内部的评级服务或者业务的维度考虑 干掉一些不用的，保护正常的</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>实现：漏斗，令牌桶<br>注意点：限流不要成为瓶颈，最好又开关可以直接介入</p><p>强调保护系统的作用</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>Git Flow:<a href="https://nvie.com/">https://nvie.com/</a></p><h2 id="微服务的基础设置"><a href="#微服务的基础设置" class="headerlink" title="微服务的基础设置"></a>微服务的基础设置</h2><ol><li>注册中心：用于注册微服务相关配置信息的中心，如Zookeeper</li><li>调用中心：用于提供给前端调用的统一入口E</li><li>部署中心：用于编译并打包微服务源码的并将其部署到Docker引擎中，如Jenkins</li><li>日志中心：用于收集并管理微服务应用程序中产生的日志，如ELK<br>Elasticsearch负责存储日志，LogStash负责日志收集并村塾Elasticsearch，Kibana负责日志查询可视化</li><li>监控中心：用于监控微服务的实时运行情况。使用InfluxDB,cAdvisor,Grafana。<br>InfluxDB负责存放时序性数据，cAdvisor将时序性数据存入到InfluxDB，Grafana负责展示时序性数据。</li><li>追踪中心：用于追踪微服务的调用轨迹，如zipkin</li><li>消息中心：用于解耦微服务之间的调用关系</li><li>配置中心：用于管理微服务应用程序所需的配置参数</li></ol><h2 id="根据业务切分微服务边界"><a href="#根据业务切分微服务边界" class="headerlink" title="根据业务切分微服务边界"></a>根据业务切分微服务边界</h2><ol><li>梳理业务流程</li><li>抽取公共服务</li><li>定义业务服务</li><li>设计数据模型</li><li>定义服务接口</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构核心要素</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件架构的核心要素"><a href="#软件架构的核心要素" class="headerlink" title="软件架构的核心要素"></a>软件架构的核心要素</h1><p>软件架构：有关软件整体接口与组件的抽象描述，用于知道大型软件系统各个反面的测试</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>浏览器端：浏览器缓存、页面压缩、合理布局页面、减少cookie传输、CDN加速</li><li>应用服务器端：服务器缓存、分布式缓存、异步消息队列、集群</li><li>代码：使用多线程、改善内存管理</li><li>数据库服务器端：索引、缓存、sql优化<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3>响应时间、TPS、系统性能计数器。<br>可以通过监控指标分析系统瓶颈，预测网站容量，并对异常指标进行报警，保障系统可用<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2>主要手段：冗余<h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2>伸缩性指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储亲求<h3 id="主要指标"><a href="#主要指标" class="headerlink" title="主要指标"></a>主要指标</h3></li><li>是否可以用太台服务器构建集群</li><li>是否容易向集群中添加新的服务器</li><li>加入新的服务器时候可以提供和原来的服务器无差别的服务<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2>手段：事件驱动架构和分布式服务</li><li>事件驱动架构：利用消息队列实现</li><li>分布式服务：将业务和可复用服务分离开来，通过分布式服务框架调用<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构模式</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>分为应用层，服务层，数据层，后续继续分层<br>reference:<a href="https://zhuanlan.zhihu.com/p/40353581">https://zhuanlan.zhihu.com/p/40353581</a></p><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><ol><li>分层的设计可以简化系统设计，让不同的人专注做某一层次的事情</li><li>分层之后可以做到很高的复用</li><li>分层架构可以让我们更容易做横向扩展</li></ol><h3 id="分层的缺点"><a href="#分层的缺点" class="headerlink" title="分层的缺点"></a>分层的缺点</h3><ol><li>增加代码复杂度</li><li>如果我们把每个层次独立部署，层次间通过网络来交互，那么多层的架构在性能上会有损耗。这也是为什么服务化架构性能要比单体架构略差的原因<br>reference：<a href="https://zhuanlan.zhihu.com/p/196733107">https://zhuanlan.zhihu.com/p/196733107</a></li></ol><h3 id="分层的原则"><a href="#分层的原则" class="headerlink" title="分层的原则"></a>分层的原则</h3><ol><li>机器为本，用户至上<h3 id="分层的依据"><a href="#分层的依据" class="headerlink" title="分层的依据"></a>分层的依据</h3></li></ol><ul><li>基于关注点为不同的调用目的划分层次</li><li>面对变化</li><li>保证同一层的组件处于同一个抽象层次</li></ul><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>将不同的功能和服务分割开飞，形成高内聚低耦合的模块单元。一是有助于软件的开发和维护，而是便于不同模块的分布式部署，提高网站并发处理能力和扩展能力</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>将不同模块部署在不同的服务器上，通过远程调用协调工作。意味着更多的计算机完成同样的功能，计算机越多，resource就越多，能够处理的并发访问和数据量就越大</p><h3 id="分布式应用和微服务"><a href="#分布式应用和微服务" class="headerlink" title="分布式应用和微服务"></a>分布式应用和微服务</h3><h3 id="分布式静态资源"><a href="#分布式静态资源" class="headerlink" title="分布式静态资源"></a>分布式静态资源</h3><h3 id="分布式数据和存储"><a href="#分布式数据和存储" class="headerlink" title="分布式数据和存储"></a>分布式数据和存储</h3><h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>多台服务器部署相同的应用构成一个集群，通过负载均衡对外服务，当更多用户访问的时候，只需要向集群中增加服务器即可</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>在单一服务器可以通过多线程共享队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理。分布式系统中，多个服务器集群可以通过分布式消息队列实现异步，分布式队列可以看做内存队列的分布式部署<br>优点：</p><ol><li>提高系统的可用性</li><li>加快网站响应速度</li><li>消除并发访问高峰</li></ol><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>数据库定期备份，存档保存。实现冷备份以外，为保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份</p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站架构模式</title>
      <link href="2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/01/%E5%90%8E%E7%AB%AF/%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="网站架构模式"><a href="#网站架构模式" class="headerlink" title="网站架构模式"></a>网站架构模式</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>通过分层，可以将一个庞大的软件系统切分成不同的部分，便于分工、合作、开发和维护</li><li>各层具有一定独立性，只要维持调用接口不变，各层可以根据具体问题独立烟花发展而不需要其他层做出相应的调整<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3></li><li>必须合理规划层次边界和接口</li><li>开发过程严格遵循分层架构，严禁跨层次调用<h3 id="重要性和必要性"><a href="#重要性和必要性" class="headerlink" title="重要性和必要性"></a>重要性和必要性</h3>分层架构对网站和高并发向分布式方向发展至关重要，因此网站规模还很小的时候就应该使用分层架构<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2></li><li>将软件在纵向方向进行分割，有助于软件的开发和维护</li><li>便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2>分割和分层的牡蛎就是为了切分后的模块能便于分布式部署，将不同的模块部署到不同的服务器上。通过远程调用协同工作<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3></li></ul><ol><li>通过远程调用，会有性能损耗</li><li>服务器越多，宕机的可能性就越大</li><li>分布式环境中的数据一致性问题<h3 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h3></li><li>分布式应用和服务</li><li>分布式静态资源</li><li>分布式数据和存储</li><li>分布式计算</li><li>分布式配置<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2>多台服务器部署相同的应用，通过负载均衡设备共同对外提供服务<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3>缓存就是将数据存放在计算最近的位置加快处理速度</li><li>CDN</li><li>反向代理</li><li>本地缓存</li><li>分布式缓存<br>将数据缓存存储在一个专门的分布式缓存集群中<h3 id="缓存的前提条件"><a href="#缓存的前提条件" class="headerlink" title="缓存的前提条件"></a>缓存的前提条件</h3></li><li>数据访问热点不均</li><li>数据在某个时间段内有效，不会很快过期<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2>使用异步消息队列<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3></li></ol><ul><li>提高系统可用性</li><li>加快网站反应速度</li><li>消除并发访问高峰<h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2></li><li>热备份</li><li>冷备份（数据库主从分离）<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><h3 id="发布过程自动化"><a href="#发布过程自动化" class="headerlink" title="发布过程自动化"></a>发布过程自动化</h3></li></ul><ol><li>自动化代码管理：代码版本控制，代码分支创建和合并</li><li>自动化测试</li><li>自动化安全检测</li><li>自动化部署<h3 id="线上问题自动化"><a href="#线上问题自动化" class="headerlink" title="线上问题自动化"></a>线上问题自动化</h3></li><li>自动化监控</li><li>自动化报警</li><li>自动化线性转移</li><li>自动化失效恢复</li><li>自动化降级</li><li>自动化分配资源<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2></li></ol><ul><li>身份校验</li><li>敏感数据加密处理</li><li>垃圾信息和敏感信息过滤</li><li>风险控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%20Network/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%20Network/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><h2 id="CNM-Container-Network-Model"><a href="#CNM-Container-Network-Model" class="headerlink" title="CNM(Container Network Model)"></a>CNM(Container Network Model)</h2><p>CNM (Container Network Model) 是 Docker 发布的容器网络标准，意在规范和指定容器网络发展标准，CNM 抽象了容器的网络接口 ，使得只要满足 CNM 接口的网络方案都可以接入到 Docker 容器网络，更好地满足了用户网络模型多样化的需求<br>网络标准的三个元素</p><ol><li>沙箱（Sandbox）：沙箱代表了一系列网络堆栈的配置，其中包含路由信息、网络接口等网络资源的管理</li><li>接入点（Endpoint）：接入点将沙箱连接到网络中，代表容器的网络接口</li><li>网络（Network）：网络是一组可以互相通信的接入点，它将多接入点组成一个子网，并且多个接入点之间可以相互通信</li></ol><p>为了更好地构建容器网络标准，Docker 团队把网络功能从 Docker 中剥离出来，成为独立的项目 libnetwork，它通过插件的形式为 Docker 提供网络功能。使用 Golang 编写，它完全遵循 CNM 网络规范，是 CNM 的官方实现</p><h2 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a>Libnetwork</h2><p>Libnetwork 比较典型的网络模式主要有四种</p><h3 id="1-null-空网络模式"><a href="#1-null-空网络模式" class="headerlink" title="1. null 空网络模式"></a>1. null 空网络模式</h3><p>构建一个没有网络接入的容器环境，以保障数据安全</p><h3 id="2-bridge-桥接模式"><a href="#2-bridge-桥接模式" class="headerlink" title="2. bridge 桥接模式"></a>2. bridge 桥接模式</h3><p>可以打通容器与容器间网络通信的需求。bridge 桥接模式是 Docker 的默认网络模式。桥接模式是基于Linux的veth和bridge技术实现的</p><h4 id="Linux-veth"><a href="#Linux-veth" class="headerlink" title="Linux veth"></a>Linux veth</h4><p>veth 是 Linux 中的虚拟设备接口，veth 都是成对出现的，它在容器中，通常充当一个桥梁。veth 可以用来连接虚拟网络设备，例如 veth 可以用来连通两个 Net Namespace，从而使得两个 Net Namespace 之间可以互相访问</p><h4 id="Linux-bridge"><a href="#Linux-bridge" class="headerlink" title="Linux bridge"></a>Linux bridge</h4><p>Linux bridge 是一个虚拟设备，是用来连接网络的设备，相当于物理网络环境中的交换机。Linux bridge 可以用来转发两个 Net Namespace 内的流量</p><h4 id="veth和bridge的关系"><a href="#veth和bridge的关系" class="headerlink" title="veth和bridge的关系"></a>veth和bridge的关系</h4><p><img src="/images/veth%E5%92%8Cbridge%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="veth和bridge的关系"><br>bridge 就像一台交换机，而 veth 就像一根网线，通过交换机和网线可以把两个不同 Net Namespace 的容器连通，使得它们可以互相通信</p><h3 id="3-host-主机网络模式"><a href="#3-host-主机网络模式" class="headerlink" title="3. host 主机网络模式"></a>3. host 主机网络模式</h3><p>可以让容器内的进程共享主机网络，从而监听或修改主机网络<br>使用 host 主机网络模式时</p><ul><li>libnetwork 不会为容器创建新的网络配置和 Net Namespace</li><li>Docker 容器中的进程直接共享主机的网络配置，可以直接使用主机的网络信息，此时，在容器内监听的端口，也将直接占用到主机的端口</li><li>除了网络共享主机的网络外，其他的包括进程、文件系统、主机名等都是与主机隔离的<h3 id="4-container-网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过-localhost-即可实现访问"><a href="#4-container-网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过-localhost-即可实现访问" class="headerlink" title="4. container 网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问"></a>4. container 网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问</h3>container 网络模式允许一个容器共享另一个容器的网络命名空间<h3 id="网络模式和应用场景"><a href="#网络模式和应用场景" class="headerlink" title="网络模式和应用场景"></a>网络模式和应用场景</h3><img src="/images/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="网络模式及应用场景"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile 书写原则</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Dockerfile%E7%BC%96%E5%86%99%E5%87%86%E5%88%99/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Dockerfile%E7%BC%96%E5%86%99%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Dockerfile-书写原则"><a href="#Dockerfile-书写原则" class="headerlink" title="Dockerfile 书写原则"></a>Dockerfile 书写原则</h1><h2 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="1. 单一职责"></a>1. 单一职责</h2><pre><code>由于容器的本质是进程，一个容器代表一个进程，因此不同功能的应用应该尽量拆分为不同的容器，每个容器只负责单一业务进程。</code></pre><h2 id="2-提供注释信息"><a href="#2-提供注释信息" class="headerlink" title="2. 提供注释信息"></a>2. 提供注释信息</h2><p>   Dockerfile 也是一种代码，我们应该保持良好的代码编写习惯，晦涩难懂的代码尽量添加注释，让协作者可以一目了然地知道每一行代码的作用，并且方便扩展和使用。</p><h2 id="3-保持容器最小化"><a href="#3-保持容器最小化" class="headerlink" title="3. 保持容器最小化"></a>3. 保持容器最小化</h2><p>   应该避免安装无用的软件包</p><h2 id="4-合理选择基础镜像"><a href="#4-合理选择基础镜像" class="headerlink" title="4. 合理选择基础镜像"></a>4. 合理选择基础镜像</h2><p>   容器的核心是应用，因此只要基础镜像能够满足应用的运行环境即可。例如一个Java类型的应用运## 行时只需要JRE，并不需要JDK，因此我们的基础镜像只需要安装JRE环境即可</p><h2 id="5-使用-dockerignore-文件"><a href="#5-使用-dockerignore-文件" class="headerlink" title="5. 使用 .dockerignore 文件"></a>5. 使用 .dockerignore 文件</h2><pre><code>忽略一些不需要参与构建的文件，从而提升构建效率</code></pre><h2 id="6-尽量使用构建缓存"><a href="#6-尽量使用构建缓存" class="headerlink" title="6. 尽量使用构建缓存"></a>6. 尽量使用构建缓存</h2><p>Docker 构建过程中，每一条 Dockerfile 指令都会提交为一个镜像层，下一条指令都是基于上一条指令构建的。如果构建时发现要构建的镜像层的父镜像层已经存在，并且下一条命令使用了相同的指令，即可命中构建缓存<br>命中缓存的原则：</p><ol><li>从当前构建层开始，比较所有的子镜像，检查所有的构建指令是否与当前完全一致，如果不一致，则不使用缓存</li><li>一般情况下，只需要比较构建指令即可判断是否需要使用缓存，但是有些指令除外（例如ADD和COPY）</li><li>对于ADD和COPY指令不仅要校验命令是否一致，还要为即将拷贝到容器的文件计算校验和（根据文件内容计算出的一个数值，如果两个文件计算的数值一致，表示两个文件内容一致 ），命令和校验和完全一致，才认为命中缓存<h2 id="7-正确设置时区"><a href="#7-正确设置时区" class="headerlink" title="7. 正确设置时区"></a>7. 正确设置时区</h2>我们从 Docker Hub 拉取的官方操作系统镜像大多数都是 UTC 时间（世界标准时间）<h2 id="8-使用国内软件源加快镜像构建速度"><a href="#8-使用国内软件源加快镜像构建速度" class="headerlink" title="8. 使用国内软件源加快镜像构建速度"></a>8. 使用国内软件源加快镜像构建速度</h2><h2 id="9-最小化镜像层数"><a href="#9-最小化镜像层数" class="headerlink" title="9. 最小化镜像层数"></a>9. 最小化镜像层数</h2>在构建镜像时尽可能地减少 Dockerfile 指令行数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 组件</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E7%BB%84%E4%BB%B6/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h1><p><em>Docker 在linux下默认的安装目录/var/lib/docker</em></p><h2 id="Docker-相关组件"><a href="#Docker-相关组件" class="headerlink" title="Docker 相关组件"></a>Docker 相关组件</h2><h3 id="docker-客户端"><a href="#docker-客户端" class="headerlink" title="docker 客户端"></a>docker 客户端</h3><p>对用户可见的操作形式为 docker 命令，通过 docker 命令可以完成所有的 Docker 客户端与服务端的通信（还可以通过 REST API、SDK 等多种形式与 Docker 服务端通信）<br>客户端与服务器端交互的过程：<br>    docker 客户端向服务端发送请求后，服务端根据请求执行具体的动作并将结果返回给 docker客户端，docker 解析服务端的返回结果，并将结果通过命令行标准输出展示给用户。这样一次完整的客户端服务端请求就完成了</p><h3 id="dockerd"><a href="#dockerd" class="headerlink" title="dockerd"></a>dockerd</h3><p>dockerd 是 Docker 服务端的后台常驻进程，用来接收客户端发送的请求，执行具体的处理任务，处理完成后将结果返回给客户端<br>Docker 客户端与 dockerd 的交互方式有三种，客户端和服务器端的通信必须保持一致</p><ol><li>通过 UNIX 套接字与服务端通信<br>配置格式为unix://socket_path，默认 dockerd 生成的 socket 文件路径为 /var/run/docker.sock。该文件只有root用户和docker用户组的用户才能访问</li><li>通过 TCP 与服务端通信<br>配置格式为tcp://host:port，存在安全隐患，可以使用TLS认证来保证传输安全</li><li>通过文件描述符的方式与服务端通信<br> 配置格式为：fd://这种格式一般用于 systemd 管理的系统中<h3 id="docker-init"><a href="#docker-init" class="headerlink" title="docker-init"></a>docker-init</h3>在容器内部，当我们自己的业务进程没有回收子进程的能力时，在执行 docker run 启动容器时可以添加 –init 参数，此时 Docker 会使用 docker-init 作为1号进程，帮你管理容器内子进程，例如回收僵尸进程等<h3 id="docker-proxy"><a href="#docker-proxy" class="headerlink" title="docker-proxy"></a>docker-proxy</h3>docker-proxy 主要是用来做端口映射的，底层依赖于iptables实现<h2 id="containerd相关组件"><a href="#containerd相关组件" class="headerlink" title="containerd相关组件"></a>containerd相关组件</h2><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4></li><li>负责容器生命周期的管理</li><li>镜像的管理，例如容器运行前从镜像仓库拉取镜像到本地</li><li>接收 dockerd 的请求，通过适当的参数调用 runc 启动容器</li><li>管理存储相关资源</li><li>管理网络相关资源<h4 id="containerd和dockerd的交互"><a href="#containerd和dockerd的交互" class="headerlink" title="containerd和dockerd的交互"></a>containerd和dockerd的交互</h4>containerd 包含一个后台常驻进程，默认的 socket 路径为 /run/containerd/containerd.sock，dockerd 通过 UNIX 套接字向 containerd 发送请求，containerd 接收到请求后负责执行相关的动作并把执行结果返回给 dockerd。<h3 id="containerd-shim"><a href="#containerd-shim" class="headerlink" title="containerd-shim"></a>containerd-shim</h3>containerd-shim 的主要作用是将 containerd 和真正的容器进程解耦，使用 containerd-shim 作为容器进程的父进程，从而实现重启 containerd 不影响已经启动的容器进程<h3 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h3>containerd的客户端，可以直接向containerd发送容器请求<h2 id="runc（容器运行时组件）"><a href="#runc（容器运行时组件）" class="headerlink" title="runc（容器运行时组件）"></a>runc（容器运行时组件）</h2>runc 是一个标准的 OCI 容器运行时的实现，它是一个命令行工具，可以直接用来创建和运行容器</li></ol><p><img src="/images/Docker%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8.png" alt="Docker组件"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker隔离</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker隔离"><a href="#Docker隔离" class="headerlink" title="Docker隔离"></a>Docker隔离</h1><h2 id="Docker-资源隔离-借助于Linux-的Namespace"><a href="#Docker-资源隔离-借助于Linux-的Namespace" class="headerlink" title="Docker 资源隔离 借助于Linux 的Namespace"></a>Docker 资源隔离 借助于Linux 的Namespace</h2><h3 id="Namespace是什么"><a href="#Namespace是什么" class="headerlink" title="Namespace是什么"></a>Namespace是什么</h3><p>Namespace 是 Linux 内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。<br>它实现了在同一个主机中，对进程 ID、主机名、用户 ID、文件名、网络和进程间通信等资源的隔离</p><h3 id="Namespace的功能"><a href="#Namespace的功能" class="headerlink" title="Namespace的功能"></a>Namespace的功能</h3><p>Linux提供了8种类型的Namespace<br>|Namespace 名称    |作用|<br>|—-|—-|<br>|Mount（mnt）    |隔离挂载点    |<br>|Process ID (pid)    |隔离进程 ID    |<br>|Network (net)    |隔离网络设备，端口号等    |<br>|Interprocess Communication (ipc)    |隔离 System V IPC 和 POSIX message queues    |<br>|UTS Namespace(uts)|    隔离主机名和域名    |<br>|User Namespace (user)|    隔离用户和用户组    |<br>|Control group (cgroup) Namespace|    隔离 Cgroups 根目录    |<br>|Time Namespace    |隔离系统时间|    </p><p>Docker 使用了前6种Namespace</p><h3 id="为什么docker需要Namespace"><a href="#为什么docker需要Namespace" class="headerlink" title="为什么docker需要Namespace"></a>为什么docker需要Namespace</h3><p>当 Docker 新建一个容器时， 它会创建这六种 Namespace，然后将容器中的进程加入这些 Namespace 之中，使得 Docker 容器中的进程只能看到当前 Namespace 中的系统资源。</p><p>正是由于 Docker 使用了 Linux 的这些 Namespace 技术，才实现了 Docker 容器的隔离，可以说没有 Namespace，就没有 Docker 容器</p><h2 id="Docker-资源限制-借助于Linux-的Cgroups"><a href="#Docker-资源限制-借助于Linux-的Cgroups" class="headerlink" title="Docker 资源限制 借助于Linux 的Cgroups"></a>Docker 资源限制 借助于Linux 的Cgroups</h2><h3 id="Cgroups是什么"><a href="#Cgroups是什么" class="headerlink" title="Cgroups是什么"></a>Cgroups是什么</h3><p>cgroups（全称：control groups）是 Linux 内核的一个功能，它可以实现限制进程或者进程组的资源（如 CPU、内存、磁盘 IO 等）</p><h3 id="Cgroups功能"><a href="#Cgroups功能" class="headerlink" title="Cgroups功能"></a>Cgroups功能</h3><ol><li>资源限制： 限制资源的使用量，例如我们可以通过限制某个业务的内存上限，从而保护主机其他业务的安全运行</li><li>优先级控制：不同的组可以有不同的资源（ CPU 、磁盘 IO 等）使用优先级</li><li>审计：计算控制组的资源使用情况</li><li>控制：控制进程的挂起或恢复</li></ol><h3 id="Cgroups三个核心概念"><a href="#Cgroups三个核心概念" class="headerlink" title="Cgroups三个核心概念"></a>Cgroups三个核心概念</h3><ul><li>子系统（subsystem）：是一个内核的组件，一个子系统代表一类资源调度控制器。例如内存子系统可以限制内存的使用量，CPU 子系统可以限制 CPU 的使用时间。</li><li>控制组（cgroup）：表示一组进程和一组带有参数的子系统的关联关系。例如，一个进程使用了 CPU 子系统来限制 CPU 的使用时间，则这个进程和 CPU 子系统的关联关系称为控制组。</li><li>层级树（hierarchy）：是由一系列的控制组按照树状结构排列组成的。这种排列方式可以使得控制组拥有父子关系，子控制组默认拥有父控制组的属性，也就是子控制组会继承于父控制组</li></ul><h3 id="Docker-是如何使用Cgroups的"><a href="#Docker-是如何使用Cgroups的" class="headerlink" title="Docker 是如何使用Cgroups的"></a>Docker 是如何使用Cgroups的</h3><p>Docker 创建容器时，Docker 会根据启动容器的参数，在对应的 cgroups 子系统下创建以容器 ID 为名称的目录, 然后根据容器启动时设置的资源限制参数, 修改对应的 cgroups 子系统资源限制文件, 从而达到资源限制的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 镜像</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E9%95%9C%E5%83%8F/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p>Docker 镜像是由文件系统叠加而成</p><ol><li>最低端是一个引导文件系统，即bootfs</li><li>第二层是root文件系统rootfs，位于引导文件系统之上，rootfs可以使一种或多种操作系统<br>使用联合加载技术会在root文件系统层上加载更多制度文件系统。<br>联合加载是指一次同时加载多个文件系统。</li></ol><p>写时复制机制</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker cookbook</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/docker%20cookbook/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/docker%20cookbook/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-cookbook"><a href="#Docker-cookbook" class="headerlink" title="Docker cookbook"></a>Docker cookbook</h1><h2 id="无权限连接Docker-Daemon-socket"><a href="#无权限连接Docker-Daemon-socket" class="headerlink" title="无权限连接Docker Daemon socket"></a>无权限连接Docker Daemon socket</h2><p>问题描述：Got permission denied while trying to connect to the Docker daemon socket<br>问题原因：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问<br>解决措施：</p><ol><li>使用sudo获取管理员权限</li><li>docker守护进程启动时，会默认赋予docker的用户组读写Unix Socket的权限，因此只需将当前用户添加到用户组就有权限访问Unix Socket了<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改国内镜像源"><a href="#修改国内镜像源" class="headerlink" title="修改国内镜像源"></a>修改国内镜像源</h2><p>问题描述：Error response from daemon: Head “<a href="https://registry-1.docker.io/v2/library/ngnix/manifests/latest&quot;">https://registry-1.docker.io/v2/library/ngnix/manifests/latest&quot;</a>: Get “<a href="https://auth.docker.io/token?scope=repository:library/ngnix:pull&amp;service=registry.docker.io&quot;">https://auth.docker.io/token?scope=repository%3Alibrary%2Fngnix%3Apull&amp;service=registry.docker.io&quot;</a>: net/http: TLS handshake timeout.<br>问题原因：国内无法访问镜像源<br>解决措施：更改为国内镜像源</p><ol><li>sudo vim /etc/docker/daemon.json</li><li>修改配置文件<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">&quot;registry-mirrors&quot;</span>: <span class="string">[&quot;https://docker.mirrors.ustc.edu.cn/&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot;],</span></span><br><span class="line"><span class="meta">&quot;insecure-registries&quot;</span>: <span class="string">[&quot;10.0.0.12:5000&quot;]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li>重新加载守护进程：sudo systemctl daemon-reload</li><li>重启docker：sudo service docker restart</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/docker%E7%AE%80%E4%BB%8B/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/docker%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h3><ul><li>提供一个简单、轻量的建模方式<br>所需要的环境知识一台仅仅安装兼容版本的linux内核和二进制文件最小限的宿主机</li><li>职责的逻辑分离<br>开发人员只需要关注容器运行的应用程序，运维只需要关注如何管理容器</li><li>快速、高效的生命开发周期<br>缩短代码从开发、测试到部署、上线运行的周期，让程序具有可以移植性，易于构建和协作</li><li>鼓励使用面向服务的架构<br>Docker推荐单个容器只运行一个应用程序或进程，形成分布式的应用程序模型。</li></ul><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p><img src="/images/Docker%E6%9E%B6%E6%9E%84.png" alt="Docker架构"></p><h4 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h4><p>核心组件：</p><ul><li>Docker客户端和服务器</li><li>Docker镜像</li><li>Registry</li><li>Docker容器</li></ul><h4 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h4><p>Docker是一个C/S架构的程序。Docker客户端向Docker服务器或者守护进程发送请求，服务器或守护进程将完成所有工作并返回结果。</p><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><ol><li>镜像是Docker生命周期中的构建部分。是基于联合(Union)文件系统的一种层式结构。他是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。</li><li>Docker镜像的实现原理：Docker 镜像是静态的分层管理的文件组合，镜像底层的实现依赖于联合文件系统（UnionFS）。每一层的只存放了上一层的增量数据</li><li>如何使用镜像：<ol><li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，你可以在基础镜像上添加一些用户自定义的内容</li><li>从功能镜像仓库拉取别人制作好的镜像，如Docker Hub</li></ol></li><li>Docker镜像的操作<br><img src="/images/Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C.png" alt="Docker镜像的操作"></li></ol><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是Docker生命周期中的启动部分。容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。</p><p>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态</p><p>使用Docker,能够快读构建一个应用程序服务器、一个消息总线、一套实用工具、一个持续集成测试环境或者任意一种应用程序、服务或工具。</p><p>容器的生命周期<br><img src="/images/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="容器的生命周期"></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>Registry类似于代码仓库，用来存储和分发 Docker 镜像。<br>Registry 用于保存用户构建的镜像。分为公共和私有两种。公共Registry叫做Docker Hub。</p><h4 id="容器、仓库、镜像之间的关系"><a href="#容器、仓库、镜像之间的关系" class="headerlink" title="容器、仓库、镜像之间的关系"></a>容器、仓库、镜像之间的关系</h4><p><img src="/images/%E5%AE%B9%E5%99%A8%E3%80%81%E4%BB%93%E5%BA%93%E3%80%81%E9%95%9C%E5%83%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="容器、仓库、镜像之间的关系"></p><h4 id="Docker架构-1"><a href="#Docker架构-1" class="headerlink" title="Docker架构"></a>Docker架构</h4><h3 id="Docker-应用场景"><a href="#Docker-应用场景" class="headerlink" title="Docker 应用场景"></a>Docker 应用场景</h3><ul><li>加快本地开发和构建流程</li><li>能够让独立服务或应用程序在不同的环境中，得到相同的运行结果</li><li>创建隔离的环境来进行测试</li><li>构建一个多用户的平台即服务基础(PaaS)设施</li><li>为开发、测试提供一个轻量级的独立沙河环境</li><li>提供软件即服务(SaaS)应用程序</li><li>高性能、超大规模的宿主机部署</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE 指导思想</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/SRE/SRE%20%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/SRE/SRE%20%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h1><h2 id="拥抱风险"><a href="#拥抱风险" class="headerlink" title="拥抱风险"></a>拥抱风险</h2><h3 id="管理风险"><a href="#管理风险" class="headerlink" title="管理风险"></a>管理风险</h3><p>管理服务的可靠性很大程度上是通过管理风险来进行的。<br>需要将运维风险和业务风险结合。提高一项服务的可靠性，但不会超过该服务的可靠性<br>高昂的成本在于以下两个维度</p><ol><li>冗余物理服务器/计算资源的成本<br>投入冗余设备，能够进行更多的维护操作，又能利用空间来提供一定程度的数据持久化保证</li><li>机会成本<h3 id="度量服务风险"><a href="#度量服务风险" class="headerlink" title="度量服务风险"></a>度量服务风险</h3></li></ol><ul><li>基于时间的可用性：可用性 = 系统正常运行时间/(系统正常运行时间+停机时间)</li><li>合计可用性：可用性 = 成功请求数/总的请求数<h3 id="服务的风险容忍度"><a href="#服务的风险容忍度" class="headerlink" title="服务的风险容忍度"></a>服务的风险容忍度</h3><h4 id="消费者服务的风险容忍度"><a href="#消费者服务的风险容忍度" class="headerlink" title="消费者服务的风险容忍度"></a>消费者服务的风险容忍度</h4></li><li>需要的可用性水平是什么</li><li>不同类型的失败对服务有不同的影响吗</li><li>我们如何使用服务成本来帮助在风险曲线上定位这个服务</li><li>有哪些其他重要的服务指标需要考虑<h5 id="可用性目标"><a href="#可用性目标" class="headerlink" title="可用性目标"></a>可用性目标</h5>服务的可用性目标通常取决于它提供的功能</li><li>用户期望的服务水平</li><li>这项服务是否直接关系到收入</li><li>这是有偿还是免费的</li><li>市场有竞争对手，那竞争对手提供的服务水平如何</li><li>服务是针对消费者还是企业的<h5 id="故障类型"><a href="#故障类型" class="headerlink" title="故障类型"></a>故障类型</h5>根据业务对服务的停机时间的容忍程度有多高<h5 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h5></li><li>构建再过一个9的系统，收益会增加多少</li><li>额外的首付是否能抵消为了达到这一可靠性水平付出的成本<h4 id="基础设施服务的风险容忍度"><a href="#基础设施服务的风险容忍度" class="headerlink" title="基础设施服务的风险容忍度"></a>基础设施服务的风险容忍度</h4>不同于消费者服务，基础设施组件有多个客户，而且他们通常有很多不同的需求<br>关键战略：明确划分水平</li></ul><h2 id="质量服务目标"><a href="#质量服务目标" class="headerlink" title="质量服务目标"></a>质量服务目标</h2><h3 id="SLI-服务质量指标"><a href="#SLI-服务质量指标" class="headerlink" title="SLI(服务质量指标)"></a>SLI(服务质量指标)</h3><p>几个关键指标</p><ul><li>请求延迟</li><li>错误率(请求处理失败的百分比)</li><li>系统吞吐量(每秒请求数量)</li><li>可用性(服务可用时间的百分比)<h3 id="SLO-服务质量目标-Service-Level-Objectives"><a href="#SLO-服务质量目标-Service-Level-Objectives" class="headerlink" title="SLO(服务质量目标) Service Level Objectives"></a>SLO(服务质量目标) Service Level Objectives</h3>某个SLI值&lt;=目标值或者SLI在某个目标范围<h3 id="SKA-服务质量协议"><a href="#SKA-服务质量协议" class="headerlink" title="SKA(服务质量协议)"></a>SKA(服务质量协议)</h3>指服务和用户之间的一个协议，描述没有达到SLO之后的后果</li></ul><h2 id="减少琐事"><a href="#减少琐事" class="headerlink" title="减少琐事"></a>减少琐事</h2><p>琐事</p><ul><li>手动的</li><li>重复性的</li><li>可以被自动化的</li><li>战术性的</li><li>没有持久价值的</li><li>与服务同步线性增长的<br>SRE活动</li><li>软件工程：<br>编写修改代码，以及所有其他相关的设计和文档工作。如，编写自动化脚本，创造工具或者框架，增加可用性扩展和可靠性服务或修改基础设施代码使其更稳健</li><li>系统工程：<br>配置生产系统、修改现存配置或通过一种一次性工作产生持久的改进的方法来书写文档。例如，监控的部署和更新、负载均衡的配置、服务器配置和操作系统参数调整和负载均衡器的部署</li><li>琐事：</li><li>流程负担：<br>与运维服务不直接相关的行政工作。如任务系统的定期清理，工作总结，自我评价以及培训课程</li></ul><h2 id="分布式监控"><a href="#分布式监控" class="headerlink" title="分布式监控"></a>分布式监控</h2><ul><li>监控：收集、处理、汇总并显示光宇某个系统的实时量化数据。如请求类型和错误数量和类型，以及处理用时，应用服务器的存活时间</li><li>白盒监控：依靠系统内部暴露的一些性能指标进行监控。包括日志分析，java虚拟机提供的监控接口或者一个列出内部统计数据的HTTP接口监控</li><li>黑盒监控：通过测试某种外部用户的系统行为进行监控</li><li>监控台页面：提供某个服务核心指标一览服务的应用程序。该程序提供过滤功能、选择功能。主要用以显示系统最重要的指标。</li><li>警报</li><li>根源问题</li><li>节点和机器</li></ul><h3 id="为什么需要监控"><a href="#为什么需要监控" class="headerlink" title="为什么需要监控"></a>为什么需要监控</h3><ul><li>分析长期趋势</li><li>跨事件范围比较或者观察实验组和控制组之间的区别</li><li>报警</li><li>构建监控台页面：回答有关服务的一些基本问题。如四个黄金指标</li><li>临时性回溯分析：在线调试<h3 id="四个黄金指标"><a href="#四个黄金指标" class="headerlink" title="四个黄金指标"></a>四个黄金指标</h3></li><li>延迟：服务器处理某个请求所需要的时间</li><li>流量：系统某个高层次的指标针对系统负载需求锁进行的度量</li><li>错误：请求失败的速率</li><li>饱和度：系统中目前最为受限的某种资源的某个具体指标的度量</li></ul><h3 id="简化监控系统"><a href="#简化监控系统" class="headerlink" title="简化监控系统"></a>简化监控系统</h3><ul><li><p>最能反映真实故障的规则越简单越好，可预测性强,非常可靠</p></li><li><p>不常用的数据收集、汇总以及警报配置应该定时删除</p></li><li><p>收集到的信息，但是没有暴露给控制台或者没有被任何警报规则使用的应该定时删除</p><h3 id="减少误报"><a href="#减少误报" class="headerlink" title="减少误报"></a>减少误报</h3></li><li><p>该规则是否能够检测到一个目前检测不到的、紧急的、有操作性的，并且即将发生或者已经发生的用户可见故障</p></li><li><p>是否可以忽略这条警报？什么情况下可能会导致用户忽略这条警报，如何避免？</p></li><li><p>这条警报是否确实显示了用户正在受到影响？是否存在用户没有收到影响也可以触发这条规则的情况。例如测试环境和系统维护状态下发出的警报是否被过滤掉</p></li><li><p>收到警报后是否需要进行某个操作，是否要立即执行。该操作是否可以被安全自动化，操作的效果是长期还是短期</p></li><li><p>是否也会有其他人收到相关的紧急警报，这个警报是否不必要</p></li><li><p>每个警报都应该是具体可操作的</p></li><li><p>每个紧急警报的回复都是需要某种智力分析过程，如果某个紧急警报只是需要一个固定的机械动作，那就不应该成文警报</p></li><li><p>每个紧急警报都应该是关于新问题的，不应该彼此重叠</p></li></ul><h2 id="自动化的价值"><a href="#自动化的价值" class="headerlink" title="自动化的价值"></a>自动化的价值</h2><ul><li>一致性</li><li>平台性</li><li>修复速度更快：能够降低一些常见故障的平均修复时间</li><li>行动速度更快</li><li>节省时间<h4 id="专业化倾向"><a href="#专业化倾向" class="headerlink" title="专业化倾向"></a>专业化倾向</h4>自动化程序的不同体现在</li><li>准确性</li><li>延迟：即开始后，执行步骤需要多久</li><li>相关性：自动化所涵盖的实际流程比例</li></ul><h2 id="发布工程"><a href="#发布工程" class="headerlink" title="发布工程"></a>发布工程</h2><h3 id="发布工程的哲学"><a href="#发布工程的哲学" class="headerlink" title="发布工程的哲学"></a>发布工程的哲学</h3><ul><li>自服务模型</li><li>追求速度</li><li>密闭性</li><li>强调策略和流程</li></ul><h2 id="简单化"><a href="#简单化" class="headerlink" title="简单化"></a>简单化</h2><p>SRE管理系统：工作最终是在系统灵活性和稳定性上维持平衡<br>为了最小化意外复杂度，应该</p><ul><li>在他们所复杂的系统音符意外复杂度，及时提出抗议</li><li>不断努力消除正在接受的和已经负责运维的系统的复杂度<br>软件的简单性是可靠性的前提</li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 问题集</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/Docker/Docker%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Dockerfile-和-docker-compose-yml-的区别"><a href="#Dockerfile-和-docker-compose-yml-的区别" class="headerlink" title="Dockerfile 和 docker-compose.yml 的区别"></a>Dockerfile 和 docker-compose.yml 的区别</h3><p>Dockerfile: Dockerfile 是拿来构建自定义镜像的，并没有直接生成容器<br>docker-compose.yml是用来编排项目的，里面包含使用各种镜像创建的容器服务,在服务启动的时候用到</p><h3 id="为什么容器是单进程模型"><a href="#为什么容器是单进程模型" class="headerlink" title="为什么容器是单进程模型"></a>为什么容器是单进程模型</h3><p>容器只是通过Linux的Namespaces、Cgroups实现了进程级别的隔离。虽然在容器里看不见宿主机上的其他进程，但归根结底它还只是一个运行在宿主机上的进程，所以就不具备操作系统的进程管理能力。</p><p>容器的”单进程模型”，并不是指容器里只能运行”一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里的主进程（PID=1 的进程）就是应用本身，其他的进程都是这个主进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的init进程或者systemd 那样拥有进程管理的功能。<br>reference：<a href="https://cloud.tencent.com/developer/article/1671554">https://cloud.tencent.com/developer/article/1671554</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE 方法论</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/SRE/SRE%20%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/SRE/SRE%20%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h1><h2 id="承担的职责："><a href="#承担的职责：" class="headerlink" title="承担的职责："></a>承担的职责：</h2><p>可用性改进，延迟优化，性能优化，效率优化，变更管理，监控，紧急事务处理，容量规划与管理</p><h2 id="工作内容："><a href="#工作内容：" class="headerlink" title="工作内容："></a>工作内容：</h2><p>开发监控系统，规划容量，处理紧急事件，确保事故根源被跟踪修复</p><h2 id="核心方法论："><a href="#核心方法论：" class="headerlink" title="核心方法论："></a>核心方法论：</h2><ol><li>确保长期关注研发工作<ol><li>将运维工作限制在50%以内，剩余时间花在项目研发上</li><li>运维工作的一项准则：在每8~12个小时的on-cal轮值期间最多只处理两个紧急的事件，确保on-call工程师能够有足够的时间跟进紧急事件，能够正确的处理故障，恢复服务并且撰写事后报告。</li><li>事后总结应该包括内容：事故发生，发现，解决的全过程。事故的根本原因、预防或者优化解决方案</li></ol></li><li>在保障服务SLO（服务等级目标）的前提下最大化迭代速度<ol><li>在办证业务服务的可靠性需求的同事尽可能加快功能上线速度</li><li>错误预算。SRE的目标是不是达到100%可靠。而是基于以下考虑<ol><li>基于用户的使用习惯，服务可靠性要达到什么程度用户才会满意</li><li>如果这项服务的可靠程度不够，用户是否有其他的替代选择</li><li>服务的可靠程度是否会影响用户对这服务的使用模式</li></ol></li></ol></li><li>监控系统<br>系统不应该依赖人来分析警报信息，而是由系统自动分析。仅当需要用户执行某些操作的时候才通知用户<br>一个监控系统应该只有3类输出<ul><li>紧急警报：收到警报的用户需要立即执行某种操作。目标是解决某种已经发生的问题或者避免即将发生的问题</li><li>工单：以为着接受工单的用户应该执行某种操作，并非立即执行。系统并不能自动解决目前的情况。但是用户在几天内执行这项操作，系统不会受到任何影响</li><li>日志：日志信息依旧需要被收集起来以备调试和事后分析使用</li></ul></li><li>应急事件处理<br>可靠性是平均失败时间(MTTF)和平均回复时间(MTTR)的函数。使用运维手册可以缩短平均回复时间。可以将工作重心放在“运维手册”的维护上，同时通过灾难演练培训团队成员</li><li>需求预测和容量规划<br>简单说就是保障一个业务有足够的容量和冗余度去服务预测中的未来需求。业务的容量规划，需要包括自然增长(随着用户使用量的上升，资源用量也上升)和非自然增长(新功能的发布，商业推广和其他因素)<br>必须步骤：<ol><li>必须有一个准确的自然增长需求预测模型，需求预测的时间应该超过资源获取的时间</li><li>规划中必须有准确的非自然增长的需求来源统计</li><li>必须有周期性压力测试，以便准确地将系统原始资源与业务容量对应起来</li></ol></li><li>资源部署<br>资源的部署是变更管理与容量规划的结合物。新资源的部署与配置需要谨慎执行。</li><li>效率与性能<br>密切关注一个服务的容量配置策略，进而改进其资源利用率，降低系统的总成本。<br>资源的使用情况的驱动因素：<ul><li>用户需求(流量)</li><li>可用容量和软件</li><li>资源使用效率</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE实践</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/SRE/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/SRE/%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="故障排查手段"><a href="#故障排查手段" class="headerlink" title="故障排查手段"></a>故障排查手段</h3><p>故障报告–&gt; 定位问题 –&gt; 检查 –&gt; 诊断 –&gt; 测试/修复 –&gt; 治愈<br>常见的问题主要集中在定位、检查和诊断环节上<br>应该避免</p><ul><li>关注了错误的系统现象，或者错误地理解了系统现象的含义</li><li>不能正确修改系统的配置信息、输入信息或者系统运行环境，造成不能安全和有效地的是假设</li><li>将问题过早地归结为极为不可能的因素，或者念念不忘之前曾今发生过的系统问题</li><li>试图解决与当前系统问题相关的问题，却没有认识到这些其实只是翘课或者这些问题其实是由于当前系统的问题造成的<br>遇到问题的正确做法是尽最大可能让系统恢复服务，缓解系统问题是第一要务</li></ul><h3 id="事故流程管理"><a href="#事故流程管理" class="headerlink" title="事故流程管理"></a>事故流程管理</h3><ol><li>划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场</li><li>事前准备：事先和所有事故处理参与者一起准备一套流程</li><li>信任：充分相信每个事故参与者，分配职责让他们自主行动</li><li>反思：在事故处理过程中注意自己的情绪和精神状态，发现自己开始惊慌失措或者感觉到压力难以承受，应寻求更多的帮助</li><li>考虑替代方案：周期性重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行更重要的事情或者更紧急的事情</li><li>联系：平常不断地使用这项流程，直到习惯成自然</li><li>换位思考：上次你是事故总负责人，下一可以换一个职责试试，鼓励每个团队成员熟悉流程中的其他角色</li></ol><h3 id="事后总结"><a href="#事后总结" class="headerlink" title="事后总结"></a>事后总结</h3><p>需要总结的条件：</p><ul><li>用户可见的宕机事件或者服务质量降级程度达到一定标准</li><li>任何类型的数据丢失</li><li>on-call工程师需要人工介入的事故(包括回滚、切换用户流量)</li><li>问题解决耗时超过一定限制</li><li>监控问题(预示着问题由人工发现的，而非警报系统)<h4 id="协作和共享"><a href="#协作和共享" class="headerlink" title="协作和共享"></a>协作和共享</h4>工具选择：</li><li>实时协作</li><li>开放的评论系统</li><li>邮件通知<br>事后总结还包括正式的评审和发布过程，首先在团队内部发布，同时有目的的找资深工程师评估文档的完整程度，评审条件</li><li>关键的灾难数据是否已经被收集并且保存起来</li><li>本次事故的影响评估是否完整</li><li>造成事故的根源问题是否足够深入</li><li>文档中记录的任务优先级是否合理，能否即使解决了根源问题</li><li>事故处理过程是否共享了所有相关部门</li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务可靠度模型</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/SRE/%E6%9C%8D%E5%8A%A1%E5%8F%AF%E9%9D%A0%E5%BA%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/SRE/%E6%9C%8D%E5%8A%A1%E5%8F%AF%E9%9D%A0%E5%BA%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="服务可靠度模型"><a href="#服务可靠度模型" class="headerlink" title="服务可靠度模型"></a>服务可靠度模型</h1><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li>产品设计</li><li>软件开发</li><li>容量规划</li><li>测试+发布</li><li>事后总结/问题根源分析</li><li>应急事件处理</li><li>监控<h4 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h4>大型监控系统的难点</li></ol><ul><li>大型系统中组件数量特别多，分析工作繁杂繁重</li><li>监控系统本身的维护要求必须非常低<br>时序性监控(borgmon 和 prometheus)<br><a href="https://yq.aliyun.com/articles/664669">zabbix和prometheus的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S ConfigMap 和 Secret</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/ConfigMap%E5%92%8CSecret/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/ConfigMap%E5%92%8CSecret/</url>
      
        <content type="html"><![CDATA[<h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p><strong>K8s允许将配置选项分离到单独的资源对象ConfigMap中，本质上使一个KV映射</strong>。应用无须直接读取到ConfigMap。映射的内容通过环境变量或者卷文件的形式传递给容器，而非直接传递给容器。<br>当然，应用程序也可以直接通过kubernetes Rest API按需读取ConfigMap的内容。<br>ConfigMap通常被用作存储非敏感数据，不过依旧希望仅限于文件拥有者的用户和组可读写。</p><h2 id="ConfigMap存在的意义"><a href="#ConfigMap存在的意义" class="headerlink" title="ConfigMap存在的意义"></a>ConfigMap存在的意义</h2><p>ConfigMap的作用使解耦配置。应用配置的关键在于能偶在多个环境中区分配置选项，将配置从应用程序源码中分离，可频繁变更配置值</p><p><img src="/images/pod%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8EConfigMap%E5%8D%B7%E4%BD%BF%E7%94%A8ConfigMap.png" alt="pod通过环境变量与ConfigMap卷使用ConfigMap"><br>f<br><img src="/images/%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%90%8C%E5%90%8DConfigMap.png" alt="不同环境下的同名ConfigMap"></p><h2 id="ConfigMap的创建方式"><a href="#ConfigMap的创建方式" class="headerlink" title="ConfigMap的创建方式"></a>ConfigMap的创建方式</h2><ul><li>简单创建：kubectl create configmap myConfig –from-literal=sleep-interval=25</li><li>yaml创建：kubectl create -f myConfig.yaml</li><li>文件内容创建：kubectl create configmap myConfig –from-file=config-file.conf</li><li>文件夹创建：kubectl create configmap myConfig –from-file=/path/to/dir</li><li>混合创建： kubectl create configmap myConfig –from-file=/path/to/dir –from-file=my.json –from-file=/path/to/dir<br><img src="/images/%E4%BB%8E%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BAConfigMap.png" alt="从文件、文件夹以及字面量创建ConfigMap"></li></ul><h2 id="ConfigMap的使用方式"><a href="#ConfigMap的使用方式" class="headerlink" title="ConfigMap的使用方式"></a>ConfigMap的使用方式</h2><h3 id="ConfigMap条目用作环境变量"><a href="#ConfigMap条目用作环境变量" class="headerlink" title="ConfigMap条目用作环境变量"></a>ConfigMap条目用作环境变量</h3><h4 id="单个环境变量"><a href="#单个环境变量" class="headerlink" title="单个环境变量"></a>单个环境变量</h4><ol><li>使用Pod中的spec.containers.env.name 表示环境变量</li><li>使用spec.containers.env.valueFrom.configMapKeyRef.name 指定ConfigMap。</li><li>使用spec.containers.env.valueFrom.configMapKeyRef.key 指定环境变量的值</li></ol><h4 id="多个环境变量"><a href="#多个环境变量" class="headerlink" title="多个环境变量"></a>多个环境变量</h4><p>我们可以使用spec.containers.enFrom.configMapRef 指定ConfigMap,而环境变量的名称与ConfigMap的键名相同。</p><h3 id="ConfigMap条目用作命令行参数"><a href="#ConfigMap条目用作命令行参数" class="headerlink" title="ConfigMap条目用作命令行参数"></a>ConfigMap条目用作命令行参数</h3><ol><li>与使用单个环境环境变量相似</li><li>然后通过spec.containers.env.args 引用环境变量<h3 id="ConfigMap卷将条目暴露为文件"><a href="#ConfigMap卷将条目暴露为文件" class="headerlink" title="ConfigMap卷将条目暴露为文件"></a>ConfigMap卷将条目暴露为文件</h3><h4 id="卷内使用ConfigMap条目volumes"><a href="#卷内使用ConfigMap条目volumes" class="headerlink" title="卷内使用ConfigMap条目volumes"></a>卷内使用ConfigMap条目volumes</h4></li><li>在Pod的spec.volumes.configMap中引入ConfigMap卷</li><li>在spec.containers.volumesMounts.mountPath 指明Config卷挂载的位置<br><img src="/images/ConfigMap%E6%9D%A1%E7%9B%AE%E4%BD%9C%E4%B8%BA%E5%AE%B9%E5%99%A8%E5%8D%B7%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6.png" alt="ConfigMap条目作为容器卷中的文件"></li></ol><h4 id="卷内暴露指定ConfigMap条目"><a href="#卷内暴露指定ConfigMap条目" class="headerlink" title="卷内暴露指定ConfigMap条目"></a>卷内暴露指定ConfigMap条目</h4><ol><li>在Pod的spec.volumes.configMap.items 指明包含卷中的条目</li><li>在Pod的spec.volumes.configMap.items.key 指明该键对应的条目文件</li><li>在Pod的spec.volumes.configMap.items.path 指明条目的值被储存在该文件中<h4 id="ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的文件"><a href="#ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的文件" class="headerlink" title="ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的文件"></a>ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的文件</h4>Linux挂在某一文件夹会隐藏该文件夹下的已存在的文件。此时文件夹中只会包含被挂载文件系统的文件，即便使原本文件夹的文件是不可访问也同样如此。</li></ol><p>通过spec.container.volumeMounts.subpath字段可以用于挂载卷中的某个独立文件或者使文件夹，而不需要挂载完整卷</p><p><img src="/images/%E6%8C%82%E8%BD%BD%E5%8D%B7%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E6%96%87%E4%BB%B6.png" alt="挂载卷中的单独文件"></p><h4 id="为ConfigMap的文件设置权限"><a href="#为ConfigMap的文件设置权限" class="headerlink" title="为ConfigMap的文件设置权限"></a>为ConfigMap的文件设置权限</h4><p>默认权限是644，可以使用spec.volumes.configMap.defaultMode修改权限</p><h3 id="更新应用配置"><a href="#更新应用配置" class="headerlink" title="更新应用配置"></a>更新应用配置</h3><p>K8S通过符号链接的方式更新卷。每当ConfigMap被更新后，K8s就会创建一个新文件夹，写入所有文件并更新链接至新的文件夹。</p><p>如果挂载的是卷中的单个文件，而不是完整的卷，那么ConfigMap更新后对应的文件不会被更新</p><h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>Secret只会存储在节点中，永不写入物理存储，这样从节点删除Secret就不需要擦除磁盘了。<br>Secret的条目会以Base64格式编码。使用方式和ConfigMap一致</p><h2 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h2><p>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S Pod理解</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/Pod%20%E7%90%86%E8%A7%A3/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/Pod%20%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Pod-理解"><a href="#Pod-理解" class="headerlink" title="Pod 理解"></a>Pod 理解</h1><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/">kubernetes官网</a>是这样描述Pod的:</p><blockquote><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。它是一组（一个或多个） 容器，容器之间共享存储、网络、以及怎样运行这些容器的声明。Pod中的内容总是共置在一起、共享同一个上下文和共同被调度。</p></blockquote><p>从定义中我们可以引申出</p><ol><li>Pod本质上就是容器的集合，那么为什么kubernetes使用Pod作为创建和管理的最小的单元，而不是直接使用容器呢？</li><li>什么时候应该把多个容器放在一个Pod里面，而不是放在不同的Pod里？</li><li>Pod中有多个容器了，那么Pod中的容器之间如何共享存储和网络的？</li><li>既然有Pod并不是单机的，那么Pod与Pod之间是如何通信的？</li><li>Pod是怎么被管理和调度的？</li><li>Pod既然是被管理和调度的，那么又是如何保证Pod内服务是正常的运行的？</li></ol><h2 id="1-Pod存在的意义"><a href="#1-Pod存在的意义" class="headerlink" title="1. Pod存在的意义"></a>1. Pod存在的意义</h2><p>为了解决引申出的第一个问题，首先需要知道Pod为什么存在，以及是在什么场景下被设计出来的。也就是如果调度容器可以解决问题的话，为什么还需要使用更高级的抽象Pod呢？</p><p>先看看容器有什么缺陷。以Docker容器为例，Docker容器本质上就是一个进程，里面运行着我们的应用服务。如果在单个容器里面运行多个不相关的进程，那么保持所有进程运行、管理它们的日志将会是我们的责任。比如进程奔溃的时候记录统一的日志，我们需要自己去区分这些日志数据哪一个进程。</p><p>这时候我们就需要对其进行解耦，<strong>不能将多个进程放在单独的容器中，因此我们需要另外一种更高级的结构将容器绑在一起，并将它们作为一个单元进行管理</strong>。这也就是Pod存在的意义。</p><h2 id="2-什么时候应该把多个容器放在一个Pod里面，而不是放在不同的Pod里？"><a href="#2-什么时候应该把多个容器放在一个Pod里面，而不是放在不同的Pod里？" class="headerlink" title="2. 什么时候应该把多个容器放在一个Pod里面，而不是放在不同的Pod里？"></a>2. 什么时候应该把多个容器放在一个Pod里面，而不是放在不同的Pod里？</h2><p>回想Pod存在的意义，我们知道Pod是为了将运行多个进程的容器拆分出来，进行解耦。换个角度来说，就是问什么时候我们需要将多个进程放在一个容器里？ 很容易想到就是<strong>耦合度高的服务适合放在同一个Pod</strong>内。<br>什么情况下耦合度高，比如如下情况：</p><ul><li>容器之间会发生文件交换等。比如一个写文件，一个读文件。</li><li>容器之间需要本地通信，比如通过 localhost 或者本地的 Socket</li><li>容器之间需要发生频繁的 RPC 调用，出于性能的考量，将它们放在一个 Pod 内</li><li>希望为应用添加其他功能，比如日志收集、监控数据采集、配置中心、路由及熔断等功能</li></ul><h2 id="3-Pod中的容器之间如何共享存储和网络的？"><a href="#3-Pod中的容器之间如何共享存储和网络的？" class="headerlink" title="3. Pod中的容器之间如何共享存储和网络的？"></a>3. Pod中的容器之间如何共享存储和网络的？</h2><p>同一个Pod的容器之间如何共享储存和网络之前，我们得首先明白Pod中的容器是如何隔离的。只有知道它们是如何存储和网络是如何隔离开，才能知道通过怎么样子的方式让他们共享</p><p>以Docker容器为例，Docker容器Linux的Namespaces<a href="Namespaces%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BB%8E%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%EF%BC%88%E7%BD%91%E7%BB%9C%E6%A0%88%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8%E3%80%81%E6%8C%82%E8%BD%BD%E7%82%B9%E7%AD%89%EF%BC%89%E9%87%8C%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E4%BB%85%E8%87%AA%E5%B7%B1%E5%8F%AF%E8%A7%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%8C%BA%E5%9F%9F">^Namespaces</a>技术实现内核资源的隔离。意味着<strong>可以将不同的容器放置在同一个Namespace上面，以达到资源共享的目的</strong>。</p><p>Linux提供了8种类型的Namespace，而Docker使用了其中的前6种<br>|Namespace 名称    |作用|<br>|—-|—-|<br>|Mount（mnt）    |隔离挂载点    |<br>|Process ID (pid)    |隔离进程 ID    |<br>|Network (net)    |隔离网络设备，端口号等    |<br>|Interprocess Communication (ipc)    |隔离 System V IPC 和 POSIX message queues    |<br>|UTS Namespace(uts)|    隔离主机名和域名    |<br>|User Namespace (user)|    隔离用户和用户组    |<br>|Control group (cgroup) Namespace|    隔离 Cgroups 根目录    |<br>|Time Namespace    |隔离系统时间|</p><p>这就意为着我们如果将不同的容器放在同一个Namespaces下，就可以共享挂载点以达到共享存储的目的，可以共享网络设备和端口号以达到共享网络的目的。</p><h2 id="4-Pod与Pod之间是如何通信的？"><a href="#4-Pod与Pod之间是如何通信的？" class="headerlink" title="4. Pod与Pod之间是如何通信的？"></a>4. Pod与Pod之间是如何通信的？</h2><p>先看看Pod内容器时如何通信的</p><h3 id="Pod内网络通信"><a href="#Pod内网络通信" class="headerlink" title="Pod内网络通信"></a>Pod内网络通信</h3><p>Pod内的容器都运行在同一个Namespaces中，因此只要容器不使用同一个端口号，就可以通过localhost和端口号和其他容器进行通信</p><h3 id="Pod之间网络通信"><a href="#Pod之间网络通信" class="headerlink" title="Pod之间网络通信"></a>Pod之间网络通信</h3><p>Pod内使用不同的端口号和localhost，而kubernetes本身设计网络的结构时平坦的。因此每个Pod可以通过其他Pod的IP来实现相互访问。<br><img src="/images/Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B9%B3%E5%9D%A6%E7%BD%91%E7%BB%9C.png" alt="Pod之间的平坦网络"></p><h2 id="5-Pod是怎么被管理和调度的？"><a href="#5-Pod是怎么被管理和调度的？" class="headerlink" title="5. Pod是怎么被管理和调度的？"></a>5. Pod是怎么被管理和调度的？</h2><p>在管理Pod之前，我们得先知道如何区分Pod？必然每个Pod都有自己的ID，但是仅仅只有ID的话，我们并不能获取到有用的信息去组织Pod，K8S使用了标签(Label)去处理这个问题。<strong>通过标签，就很容易通过Label去识别哪一些Pod是属于同一组</strong>。</p><p>区分了不同的Pod以后，就要可以对不同的Pod进行管理，kubernetes提供了更高级的抽象结构对Pod进行操作。通过Pod创建的调用链可以知道，ReplicatSet/ReplicatController 直接对Pod进行操作，而在此之上还有Deployment。<strong>总的来说Pod就是被更高级的资源来管理，这些资源通过变更对应Pod的配置来决定Pod部署、版本更新、回滚、横纵伸缩以及调度方式</strong>。</p><p><img src="/images/Deployment%E8%B5%84%E6%BA%90%E6%8F%90%E4%BA%A4%E5%88%B0API%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%93%BE.png" alt="Deployment资源提交到API服务器的事件链"></p><h2 id="6-如何保证Pod内服务是正常的运行的？"><a href="#6-如何保证Pod内服务是正常的运行的？" class="headerlink" title="6. 如何保证Pod内服务是正常的运行的？"></a>6. 如何保证Pod内服务是正常的运行的？</h2><p>在保证Pod如何运行之前，需要先判断Pod是不是正常的。<strong>kubernetes通过一个存活探针来判断服务是否时正常的</strong>。探针会每隔一段时间请求配置特定路径的URL，根据返回结果与预设结果的比较。来判断应用是否正常。如果不正常，会重启该Pod。（<em>Note：毕竟重启可以解决80%的问题</em>）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[1] <a href="https://kubernetes.io/">kubernetes官网</a></li><li>[2] <a href="https://www.manning.com/books/kubernetes-in-action">Kubernetes in Action</a></li><li>[3] <a href="https://www.k8stech.net/k8s-book/">Kubernetes学习指南</a></li><li>[4] <a href="https://en.wikipedia.org/wiki/Linux_namespaces">Linux_namespaces</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S Pod</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/Pod/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/Pod/</url>
      
        <content type="html"><![CDATA[<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>Pod 由一个或多个容器组成。是k8s在容器基础上做了更高层次的抽象。Pod 中的容器不可分割，会作为一个整体运行在一个 Node 节点上，也就是说 Pod 是你在 Kubernetes 中可以创建和部署的最原子化的单位。<br>本质上Pod类似与一个逻辑主机。而容器则是主机内的进程。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>同一个 Pod 中的容器共享网络、存储资源。</p><ul><li>每个 Pod 都会拥有一个独立的网络空间，其内部的所有容器都共享网络资源，即 IP 地址、端口。内部的容器直接通过 localhost 就可以通信。</li><li>Pod 可以挂载多个共享的存储卷（Volume），这时内部的各个容器就可以访问共享的 Volume 进行数据的读写。</li></ul><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>不能将多个进程聚集在一个单独的容器中，因此需要一种更高级的结构将容器绑定在一起，并将它们作为一个单元进行管理。</p><h3 id="Pod的设计理念"><a href="#Pod的设计理念" class="headerlink" title="Pod的设计理念"></a>Pod的设计理念</h3><h4 id="为什么多个容器要比单个容器要好"><a href="#为什么多个容器要比单个容器要好" class="headerlink" title="为什么多个容器要比单个容器要好"></a>为什么多个容器要比单个容器要好</h4><ol><li>容器被设计为每个容器只运行一个进程(除非是进程本身产生的子进程)</li><li>如果在单个容器里面运行多个不相关的进程，那么保持所有进程运行、管理它们的日志将会是我们的责任</li></ol><h4 id="为什么k8s不直接管理容器，而由pod来管理？"><a href="#为什么k8s不直接管理容器，而由pod来管理？" class="headerlink" title="为什么k8s不直接管理容器，而由pod来管理？"></a>为什么k8s不直接管理容器，而由pod来管理？</h4><p>使用一个新的逻辑对象 Pod 来管理容器，可以在不重载容器信息的基础上，添加更多的属性，而且也方便跟容器运行时进行解耦，兼容度高。<br>比如</p><ul><li>存活探针（Liveness Probe）可以从应用程序的角度去探测一个进程是否还存活着，在容器出现问题之前，就可以快速检测到问题</li><li>容器启动后和终止前可以进行的操作，比如，在容器停止前，可能需要做一些清理工作，或者不能马上结束进程</li><li>定义了容器终止后要采取的策略，比如始终重启、正常退出才重启等</li></ul><h4 id="为什么要允许一个-Pod-内可以包含多个容器？"><a href="#为什么要允许一个-Pod-内可以包含多个容器？" class="headerlink" title="为什么要允许一个 Pod 内可以包含多个容器？"></a>为什么要允许一个 Pod 内可以包含多个容器？</h4><p>用一个 Pod 管理多个容器，既能够保持容器之间的隔离性，还能保证相关容器的环境一致性。使用粒度更小的容器，不仅可以使应用间的依赖解耦，还便于使用不同技术栈进行开发，同时还可以方便各个开发团队复用，减少重复造轮子</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="隔离原理"><a href="#隔离原理" class="headerlink" title="隔离原理"></a>隔离原理</h4><p>Pod通过配置Docker让一个Pod内的所有容器共享linux的命名空间，而不是每个容器都有自己的命名空间</p><h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="Pod内"><a href="#Pod内" class="headerlink" title="Pod内"></a>Pod内</h5><p>同一个Pod下的容器运行在相同的Network命名空间。因此同一个Pod下的容器运行的多个进程需要注意不能绑定在同一个端口号。</p><h5 id="Pod之间"><a href="#Pod之间" class="headerlink" title="Pod之间"></a>Pod之间</h5><p>所有的Pod都在同一个共享网络地址中，因此每个Pod都可以通过其他Pod的IP来实现相互访问。Pod之间的网络是平坦的<br><img src="/images/Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B9%B3%E5%9D%A6%E7%BD%91%E7%BB%9C.png" alt="Pod之间的平坦网络"></p><h3 id="一个pod内运行多个容器的使用场景"><a href="#一个pod内运行多个容器的使用场景" class="headerlink" title="一个pod内运行多个容器的使用场景"></a>一个pod内运行多个容器的使用场景</h3><p>Pod之间应该包含紧密耦合的容器组</p><ul><li>容器之间会发生文件交换等。比如一个写文件，一个读文件。</li><li>容器之间需要本地通信，比如通过 localhost 或者本地的 Socket</li><li>容器之间需要发生频繁的 RPC 调用，出于性能的考量，将它们放在一个 Pod 内</li><li>希望为应用添加其他功能，比如日志收集、监控数据采集、配置中心、路由及熔断等功能</li></ul><h3 id="Pod-的重启策略"><a href="#Pod-的重启策略" class="headerlink" title="Pod 的重启策略"></a>Pod 的重启策略</h3><ul><li>Always 表示一直重启，这也是默认的重启策略。Kubelet 会定期查询容器的状态，一旦某个容器处于退出状态，就对其执行重启操作；</li><li>OnFailure 表示只有在容器异常退出，即退出码不为 0 时，才会对其进行重启操作；</li><li>Never 表示从不重启；</li></ul><h3 id="Pod-中的健康检查"><a href="#Pod-中的健康检查" class="headerlink" title="Pod 中的健康检查"></a>Pod 中的健康检查</h3><p>Kubernetes 中提供了一系列的健康检查，可以定制调用，来帮助解决类似的问题，我们称之为 Probe（探针）</p><ul><li>livenessProbe可以用来探测容器是否真的在“运行”，即“探活”。如果检测失败的话，这个时候 kubelet 就会停掉该容器，容器的后续操作会受到其重启策略的影响。</li><li>readinessProbe常常用于指示容器是否可以对外提供正常的服务请求，即“就绪”，比如 nginx 容器在 reload 配置的时候无法对外提供 HTTP 服务。</li><li>startupProbe则可以用于判断容器是否已经启动好，就比如上面提到的容器启动慢的例子。我们可以通过参数，保证有足够长的时间来应对“超长”的启动时间。 如果检测失败的话，同livenessProbe的操作</li></ul><h3 id="Pod的定义"><a href="#Pod的定义" class="headerlink" title="Pod的定义"></a>Pod的定义</h3><ul><li>metadata：包括名称、命名空间、标签和关于该容器的其他信息</li><li>spec：包含Pod内容的实际说明，如Pod的容器、卷和其他数据</li><li>status：包含运行中的Pod的当前信息，如Pod所处的条件，每个容器的描述和状态，内部IP等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S StatefulSet</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/StatefulSet/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/StatefulSet/</url>
      
        <content type="html"><![CDATA[<h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h2 id="StatefulSet存在的意义"><a href="#StatefulSet存在的意义" class="headerlink" title="StatefulSet存在的意义"></a>StatefulSet存在的意义</h2><p>ReplicaSet创建的多个pod副本之间，除了名字和IP地址不同以外，没有其他差异。意味着ReplicaSet的所有副本都共享一个持久卷声明，也就是绑定到同一个持久卷。<br>而Stateful资源用于代替ReplicaSet，专门定制每一个实例都是不可替代的个体的应用，使其都有用稳定的名字和状态。</p><h2 id="StatefulSet和ReplicaSet的对比"><a href="#StatefulSet和ReplicaSet的对比" class="headerlink" title="StatefulSet和ReplicaSet的对比"></a>StatefulSet和ReplicaSet的对比</h2><p>ReplicaSet是用来管理无状态的应用的，而StatfulSet是用于有状态的应用的。<br>StatefulSet保证了pod被调度后保留它们的表示和状态，方便扩容和缩容。StatefulSet也是通过pod模板创建的，但是他创建的副本并不完全一致，每个pod都可以拥有独立的数据卷，同时提供稳定的网络标识</p><h2 id="StatefulSet如何保证同样的网络标识"><a href="#StatefulSet如何保证同样的网络标识" class="headerlink" title="StatefulSet如何保证同样的网络标识"></a>StatefulSet如何保证同样的网络标识</h2><p>与无状态的pod不一样，有状态的pod需要通过主机名来定位。因此有StatefulSet创建的时候需要创建一个用来记录每个pod网络标记的headless Service，这样每个pod都会拥有独立的DNS记录，保证集群中的伙伴或者客户端能通过主机名访问它。</p><h2 id="StatefulSet的缩容策略"><a href="#StatefulSet的缩容策略" class="headerlink" title="StatefulSet的缩容策略"></a>StatefulSet的缩容策略</h2><p>StatefulSet会优先删除最高索引值的实例，同时StatefulSet在有实例不健康的情况下是不允许进行缩容操作的。</p><p>对于缩容操作，只会删除一个pod，而<strong>遗留下之前创建的声明</strong>，一个持久卷声明如果被删除的话，则其上面的数据就会跟着消失。因此，如果需要释放持久卷的话，需要手动删除对应的持久卷声明。</p><h2 id="StatefulSet如何为不同的pod实例提供稳定的专属存储"><a href="#StatefulSet如何为不同的pod实例提供稳定的专属存储" class="headerlink" title="StatefulSet如何为不同的pod实例提供稳定的专属存储"></a>StatefulSet如何为不同的pod实例提供稳定的专属存储</h2><p>StatefulSet可以拥有一个或者多个卷的声明模板，这些持久卷声明会在创建pod前创建出来，并绑定在一个pod实例上。<br>当因为错误缩容后，可以通过扩容操作恢复。因为缩容并不会删除持久卷声明。<br><img src="/images/Statefulset%E5%88%9B%E5%BB%BApod%E5%92%8C%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E.png" alt="Statefulset创建pod和持久卷声明"></p><h2 id="StatefulSet的使用"><a href="#StatefulSet的使用" class="headerlink" title="StatefulSet的使用"></a>StatefulSet的使用</h2><p>在创建StatefulSet之前，还需要创建</p><ul><li>存储文件数据的持久卷</li><li>StatefulSet必须的一个控制Service</li><li>Stateful本身</li></ul><h2 id="StatefulSet如何处理失败节点"><a href="#StatefulSet如何处理失败节点" class="headerlink" title="StatefulSet如何处理失败节点"></a>StatefulSet如何处理失败节点</h2><p>Stateful要保证不会有两个相同标记和存储的pod同时运行。因为在明确知道一个pod不再运行之前，它不能也不应该创建和替换pod</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S组件</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E6%9E%B6%E6%9E%84/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h1><p><img src="/images/Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%84%E4%BB%B6.png" alt="Kubernetes控制平面以及工作节点的组件"></p><h2 id="组件间如何通信"><a href="#组件间如何通信" class="headerlink" title="组件间如何通信"></a>组件间如何通信</h2><ul><li>k8s系统组件间只能通过API服务器通信，它们之间不会直接通信</li><li>API服务器是和etcd通信的唯一组件。其他组件不会直接和etcd通信</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>尽管工作节点的组件都要运行在同一个节点上，控制平面的组件可以被简单地分割在多台服务器上，主节点地每个组件会有多个实例。etcd和API服务器的多个实例可以并行工作，但是调度器和控制管理器在给定时间内只有一个实例起作用，其他实例都处于待命模式</p><h2 id="kubernetes如何使用etcd"><a href="#kubernetes如何使用etcd" class="headerlink" title="kubernetes如何使用etcd"></a>kubernetes如何使用etcd</h2><p>k8s将所有创建的对象持久化存储到某个地方，而这个地方就就是etcd。etcd是一个响应快、分布式的一致性key-value存储。只有API服务器才能直接和etcd的优点，其他组件只能通过API服务器间接的读写etcd数据库。</p><h3 id="只有API服务器才能直接和etcd的优点"><a href="#只有API服务器才能直接和etcd的优点" class="headerlink" title="只有API服务器才能直接和etcd的优点"></a>只有API服务器才能直接和etcd的优点</h3><ul><li>增强乐观锁、验证系统的健壮性</li><li>将实际存储机制从其他组件分离，未来替换也方便一些</li></ul><h3 id="如何确保分布式数据库etcd的一致性"><a href="#如何确保分布式数据库etcd的一致性" class="headerlink" title="如何确保分布式数据库etcd的一致性"></a>如何确保分布式数据库etcd的一致性</h3><p>etcd使用RAFT一致性算法来保证这一点，确保在任何时间点，每个节点的状态要么是大部分当前的状态，要么就是之前确认过的状态。</p><h3 id="为什么etcd实例数量应该为奇数"><a href="#为什么etcd实例数量应该为奇数" class="headerlink" title="为什么etcd实例数量应该为奇数"></a>为什么etcd实例数量应该为奇数</h3><p>由于Raft算法在做决策时需要超半数节点的投票，所以etcd集群一般推荐奇数节点，如3、5或者7个节点构成一个集群。</p><p>偶数节点虽然多了一台机器，但是容错能力是一样的，也就是说，你可以设置偶数节点，但没增加什么能力，还浪费了一台机器。同时etcd 是通过复制数据给所有节点来达到一致性，因此偶数的多一台机器增加不了性能，反而会拉低写入速度。<br><a href="https://blog.csdn.net/u013256816/article/details/113153693">https://blog.csdn.net/u013256816/article/details/113153693</a><br><a href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p><h2 id="API服务器"><a href="#API服务器" class="headerlink" title="API服务器"></a>API服务器</h2><h3 id="API服务器做了什么"><a href="#API服务器做了什么" class="headerlink" title="API服务器做了什么"></a>API服务器做了什么</h3><ul><li>通过认证插件认证客户端: 通过配置在API服务器上的一个或者多个认证插件实现。API会轮流调用这些插件，直到确认谁发送了该请求。这个是通过抽取客户端证书或者HTTP头获取的。插件会抽取客户端的用户名，用户ID，归属组等</li><li>通过授权插件授权客户端：通过配置在API服务器上的一个或者多个授权插件实现。它们的作用时决定认证的用户是否可以对请求资源执行操作。</li><li>通过准入控制插件验证AND/OR修改资源请求：如果时要修改、删除或者创建资源，请求就需要经过准入控制插件。<strong>Kubernetes 的许多高级功能都要求启用一个准入控制器</strong>，以便正确地支持该特性。 因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你期望的所有特性<br><img src="/images/K8SAPI%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="K8SAPI服务器的操作"></li></ul><h3 id="API服务器如何通知客户端资源变更"><a href="#API服务器如何通知客户端资源变更" class="headerlink" title="API服务器如何通知客户端资源变更"></a>API服务器如何通知客户端资源变更</h3><p>客户端通过创建到API服务器的HTTP连接来监听变更。通过此链接，客户端会接收到监听对象的一系列变更通知。<br><img src="/images/k8sAPI%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4.png" alt="k8sAPI服务器通知客户端资源变更"></p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度器利用API服务器监听的机制等待新建pod，然后给每个新的，没有节点集的pod分配节点。调度器通过通知kubelet创建节点，其本身并不操作pod</p><h3 id="查找复合条件的节点"><a href="#查找复合条件的节点" class="headerlink" title="查找复合条件的节点"></a>查找复合条件的节点</h3><ul><li>节点是否能满足pod对硬件资源的需求</li><li>节点是否资源耗尽</li><li>节点是否要求被调度到指定的节点</li><li>节点是否要求绑定到特定的主机端口</li><li>如果pod有要求特定类型的卷，该节点是否能为此pod加载此卷</li><li>pod是否能偶容忍节点的污点</li><li>pod是否定义了节点、pod的亲缘性和非亲缘性规则</li></ul><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器通过API服务器监听资源变更，对变更执行操作。将资源的实际状态调整为期望状态。每种资源都有一种对应的控制器<br><img src="/images/Kubernetes%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87API%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E5%90%ACAPI%20%E5%AF%B9%E8%B1%A1.png" alt="Kubernetes组件通过API服务器监听API"></p><h3 id="控制器如何协作"><a href="#控制器如何协作" class="headerlink" title="控制器如何协作"></a>控制器如何协作</h3><p>控制器通过事件链的方式进行合作。下面时创建deployment时的过程。<br><img src="/images/Deployment%E8%B5%84%E6%BA%90%E6%8F%90%E4%BA%A4%E5%88%B0API%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%93%BE.png" alt="Deployment资源提交到API服务器的事件链"></p><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>kubelet负责所有运行在工作节点上的内容组件</p><ul><li>它的第一个任务就是在API服务器中创建一个Node资源来注册该节点</li><li>然后需要持续监控API服务器是否把该节点分配给pod，然后启动pod</li><li>其也是运行容器存活探针的组件当探针报错的时候，他会重启容器。</li><li>pod从API服务器删除时，kubelet终止容器，并通知服务器pod已经被终止</li></ul><h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>kube-proxy用于确保客户端可以通过kubernetes API 连接到你定义的服务，确保对服务IP和端口的连接最终能到达支持服务的某个pod处。如果有多个pod，它会发挥负载均衡的作用。<br>kube-proxy除了监控API对service的更改，也监控对endpoint的更改</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>userspace代理模式<br><img src="/images/userspace%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="userspace代理模式"></li><li>iptables代理模式<br><img src="/images/iptables%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="iptables代理模式"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S架构</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E7%AE%80%E4%BB%8B/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><h2 id="K8S架构"><a href="#K8S架构" class="headerlink" title="K8S架构"></a>K8S架构</h2><p><img src="/images/k8s%E7%BB%84%E4%BB%B6.png" alt="K8S组件"><br>K8S集群由多个节点组成，这些节点被分为两种类型</p><ul><li>主节点：承载K8S控制和管理整个集群系统的控制面板</li><li>工作节点：运行着用户实际部署的应用</li></ul><h3 id="主节点：控制面板-Control-Plane-Components"><a href="#主节点：控制面板-Control-Plane-Components" class="headerlink" title="主节点：控制面板(Control Plane Components)"></a>主节点：控制面板(Control Plane Components)</h3><p>控制平面用户控制集群，对集群做出全局决策(比如调度)，以及检测和响应集群事件。<br>它包含多个组件，组件可以运行在单个节点或者通过副本运行在多个主节点来保证高可用。</p><p>其中组件包括：</p><ul><li>Kubernetes API server: 该组件公开了 Kubernetes API。 API 服务器是的前端</li><li>Scheduler：调度应用</li><li>Controller manager：执行集群级别的功能，如复制组件、持续跟踪工作节点、处理失败节点。</li><li>etcd：可靠分布式数据库，能持久化存储集群配置</li><li>Cloud Controller Manager(Optional)：云控制器管理器是指嵌入特定云的控制逻辑组件。 允许您链接聚合到云提供商的应用编程接口中， 并分离出相互作用的组件与您的集群交互的组件。</li></ul><h3 id="工作节点：Node"><a href="#工作节点：Node" class="headerlink" title="工作节点：Node"></a>工作节点：Node</h3><p>工作节点是运行容器化应用的机器。维护运行的 Pod 并提供 Kubernetes 运行环境。<br>其中组件包括：</p><ul><li>容器运行时（Container Runtime）：Docker、rtk或其他容器类型</li><li>Kubelet：一个在集群中每个节点（node）上运行的代理。与API server进行通信，并管理它所在节点的容器。</li><li>Kubernetes Service Proxy(kube-proxy)：集群中每个节点上运行的网络代理。负责组件之间的负载均衡网络。</li></ul><h2 id="K8S的优势"><a href="#K8S的优势" class="headerlink" title="K8S的优势"></a>K8S的优势</h2><ul><li>简化应用部署</li><li>更好地利用硬件</li><li>健康检查和自修复</li><li>自动扩容</li><li>简化应用部署</li></ul><h2 id="K8S部署过程"><a href="#K8S部署过程" class="headerlink" title="K8S部署过程"></a>K8S部署过程</h2><p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.png" alt="K8S部署过程"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S网络</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E7%BD%91%E7%BB%9C/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/k8s%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-网络"><a href="#k8s-网络" class="headerlink" title="k8s 网络"></a>k8s 网络</h1><h2 id="跨pod网络"><a href="#跨pod网络" class="headerlink" title="跨pod网络"></a>跨pod网络</h2><p>pod用于同通信的网络必须是：pod自己认为的IP地址一定和所有其他节点认为该pod拥有的IP地址一致</p><p>k8s规定pod之间必须通过非NAT网络进行连接。</p><p><img src="/images/Kubernetes%E8%A7%84%E5%AE%9Apod%E5%BF%85%E9%A1%BB%E9%80%9A%E8%BF%87%E9%9D%9ENAT%E7%BD%91%E7%BB%9C%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5.png" alt="Kubernetes规定pod必须通过非NAT网络进行连接"></p><h3 id="同节点pod通信"><a href="#同节点pod通信" class="headerlink" title="同节点pod通信"></a>同节点pod通信</h3><p>在同一个节点上的pod通过虚拟Ethernet接口连接到同一个桥接来达到pod之间的通信<br><img src="/images/%E5%90%8C%E4%B8%80%E8%8A%82%E7%82%B9%E7%9A%84pod%E9%80%9A%E4%BF%A1.png" alt="同一节点的pod通信"></p><h3 id="不同节点的pod通信"><a href="#不同节点的pod通信" class="headerlink" title="不同节点的pod通信"></a>不同节点的pod通信</h3><p>不同节点的pod，可以通过overlay或者underlay网络或者是常规路由进行通信。</p><p><img src="/images/%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84pod%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.png" alt="不同节点上的pod之间的通信"><br>但连接到相同的网关、之间没有任何路由的时候有效。否则，路由器会扔包，因为IP是私有的。虽然能通过配置路由的方式解决，但是随着节点数增加，配置会变得非常困难。<br>最终可以通过SDN(软件定义网络)解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S 服务</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/service/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/service/</url>
      
        <content type="html"><![CDATA[<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><strong>K8S服务是一种为一组功能相同的pod提供单一不变的接入点的资源</strong>。当服务存在时，它的IP地址和端口不会改变。客户端通常通过该IP和端口使用服务。IP地址时虚拟的，没有分配给任何网络接口。<br>服务分为对内服务（内部集群访问服务）和对外服务（连接集群外部的服务）</p><p>客户端通过IP地址和端口好建立连接，这些连接会被路由到提供该服务的任意一个pod上。这样客户端就不需要知道每个单独提供服务的pod的地址。</p><h2 id="服务存在的意义"><a href="#服务存在的意义" class="headerlink" title="服务存在的意义"></a>服务存在的意义</h2><ol><li>pod需要一种寻找其他pod的方法来使用其他pod提供的服务，然而pod是短暂，随时会启动和关闭。因此无法在用户端文件中明确指明服务的精确的IP地址或者主机名来配置每个客户端的应用</li><li>k8s在pod启动前会给已经调度到节点上的pod分配IP地址，因此客户端不能提前知道提供服务的地址</li><li>水平伸缩意为多个pod可能会提供相同的服务，每个pod都有自己的IP地址，而客户端无需关心后端体哦那个服务的pod数量以及各自对应的ip地址。</li></ol><h2 id="内部集群访问服务"><a href="#内部集群访问服务" class="headerlink" title="内部集群访问服务"></a>内部集群访问服务</h2><h3 id="向服务发送请求的方法"><a href="#向服务发送请求的方法" class="headerlink" title="向服务发送请求的方法"></a>向服务发送请求的方法</h3><ul><li>创建一个pod，它将请求发送到服务的集群IP并记录响应。可以通过查看pod的日志检查服务的响应</li><li>使用ssh远程登录到其中一个k8s节点上，然后使用curl命令</li><li>通过kubectl exec命令在一个已经存在的pod中执行curl命令</li></ul><h3 id="在容器中远程执行命令"><a href="#在容器中远程执行命令" class="headerlink" title="在容器中远程执行命令"></a>在容器中远程执行命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec hello-minikube-69485c8fcc-zgknv -- curl -s http://10.104.111.222</span><br></pre></td></tr></table></figure><p>“–”双横杆代表这kubectl命令结束，其后面的内容是pod内部执行的命令<br>命令运行的过程：</p><p><img src="/images/kubectl%20exec%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="exec运行过程"></p><h3 id="会话亲和性"><a href="#会话亲和性" class="headerlink" title="会话亲和性"></a>会话亲和性</h3><p>可以通过设置sessionAffinity：ClientIP 来指定客户端产生的所有请求每次都指向同一个pod</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h4 id="DNS-服务发现"><a href="#DNS-服务发现" class="headerlink" title="DNS 服务发现"></a>DNS 服务发现</h4><h4 id="FQDN（全限定域名）连接服务"><a href="#FQDN（全限定域名）连接服务" class="headerlink" title="FQDN（全限定域名）连接服务"></a>FQDN（全限定域名）连接服务</h4><h2 id="连接集群外部的服务"><a href="#连接集群外部的服务" class="headerlink" title="连接集群外部的服务"></a>连接集群外部的服务</h2><h3 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h3><p>服务和pod之间并不是直接相连的。而是通过endpoint相连。<br><strong>Endpoint资源就是暴露一个服务的IP地址和端口的列表</strong></p><h3 id="将服务暴露给外部客户端的方式"><a href="#将服务暴露给外部客户端的方式" class="headerlink" title="将服务暴露给外部客户端的方式"></a>将服务暴露给外部客户端的方式</h3><ul><li>将服务的类型设置为NodePart</li><li>将服务的类型设置为LoadBalance</li><li>创建一个Ingress资源</li></ul><h4 id="NodePort类型的服务"><a href="#NodePort类型的服务" class="headerlink" title="NodePort类型的服务"></a>NodePort类型的服务</h4><p>创建NodePart服务，可以让k8s在其所有节点上保留一个端口(所有节点都使用相同的端口号)，并将传入的连接转发给作为服务部分的Pod。<br><img src="/images/%E5%A4%96%E9%83%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E8%BF%87NodePort%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AEpod%E8%BF%87%E7%A8%8B.png" alt="外部客户端通过NodePort服务访问pod过程"></p><h4 id="LoadBalance类型的服务"><a href="#LoadBalance类型的服务" class="headerlink" title="LoadBalance类型的服务"></a>LoadBalance类型的服务</h4><p>LoadBalance服务是NodePort服务的扩展。负载均衡器拥有自己独一无二的可公开访问的IP地址，并将所有连接重定向到服务。可以通过负载均衡器的IP地址访问服务。<br><img src="/images/%E5%A4%96%E9%83%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5LoadBalance%E6%9C%8D%E5%8A%A1.png" alt="外部客户端连接LoadBalance服务"></p><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><h5 id="Ingress产生的意义"><a href="#Ingress产生的意义" class="headerlink" title="Ingress产生的意义"></a>Ingress产生的意义</h5><p>当使用LoadBalance服务的时候，每个LoadBalance服务都需要自己的负载均衡器，以及独立的共有IP地址。而Ingress只需要一个公网IP就能为许多服务提供访问，当客户端向Ingress发送请求的时候，Ingress会根据请求的主机名和路径决定请求转发到的服务。</p><h5 id="Ingress的工作原理"><a href="#Ingress的工作原理" class="headerlink" title="Ingress的工作原理"></a>Ingress的工作原理</h5><p>Ingress控制器不会将请求转发给该服务，而是用它来选择一个pod<br><img src="/images/%E9%80%9A%E8%BF%87ingress%E8%AE%BF%E9%97%AEpod.png" alt="通过ingress访问pod"></p><h5 id="Ingress处理TLS传输"><a href="#Ingress处理TLS传输" class="headerlink" title="Ingress处理TLS传输"></a>Ingress处理TLS传输</h5><p>客户端到Ingress的通信时加密的，而控制和后端的pod之间的通信则不是。运行在pod上的应用不需要支持TLS。因此如果web服务器在pod内运行，它只能收到HTTP请求，并让Ingress控制器负责处理和TLS相关的所有内容。<br>而要使控制器能这么做，需要将证书和私钥附加到Ingress。</p><h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><h3 id="就绪探针存在的意义"><a href="#就绪探针存在的意义" class="headerlink" title="就绪探针存在的意义"></a>就绪探针存在的意义</h3><p>Ingress会将请求发送到pod，如果这个pod没有准备好，那么就无法处理请求。这个pod可能需要时间加载配置或数据，或者可能需要执行预热过程以防止第一个用户请求太长影响体验。<br>就绪探针的作用就是让Ingress认为pod是否准备好接受请求</p><h3 id="就绪探针的类型"><a href="#就绪探针的类型" class="headerlink" title="就绪探针的类型"></a>就绪探针的类型</h3><ul><li>EXEC探针</li><li>HTTP GET探针</li><li>TCP socket探针</li></ul><h3 id="探针的操作"><a href="#探针的操作" class="headerlink" title="探针的操作"></a>探针的操作</h3><p>就绪探测器会定时调用，并确定特定的pod是否接受客户端亲求，当容器的准备就绪探测返回成功的时候，表示容器已经准备好接受请求。而这一个就绪状态的判定使应用程序开发人员的责任。</p><p>与存活探针通过杀死异常的容器并用新的容器来保持pod正常工作不同。容器若没有通过就绪检查，则不会被终止或者重新启动。而是将该容器从端点对象中移除，使连接该服务的客户端不会被重定向到这个pod。<br><img src="/images/%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88%E5%A4%B1%E8%B4%A5.png" alt="就绪探针失败"></p><h3 id="探针的实际作用"><a href="#探针的实际作用" class="headerlink" title="探针的实际作用"></a>探针的实际作用</h3><ul><li>务必定义就绪探针：如果没有就绪探针，新添加的pod立马就会成为服务端点。服务启动但是尚未准备好接受请求连接时，将会看到连接被拒绝类型的错误。</li><li>不要将停止pod的逻辑加入到就绪探针中：只要删除了容器，k8s将会从服务中删除该容器</li></ul><h2 id="无法访问pod的trouble-shooting"><a href="#无法访问pod的trouble-shooting" class="headerlink" title="无法访问pod的trouble shooting"></a>无法访问pod的trouble shooting</h2><ol><li>确保集群内连接到服务的集群IP</li><li>不要通过ping服务IP来判断服务是否可访问</li><li>如果定义了就绪探针，确保它返回成功</li><li>确保某个容器时服务的一部分，确保其在endpoint里</li><li>如果通过FQDN访问服务不起作用，看看是否可以使用集群IP而不是FQDN来访问服务</li><li>检查是否连接到服务公开的端口，而不是目标端口</li><li>尝试直接连接pod IP 以确认pod正在接受正确端口上的连接</li><li>如果无法通过pod的IP访问应用，确保应用不是仅半丁本地主机</li></ol><h2 id="服务时如何实现的？"><a href="#服务时如何实现的？" class="headerlink" title="服务时如何实现的？"></a>服务时如何实现的？</h2><ol><li>当API服务中创建一个新的service的时候，虚拟的IP地址就会分配给它。</li><li>之后很短之间内，API服务器就会通知所i有运行在工作节点上的kube-proxy客户端有一个新的service被创建。</li><li>每个kube-proxy会让该服务在自己运行的节点上可寻址。kube-proxy会配置一些iptables规则处理数据包，内核确保每个目的地的IP/端口对的数据包被解析，目的地址被修改。</li></ol><p><em>Note:kube-proxy除了监控API对service的更改，也监控对endpoint的更改</em></p><p><img src="/images/kube-proxy%E8%AE%A9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%83%BD%E9%80%9A%E8%BF%87Service%E8%BF%9E%E6%8E%A5%E5%88%B0pod.png" alt="proxy让客户端能通过Service连接到pod"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S API</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Downward-API"><a href="#Downward-API" class="headerlink" title="Downward API"></a>Downward API</h1><h2 id="Downward-API存在的意义"><a href="#Downward-API存在的意义" class="headerlink" title="Downward API存在的意义"></a>Downward API存在的意义</h2><p>对于Pod、运行前的预设的数据，我们可以通过ConfigMap和Secret卷或者环境变量进行设置。但是对于一些不能预先知道的数据，比如pod的IP、主机名或者使pod自身的名称、pod的标签和注解等是不可行的。Downward API 允许我们通过环境变量或者文件(downwardAPI卷)传递pod的元数据，同时将<strong>元数据与数据分离</strong></p><p><img src="/images/Downward%20API%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2pod%E5%85%83%E6%95%B0%E6%8D%AE.png" alt="API通过环境变量或者文件对外暴露pod元数据"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul><li>通过环境变量</li><li>通过卷</li></ul><h1 id="Kubernetes-API"><a href="#Kubernetes-API" class="headerlink" title="Kubernetes API"></a>Kubernetes API</h1><h2 id="Kubernetes-API-存在的意义"><a href="#Kubernetes-API-存在的意义" class="headerlink" title="Kubernetes API 存在的意义"></a>Kubernetes API 存在的意义</h2><p>Downward API提供了一种简单的方式，将pod和容器的元数据传递给它们内部运行的进程，但这种方式仅仅可以暴露一个pod自身的元数据，而且只可以暴露部分元数据。</p><p>而<strong>通过Kuberneters API，应用可以知道其他pod的信息，甚至是集群的信息</strong>。</p><h2 id="pod-如何与kubernetes交互"><a href="#pod-如何与kubernetes交互" class="headerlink" title="pod 如何与kubernetes交互"></a>pod 如何与kubernetes交互</h2><ol><li>应用应该验证API服务器的证书是否是证书机构所签发的。证书在ca.crt文件中</li><li>应用应该将它在token文件中持有的凭证通过Authorization标头获取的API服务器的授权</li><li>当对pod所在命名空间的API对象进行CRUD操作时，应该是使用namespace文件夹来传递命名空间信息到API服务器<br><img src="/images/%E4%B8%8EAPI%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.png" alt="Pod与API服务器进行交互"><h2 id="ambassador容器简化API服务器交互"><a href="#ambassador容器简化API服务器交互" class="headerlink" title="ambassador容器简化API服务器交互"></a>ambassador容器简化API服务器交互</h2>在ambassador容器里面运行kubectl proxy命令作为代理。而应用容器向代理发送请求，而不是通过直接向API服务发送请求。<br>这种模式下，将加密，授权，服务器验证的工作交给ambassador容器。应用容器通过http来与ambassador容器交互，而ambassador通过HTTPS来连接API服务器，对应用容器来说，安全问题是透明的。</li></ol><p><img src="/images/%E4%BD%BF%E7%94%A8ambassador%E8%BF%9E%E6%8E%A5API%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="使用ambassador连接API服务器"></p><p><img src="/images/%E4%BD%BF%E7%94%A8ambassador%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%9E%E6%8E%A5API%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="使用ambassador容器中连接API服务器"></p><h2 id="使用客户端与API服务器交互"><a href="#使用客户端与API服务器交互" class="headerlink" title="使用客户端与API服务器交互"></a>使用客户端与API服务器交互</h2><h2 id="为什么有了Kubernetes-API-还需要-Downward-API"><a href="#为什么有了Kubernetes-API-还需要-Downward-API" class="headerlink" title="为什么有了Kubernetes API 还需要 Downward API"></a>为什么有了Kubernetes API 还需要 Downward API</h2><p>对于容器来说，有时候拥有自己的信息是很有用的，可避免与 Kubernetes 过度耦合。 Downward API 使得容器使用自己或者集群的信息，而不必通过 Kubernetes 客户端或 API 服务器来获得</p><h2 id="为什么要将元数据与数据分离"><a href="#为什么要将元数据与数据分离" class="headerlink" title="为什么要将元数据与数据分离"></a>为什么要将元数据与数据分离</h2><ol><li>设计简单，管理容易。元数据基于Pod级别，而不是基于容器级别，保证容器挂了而不影响元数据。</li><li>容器不是持久的，如果元数据变更，容器之间相互同步元数据比较难处理。</li><li>集中放置有利于做热备份</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes副本机制</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes副本机制"><a href="#kubernetes副本机制" class="headerlink" title="kubernetes副本机制"></a>kubernetes副本机制</h1><h2 id="存活探针-Liveness-probe"><a href="#存活探针-Liveness-probe" class="headerlink" title="存活探针(Liveness probe)"></a>存活探针(Liveness probe)</h2><p>K8S能够通过探针检查容器是否正在运行，可以为pod中的每个容器单独指定存活探针，如果探测失败，k8s将定期执行探针并重新启动容器。<br>重启容器这项任务是由Kubelet执行的，而Kubelet本身是在Node里的，因此如果Node失效，Kubelet将无法执行任何操作。</p><h3 id="K8S探测容器的机制类型"><a href="#K8S探测容器的机制类型" class="headerlink" title="K8S探测容器的机制类型"></a>K8S探测容器的机制类型</h3><ul><li>HTTP GET探针：执行HTTP GET请求，如果收到错误响应状态码或者没有响应，则重启容器。</li><li>TCP套接字探针：和指定端口建立TCP连接，如果建立失败，则重启容器</li><li>Exec探针：在容器内执行任意命令，并检查命令的退出状态码，如果状态码不为0，则重启容器。</li></ul><h3 id="存活探针创建原则"><a href="#存活探针创建原则" class="headerlink" title="存活探针创建原则"></a>存活探针创建原则</h3><h4 id="存活探针应该检查什么"><a href="#存活探针应该检查什么" class="headerlink" title="存活探针应该检查什么"></a>存活探针应该检查什么</h4><ol><li>仅仅检查服务器是否相应</li><li>一定要检查应用程序内部，而没有任何外部因素的影响，如数据库的影响<h4 id="保持探针轻量"><a href="#保持探针轻量" class="headerlink" title="保持探针轻量"></a>保持探针轻量</h4></li><li>存活探针不应该消耗太多计算资源。探针的执行频率相对高，必须在1s内执行完毕<h4 id="无须在探针中实现重试循环"><a href="#无须在探针中实现重试循环" class="headerlink" title="无须在探针中实现重试循环"></a>无须在探针中实现重试循环</h4></li><li>探针的失败阈值时可配置的，并且在容器被终止前探针必须失败多次。</li></ol><h2 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h2><h3 id="ReplicationController的作用"><a href="#ReplicationController的作用" class="headerlink" title="ReplicationController的作用"></a>ReplicationController的作用</h3><p>ReplicationController的作用会持续监控正在运行的pod列表，并保证相应“类型”的pod和期望相符。运行的pod太少，它会根据pod模板创建新的副本。如果pod太多，他将删除多余的副本。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>label selector(标签选择器)：用于确定ReplicationController作用域中有哪些pod</li><li>replica count(副本个数)：指定应运行的pod数量</li><li>pod template：用于创建新的pod副本</li></ul><h3 id="协调流程"><a href="#协调流程" class="headerlink" title="协调流程"></a>协调流程</h3><p><img src="/images/ReplicationController%E5%8D%8F%E8%B0%83%E6%B5%81%E7%A8%8B.png" alt="ReplicationController协调流程"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>确保一个pod(多个pod副本)持续运行</li><li>集群发生故障时，将为故障节点上运行的所有pod创建替代副本</li><li>轻松实现pod的水平伸缩</li></ul><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><h3 id="与ReplicationController区别"><a href="#与ReplicationController区别" class="headerlink" title="与ReplicationController区别"></a>与ReplicationController区别</h3><p>两者的行为完全相同，但是ReplicationSet的标签表达能力更强。ReplicationController的标签选择器只允许包含某个标签的匹配pod。<br>ReplicationSet的标签选择器还允许匹配缺少某个标签的pod，或包含特定标签名的pod。</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operaiton:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><p>ReplicaSet可以使用matchLabel或者时matchExpressions进行选择。</p><p>matchExpressions 有四种类型</p><ul><li>In</li><li>NotIn</li><li>Exists</li><li>DoseNotExist</li></ul><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><h3 id="DaemonSet存在意义"><a href="#DaemonSet存在意义" class="headerlink" title="DaemonSet存在意义"></a>DaemonSet存在意义</h3><p>ReplicationController和ReplicaSet都用于k8s集群上部署特定数量的pod，但是不能保证每个节点上都正好运行一个pod实例。比如，希望在每个节点上运行日志收集器和资源监控器，以及k8s自己的kube-proxy进程。<br><strong>DaemonSet可以确保一个pod匹配它的选择器并且在每个节点上运行。而不是随机分布在集群上</strong></p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><h3 id="Job存在的意义"><a href="#Job存在的意义" class="headerlink" title="Job存在的意义"></a>Job存在的意义</h3><p>无论时ReplicationController、ReplicaSet还是DaemonSet，都是对持续运行的pod进行管理。它们会持续运行任务，永远达不到完成态。<br><strong>Job允许运行一种pod，该pod在内部进程成功结束时，不重启容器，一旦任务完成，pod就会被认为是完成的状态</strong><br>Job管理的pod会一直被重新安排，直道成完成任务。</p><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>定时的job<br>Example of scheduled job:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 3 * * *&quot;</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">JobTemplate:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h4><p>CronJob资源会创建Job资源，然后Job资源创建pod。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>CronJob总是为计划中配置的每个执行创建一个Job。但是可能会同时创建两个Job，或者没有创建。<br>为了解决第一个问题，你的任务必须是幂等的。对于第二个问题，确保下一个任务运行完成本应该由上一次的(错过的)运行完成的任何工作</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S卷</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%8D%B7/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h1><p><strong>卷是pod的一个组成部分</strong>。它被绑定到pod的生命周期里面，只有pod存在时，才会存在。用于共享pod内的磁盘存储。</p><h2 id="卷存在的意义"><a href="#卷存在的意义" class="headerlink" title="卷存在的意义"></a>卷存在的意义</h2><p>pod中每个容器都有自己独立的文件系统，因为文件系统来自于容器镜像<br>如果pod中的每个容器在不共享磁盘存储的情况下，用多个容器在一个pod内就没有存在的意义，因为pod里的容器不能相互访问对方的文件。</p><p><img src="/images/%E5%AE%B9%E5%99%A8%E4%B8%8D%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%9A%84pod.png" alt="容器不共享磁盘存储的pod"></p><p>而K8S里面通过卷来解决这个问题。<br><img src="/images/%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E5%8D%B7.png" alt="容器挂载卷"></p><h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><ul><li>emptyDir：用于存储临时数据的简单空目录。非持久的存储</li><li>hostPath：将目录从工作节点的文件系统挂载到pod</li><li>gitRepo：通过检出Git仓库的内容来初始化的卷</li><li>nfs：挂载到pod中的NFS共享卷</li><li>gcePersistentDisk、awsElastic等用于挂载云服务商提供的特定存储类型</li><li>cinder、glusterfs等用于挂载其他类型的网络存储</li><li>configMap、secret、downwardAPI:用于K8S部分资源和集群信息公开为pod的特殊类型券</li><li>persistentVolumeClaim:一种使用预置或者动态配置持久性存储</li></ul><h2 id="持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）"><a href="#持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）" class="headerlink" title="持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）"></a>持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）</h2><p>持久卷不属于任何命名空间，它跟节点一样使集群层面的资源。<br>当一个持久卷和一个持久卷声明绑定时，这个持久卷不可以被另外一个持久卷声明所绑定和使用</p><h3 id="持久卷和持久卷声明的意义"><a href="#持久卷和持久卷声明的意义" class="headerlink" title="持久卷和持久卷声明的意义"></a>持久卷和持久卷声明的意义</h3><p>K8s中，为了使应用能正常请求存储资源，同时避免处理基础设施细节。因此引入了持久卷和持久卷声明两种资源。</p><h3 id="持久卷和持久卷声明和底层存储之间的关系"><a href="#持久卷和持久卷声明和底层存储之间的关系" class="headerlink" title="持久卷和持久卷声明和底层存储之间的关系"></a>持久卷和持久卷声明和底层存储之间的关系</h3><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8D%B7%E5%92%8C%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E%E5%92%8C%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="持久卷和持久卷声明和底层存储之间的关系"></p><p>持久卷不属于任何命名空间，它跟节点一样使集群层面的资源。但是持久卷声明使在特定命名空间中创建的，所以持久卷和持久卷声明只能被同一命名空间内的pod创建使用<br><img src="/images/%E6%8C%81%E4%B9%85%E5%8D%B7%E5%92%8C%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E%E5%92%8C%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB2.png" alt="持久卷和持久卷声明和底层存储之间的关系2"></p><h3 id="PCV访问模式"><a href="#PCV访问模式" class="headerlink" title="PCV访问模式"></a>PCV访问模式</h3><ul><li>RWO:ReadWriteOnce 仅允许单个节点挂载读写</li><li>ROX:ReadOnlyMany 允许多个挂载只读</li><li>RWX:ReadWriteMany 允许多个节点挂载读写</li></ul><h2 id="动态卷"><a href="#动态卷" class="headerlink" title="动态卷"></a>动态卷</h2><p>StorageClass 本质上是一个持久卷的配置，是一个集群级别的资源。为管理员提供了描述存储 “类” 的方法。<br>在PVC中如果不声明存储类，则使用默认的存储类。可以将spec.storageClassName设置为空字符串””，表示使用手动预先配置的持久卷，而不是动态配置的新PV。</p><h3 id="StorageClass存在的意义"><a href="#StorageClass存在的意义" class="headerlink" title="StorageClass存在的意义"></a>StorageClass存在的意义</h3><ol><li>减少了用户对于底层存储资源各方面细节的关注，只需要关注自己创建的PVC资源，引用存储类的对应StorageClass资源即可</li><li>集群管理员将从多次创建PV这项工作中解脱出来，只要有了StorageClass资源，PVC创建引用好后，k8s系统会自动为其创建合适的PV，并且将PV和PVC绑定好，从而实现动态的资源供应</li></ol><h3 id="持久卷动态配置过程"><a href="#持久卷动态配置过程" class="headerlink" title="持久卷动态配置过程"></a>持久卷动态配置过程</h3><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8D%B7%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B.png" alt="持久卷动态配置过程"></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S Deployment</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/kubernetes/%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Deployment存在的意义"><a href="#Deployment存在的意义" class="headerlink" title="Deployment存在的意义"></a>Deployment存在的意义</h2><ol><li>因为使用Kubectl rolling-update 升级是客户端升级。如果中途失去了网络连接，升级进程就会中断。pod和ReplicationController最终会处于中间状态。</li><li>使用Deployment可以定义单个Deployment的资源所需要达到的状态，并让kubernetes处理中间的状态。</li><li>Deployment会创建新的ReplicaSet，但是用户并不需要关系和维护ReplicaSet，所有的操作都是再Deployment上面完成的，和管理多个ReplicationController相比，管理单个Deployment对象容易得多。</li></ol><h2 id="Deployment升级应用过程"><a href="#Deployment升级应用过程" class="headerlink" title="Deployment升级应用过程"></a>Deployment升级应用过程</h2><h3 id="Deployment创建"><a href="#Deployment创建" class="headerlink" title="Deployment创建"></a>Deployment创建</h3><p>当Deployment创建的时候，ReplicaSet也会随之创建。在使用Deployment的时候，pod是由ReplicaSet创建和管理的，而不是由Deployment创建和管理的<br><img src="/images/Deployment%E4%B8%8Epod%E5%85%B3%E7%B3%BB.png" alt="Deployment与pod关系"></p><h3 id="Deployment触发升级"><a href="#Deployment触发升级" class="headerlink" title="Deployment触发升级"></a>Deployment触发升级</h3><p>通过修改Deployment资源中的Pod模板(字段)，就可以触发deployment的升级。</p><p><em>Note：如果deployment的pod模板引用ConfigMap或者是Secret，那么更改ConfigMap资源本身不会触发Deployment的升级。如果需要，可以通过创建一个新的ConfigMap，并修改deployment模板引用新的ConfigMap</em></p><p>当Deployment升级的时候，会创建一个新的ReplicaSet，然后再慢慢扩容。原本旧的ReplicaSet就会慢慢缩容为0,而不是删除。这样做的意义是为了方便Deployment回滚。</p><h3 id="Deployment回滚"><a href="#Deployment回滚" class="headerlink" title="Deployment回滚"></a>Deployment回滚</h3><p>因为Deployment保留了旧的ReplicaSet，因此很容易地能做到版本地回滚。旧版本的ReplicaSet过多容易导致ReplicaSet列表过于混乱，因此可以通过spec.revisionHistoryLimit限制历史版本的数量。<br><img src="/images/Deployment%E4%B8%8EReplicaSet.png" alt="Deployment与ReplicaSet"></p><h3 id="控制升级的速率"><a href="#控制升级的速率" class="headerlink" title="控制升级的速率"></a>控制升级的速率</h3><p>通过spec.strategy.rollingUpdate.maxUnavailable来控制最大不可用的Pod数量<br>通过spec.strategy.rollingUpdate.maxSurge来控制最大可同时存在pod的数量</p><h3 id="Deployment的升级策略"><a href="#Deployment的升级策略" class="headerlink" title="Deployment的升级策略"></a>Deployment的升级策略</h3><p>Deployment的升级策略可以通过spec.strategy指定。</p><ul><li>滚动更新策略：RollingUpdate</li><li>重新创建策略：Recreate</li></ul><h2 id="回滚-Deplyment"><a href="#回滚-Deplyment" class="headerlink" title="回滚 Deplyment"></a>回滚 Deplyment</h2><h2 id="为什么旧的ReplicaSet不删除"><a href="#为什么旧的ReplicaSet不删除" class="headerlink" title="为什么旧的ReplicaSet不删除"></a>为什么旧的ReplicaSet不删除</h2><p>用于版本回滚，可以使用Deployment的revisionHistoryLimit属性限制历史版本的数量</p><h2 id="应用升级策略"><a href="#应用升级策略" class="headerlink" title="应用升级策略"></a>应用升级策略</h2><ul><li>滚动更新：程序需要支持两个版本的对外服务。</li><li>剔除旧版本，再更新新版本：会导致服务短暂不可用。</li></ul><h2 id="为什么K8S抛弃使用Kubectl-rolling-update滚动升级-ReplicationController滚动升级"><a href="#为什么K8S抛弃使用Kubectl-rolling-update滚动升级-ReplicationController滚动升级" class="headerlink" title="为什么K8S抛弃使用Kubectl rolling-update滚动升级(ReplicationController滚动升级)"></a>为什么K8S抛弃使用Kubectl rolling-update滚动升级(ReplicationController滚动升级)</h2><p>kubectl rolling-update 这个方式会直接更新pod和ReplicationController的标签。<strong>更重要的是Kubectl 只是执行滚动升级的客户端</strong>，因此调整ReplicaitonController的副本数，是由客户端执行的。 如果再执行升级的时候kubectl失去了网络连接，升级进程就会中断。pod和ReplicationController最终会处于中间状态。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CPU基本指标</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/CPU%E6%8C%87%E6%A0%87/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/CPU%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU基本指标"><a href="#CPU基本指标" class="headerlink" title="CPU基本指标"></a>CPU基本指标</h1><h2 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h2><p>平均负载是指单位时间内，系统处于可运行状态(Running和Runnable)和不可中断状态(如进行I/O)的平均进程数，也就是平均活跃进程数</p><h3 id="瓶颈地"><a href="#瓶颈地" class="headerlink" title="瓶颈地"></a>瓶颈地</h3><ul><li>CPU密集型进程导致的</li><li>I/O 繁忙</li></ul><h2 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h2><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>上下文切换类型：进程上下文切换、线程上下文切换以及中断上下文切换</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待CPU的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待CPU时间最长的进程来运行。</p><h4 id="触发进程调度的一些情景"><a href="#触发进程调度的一些情景" class="headerlink" title="触发进程调度的一些情景"></a>触发进程调度的一些情景</h4><ul><li>进程执行完毕</li><li>时间片切换</li><li>系统资源不足</li><li>进程自主挂起</li><li>有更高优先级的进程运行时</li><li>硬件中断</li></ul><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程上下文切换的情况：</p><ul><li>前后两个线程属于不同进程。因为资源不共享，所以切换过程就跟进程上下文切换是一样</li><li>前后两个线程属于同一个进程。因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ul><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>中断上下文只包括内核态中断服务程序执行所必须的状态，包括CPU寄存器，内核堆栈，硬件终端参数<br>中断处理比进程进程拥有更高的优先级</p><h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>中断处理分为上半部分和下半部分</p><ul><li>上半部分对应硬件中断，用来快速处理中断</li><li>下半部分对应软中断，用来异步处理上半部分未完成的工作</li></ul><p>linux软中断包括网络手法、定时、调度、RCU锁等类型。可有通过/proc/softirqs来查看</p><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><ul><li>uptime：平均负载</li><li>top/htop：平均负载、运行队列、整体CPU使用率以及每个进程的状态和CPU使用率</li><li>atop：cpu、内存、磁盘、网络等资源的全面监控</li><li>vmstat: 系统整体的CPU使用率、上下文切换次数、中断次数、处于运行和不可中断状态的进程数量</li><li>mpstat:每个CPU的使用率和软中断次数</li><li>pidstat：查看进程的CPU、内存、I/O及上下文切换指标</li><li>/proc/softirqs:软中断类型和每个CPU上的累积中断次数</li><li>/proc/intirqs:硬中断类型和每个CPU上的累积中断次数</li><li>ps：每个进程的状态和CPU使用率</li><li>pstree：用树状形式显示所有进程之间的关系</li><li>dstat：系统整体的CPU使用率</li><li>sar：系统整体的CPU使用率，包括可配置的历史数据</li><li>strace：进程的系统调用</li><li>perf：CPU性能事件剖析。如调用链分析、CPU缓存、CPU调度等</li><li>execsnoop：监控短时进程</li></ul><h2 id="CPU-check-Flow"><a href="#CPU-check-Flow" class="headerlink" title="CPU check Flow"></a>CPU check Flow</h2><p><img src="..%5Cimage%5Cimages/CPU_check_flow.png" alt="cpu_check_flow"></p><h2 id="CPU-优化"><a href="#CPU-优化" class="headerlink" title="CPU 优化"></a>CPU 优化</h2><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><ul><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ul><h3 id="测试性能的注意"><a href="#测试性能的注意" class="headerlink" title="测试性能的注意"></a>测试性能的注意</h3><ol><li>避免测试工具干扰应用程序的性能。</li><li>避免外部环境的变化影响性能指标的评估</li></ol><h3 id="多个性能问题同时存在"><a href="#多个性能问题同时存在" class="headerlink" title="多个性能问题同时存在"></a>多个性能问题同时存在</h3><ol><li>优先优化系统资源达到瓶颈的</li><li>优先优化那些由瓶颈导致的，性能指标变化幅度最大的问题</li></ol><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><h4 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h4><ul><li>应用程序优化：排除不必要的工作，保留核心逻辑，减少循环层次、减少递归和内存动态分配等</li><li>编译器优化</li><li>算法优化：使用复杂度更低的算法</li><li>异步处理：将轮询替换为事件通知</li><li>多线程代替多进程：减少上下文切换成本</li><li>擅用缓存<h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4></li><li>CPU绑定：将进程绑定到一个或者多个CPU上，提高CPU缓存的命中率，减少跨CPU调度</li><li>CPU独占：和CPU绑定类似，将CPU分组，通过CPU亲和性机制为其分配进程</li><li>优先级调整：降低非核心应用的优先级，增高核心应用的优先级。确保核心应用得到优先处理</li><li>为进程设置资源限制：使用cgroups设置CPU的使用上限，防止某个应用问题，耗尽系统资源</li><li>NUMA(non-uniform memory access)：让CPU尽可能只访问本地内存</li><li>中断负载均衡：把中断处理过程自动负载到多个CPU上</li></ul><h4 id="避免过早优化"><a href="#避免过早优化" class="headerlink" title="避免过早优化"></a>避免过早优化</h4><ul><li>优化会带来一定复杂性，降低可维护性</li><li>需求并不是一成不变的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux IPtable</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/IPtable/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/IPtable/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux LVS</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/LVS/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/LVS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Cgroup</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/cgroups%20%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/cgroups%20%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Docker 背后的内核知识——cgroups 资源限制<br><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation">https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation</a></p><p>Linux资源管理之cgroups简介<br><a href="https://tech.meituan.com/2015/03/31/cgroups.html">https://tech.meituan.com/2015/03/31/cgroups.html</a></p><p>DOCKER基础技术：LINUX CGROUP<br><a href="https://coolshell.cn/articles/17049.html">https://coolshell.cn/articles/17049.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux cookbook</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%20cookbook/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%20cookbook/</url>
      
        <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="安装idea"><a href="#安装idea" class="headerlink" title="安装idea"></a>安装idea</h3><ol><li>创建安装目录 mkdir /opt/idea</li><li>下载IDEA安装包到这个目录并解压 tar -zxvf  ideaUI-2020.3.2.tar.gz</li><li>在桌面创建快捷方式 vi idea.desktop 添加以下内容</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[Desktop</span> <span class="string">Entry]</span></span><br><span class="line"><span class="attr">Name</span>=<span class="string">IntelliJ IDEA</span></span><br><span class="line"><span class="attr">Comment</span>=<span class="string">IntelliJ IDEA</span></span><br><span class="line"><span class="attr">Exec</span>=<span class="string">/opt/idea/idea-IC-203.7148.57/bin/idea.sh</span></span><br><span class="line"><span class="attr">Icon</span>=<span class="string">/opt/idea/idea-IC-203.7148.57/bin/idea.png</span></span><br><span class="line"><span class="attr">Terminal</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">Application</span></span><br></pre></td></tr></table></figure><h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><ol><li>安装fcitx5<br>sudo pacman -S fcitx5 fcitx5-configtool fcitx5-qt fcitx5-gtk fcitx5-chinese-addons</li><li>修改环境变量<br>vim ~/.pam_environment<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GTK_IM_MODULE</span> <span class="string">DEFAULT=fcitx</span></span><br><span class="line"><span class="attr">QT_IM_MODULE</span>  <span class="string">DEFAULT=fcitx</span></span><br><span class="line"><span class="attr">XMODIFIERS</span>    <span class="string">DEFAULT=@im=fcitx</span></span><br></pre></td></tr></table></figure></li><li>设置登陆后默认启动输入法<br>vim ~/.xprofile<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fcitx5</span> <span class="string">&amp; </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><h2 id="bash-ll-command-not-found"><a href="#bash-ll-command-not-found" class="headerlink" title="bash: ll: command not found"></a>bash: ll: command not found</h2><p>问题描述：bash: ll: command not found<br>问题原因：ll 是 “ls -l”的别名写，是别名，而不是原生自带的，所以在bash里面是找不到这个指令的。<br>问题解决：bash每次启动时候会添加每个用户下的.bashrc文件，该文件里面时bash的配置<br>         只需在该配置文件里面加上一句即可alias ll=’ls -l’,保存后再重新载入source ~/.bashrc<br>         如果时对于所有用户，则配置文件在/etc/bash.bashrc</p><h2 id="配置Java开发环境"><a href="#配置Java开发环境" class="headerlink" title="配置Java开发环境"></a>配置Java开发环境</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h5 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h5><ol><li>进入root 状态<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></li><li>更换阿里云镜像<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/fedora.repo fedora.repo.bak</span><br><span class="line">mv /etc/yum.repos.d/fedora-updates.repo fedora-updates.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/fedora.repo http://mirrors.aliyun.com/repo/fedora.repo</span><br><span class="line">wget -O /etc/yum.repos.d/fedora-updates.repo http://mirrors.aliyun.com/repo/fedora-updates.repo</span><br></pre></td></tr></table></figure></li><li>更新缓存</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf clean all</span><br><span class="line">dnf makecache</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h5 id="在Fedora-32-安装docker"><a href="#在Fedora-32-安装docker" class="headerlink" title="在Fedora 32 安装docker"></a>在Fedora 32 安装docker</h5><p><a href="https://computingforgeeks.com/how-to-install-docker-on-fedora/">https://computingforgeeks.com/how-to-install-docker-on-fedora/</a></p><h5 id="cgroups-挂载"><a href="#cgroups-挂载" class="headerlink" title="cgroups 挂载"></a>cgroups 挂载</h5><p>sudo mkdir /sys/fs/cgroup/systemd<br>sudo mount -t cgroup -o none,name=systemd cgroup /sys/fs/cgroup/systemd</p><h5 id="更换docker镜像"><a href="#更换docker镜像" class="headerlink" title="更换docker镜像"></a>更换docker镜像</h5><p><a href="https://www.jianshu.com/p/df75f9b5fcf6">https://www.jianshu.com/p/df75f9b5fcf6</a></p><h5 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S openssh</span><br><span class="line">开始服务：systemctl start sshd</span><br><span class="line">开机启动：systemctl enable sshd.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控项目</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/monitor/Zabbix/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/monitor/Zabbix/</url>
      
        <content type="html"><![CDATA[<h1 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h1><h1 id="Zabbix连接方式"><a href="#Zabbix连接方式" class="headerlink" title="Zabbix连接方式"></a>Zabbix连接方式</h1><p>Zabbix-Server 和 Zabbix-Proxy可以通过VPN，SSH,Stunnel连接</p><h2 id="Zabbix监控配置流程"><a href="#Zabbix监控配置流程" class="headerlink" title="Zabbix监控配置流程"></a>Zabbix监控配置流程</h2><p>Host Group(主机组) —&gt; Hosts(主机) —-&gt; Applications(监控项组) —-&gt; Items(监控项) —–&gt; Triggers(触发器) —-&gt; Event(事件) —-&gt; Actions(处理动作) —-&gt; User Groups(用户组) —-&gt; Users(用户) —-&gt;Medias(告警方式) —-&gt; Audit(日志审计)</p><p><img src="/images/zabbix%E8%AD%A6%E5%91%8A%E6%B5%81%E7%A8%8B.png" alt="zabbix警告流程"></p><p>Items:采集数据<br>Trigger：对采集的数据进行阈值判断，触发阈值，产生事件<br>Action：Action对达到阈值的Trigger触发警告</p><p>每一个Trigger必须对应一个Item，但是一个Item可以对应多个Trigger</p><h2 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h2><h3 id="Agent监控方式"><a href="#Agent监控方式" class="headerlink" title="Agent监控方式"></a>Agent监控方式</h3><h3 id="Trapper-监控方式"><a href="#Trapper-监控方式" class="headerlink" title="Trapper 监控方式"></a>Trapper 监控方式</h3><p>Trapper-Server，采用主动推送的方式。Trapper不需要安装客户端，Key的名称可以灵活定义。<br>再Trapper工作模式中，Zabbix数据发送的程序时zabbix-sender。</p><h3 id="SNMP监控方式"><a href="#SNMP监控方式" class="headerlink" title="SNMP监控方式"></a>SNMP监控方式</h3><p><strong>用于监控路由器、交换机、打印机、UPS或者其他开始SNMP的设备</strong><br>SNMP(Simple Network Managment Protocol) 简单网络管理协议包含两个部分：管理进程和被管理设备。SNMP 使用的时UDP协议，采用161端口发送报文，<br>管理端和被管理端的通信方式</p><ul><li>被管理端向管理端发送数据</li><li>管理端向被管理端请求获取数据</li><li>管理端向被管理端请求改变数据</li></ul><p>SNMP网络管理框架是工业上的现行标准，由3个主要部分组成，分别是管理信息结构SMI（Structure ofManagement Information）、管理信息库MIB和管理协议SNMP。<br>SNMP是管理进程（NMS）和代理进程（Agent）之间的通信协议</p><h3 id="IPMI-监控方式"><a href="#IPMI-监控方式" class="headerlink" title="IPMI 监控方式"></a>IPMI 监控方式</h3><p>IPMI(Intelligent Platform Managerment Interface)，即智能平台管理接口，用于监控服务器的物理特性，如温度、电压、电扇工作状态、电源供应和机箱入侵等。</p><p>IPMI独立于CPU BIOS和OS外自行运行，能再缺少操作系统、系统管理软件或者系统关机但有电源的情况下远端管理服务器硬件。</p><h3 id="JMX监控方式"><a href="#JMX监控方式" class="headerlink" title="JMX监控方式"></a>JMX监控方式</h3><p>JMX(Java Manager Extensions) Java扩展管理是Java平台为应用程序、设备、系统植入管理功能的架构。</p><p>JMX监控数据的获取由专门的代理程序Zabbix-Java-Gateway来负责采集。Zabbix-Java-Gateway 和JMX的Java程序通信获取数据。</p><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><h4 id="网络发现"><a href="#网络发现" class="headerlink" title="网络发现"></a>网络发现</h4><p>完成的工作：</p><ul><li>快速发现并添加主机</li><li>简单的管理</li><li>随着环境的改变而快速搭建监控系统</li></ul><p>网络发现基于的信息：</p><ul><li>IP地址段</li><li>基于服务的FTP、SSH、Web、POP3、IMAP、TCP等</li><li>从Zabbix-Agent接收到信息</li><li>从SNMP agent接收到信息<h4 id="主动方式的自动注册"><a href="#主动方式的自动注册" class="headerlink" title="主动方式的自动注册"></a>主动方式的自动注册</h4>Active Agent Auto-Registeration(主动注册功能)主要用于Agent主动且自动的向Server注册</li></ul><h4 id="Low-level-discovery"><a href="#Low-level-discovery" class="headerlink" title="Low level discovery"></a>Low level discovery</h4><p>Low level discovery可以对网卡、文件系统、SNMP OIDS进行自动发现。</p><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>数据断层原因</p><ul><li>系统负载高</li><li>TCP连接数过多</li><li>网络问题</li><li>无法获取到数据</li><li>数据库无法存储数据</li></ul><p><a href="https://blog.csdn.net/weixin_43831670/article/details/90050861">https://blog.csdn.net/weixin_43831670/article/details/90050861</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控系统</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/monitor/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/monitor/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h1><h2 id="监控系统的实现"><a href="#监控系统的实现" class="headerlink" title="监控系统的实现"></a>监控系统的实现</h2><p>监控系统大体分为两个部分：数据采集端（客户端）和数据存储分析警告展示部分（服务器端）<br>数据采集的工作模式分为主动模式（客户端主动上报数据到服务器端）和被动模式（服务器到客户端收集数据）<br>采集数据的协议分为两种：专用客户端采集协议和公用协议采集(SNMP,SSH,Telnet)</p><h2 id="监控系统的架构"><a href="#监控系统的架构" class="headerlink" title="监控系统的架构"></a>监控系统的架构</h2><ul><li>C/S：适用于监控节点不多，产生数据少，规模较小，处于同一地域</li><li>C/P/S：(Client/Proxy/Server)：适用于被监控节点多，监控类型多</li></ul><h2 id="Web监控原理"><a href="#Web监控原理" class="headerlink" title="Web监控原理"></a>Web监控原理</h2><p>Web监控即对HTTP服务的监控，模拟用户去访问网站，对特定的结果进行比较，如返回状态码，字符串等特定数据进行比较和监控，从而判断网站Web的可用性。</p><h3 id="SNMP监控方式"><a href="#SNMP监控方式" class="headerlink" title="SNMP监控方式"></a>SNMP监控方式</h3><p>使用理由：由于某些设备不能安装Agent或者安装Agent不方便</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控项目</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/monitor/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/monitor/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="监控项目"><a href="#监控项目" class="headerlink" title="监控项目"></a>监控项目</h3><h4 id="CPU采集项"><a href="#CPU采集项" class="headerlink" title="CPU采集项"></a>CPU采集项</h4><ul><li>cpu.idle：一个或多个CPU空闲且系统没有未完成的磁盘I / O请求的时间百分比。</li><li>cpu.busy：与cpu.idle相对，他的值等于100个cpu.idle。</li><li>cpu.guest：一个或多个CPU运行虚拟处理器所花费的时间百分比。</li><li>cpu.iowait：在系统有未完成的磁盘I / O请求期间，一个或多个CPU空闲的时间百分比。</li><li>cpu.irq：一个或多个CPU服务硬件中断所花费的时间百分比。</li><li>cpu.softirq：CPU花费在服务软件中断上的时间百分比。</li><li>cpu.nice：在具有优先级的用户级别执行时发生的CPU利用率百分比。</li><li>cpu.steal：虚拟机管理程序为另一个虚拟处理器提供服务时，一个或多个虚拟CPU非自愿等待所花费的时间百分比。</li><li>cpu.system：在系统级别（内核）执行时发生的CPU利用率百分比。</li><li>cpu.user：在用户级别（应用程序）执行时发生的CPU利用率百分比。</li><li>cpu.cnt：cpu核数。</li><li>cpu.switches：cpu切换次数，计数器类型。</li></ul><p>ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33293033">理解CPU Steal Time</a></li><li><a href="https://segmentfault.com/a/1190000018471760">cpu分析</a></li></ul><h4 id="磁盘采集项"><a href="#磁盘采集项" class="headerlink" title="磁盘采集项"></a>磁盘采集项</h4><ul><li><p>df.bytes.free：磁盘可用量，int64</p></li><li><p>df.bytes.free.percent：磁盘可用量占总量的百分比，float64，比如32.1</p></li><li><p>df.bytes.total：磁盘总大小，int64</p></li><li><p>df.bytes.used：磁盘已用大小，int64</p></li><li><p>df.bytes.used.percent：磁盘已用大小占总量的百分比，float64</p></li><li><p>df.inodes.total：inode总数，int64</p></li><li><p>df.inodes.free：可用inode数目，int64</p></li><li><p>df.inodes.free.percent：可用inode占比，float64</p></li><li><p>df.inodes.used：已用的inode数据，int64</p></li><li><p>df.inodes.used.percent：已用inode占比，float64</p></li><li><p><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html">理解inode</a></p></li><li><p><a href="https://segmentfault.com/a/1190000018499770">IO分析</a></p></li></ul><h4 id="内存采集项"><a href="#内存采集项" class="headerlink" title="内存采集项"></a>内存采集项</h4><ul><li><p>mem.memtotal：内存总大小</p></li><li><p>mem.memused：使用了多少内存</p></li><li><p>mem.memused.percent：使用的内存占比</p></li><li><p>mem.memfree</p></li><li><p>mem.memfree.percent</p></li><li><p>mem.swaptotal：swap总大小</p></li><li><p>mem.swapused：使用了多少swap</p></li><li><p>mem.swapused.percent：使用的swap的占比</p></li><li><p>mem.swapfree</p></li><li><p>mem.swapfree.percent</p></li><li><p><a href="https://segmentfault.com/a/1190000018553950">内存分析</a></p></li></ul><ul><li><a href="https://rdc.hundsun.com/portal/article/731.html">性能分析工具集</a></li></ul><h4 id="Web监控指标"><a href="#Web监控指标" class="headerlink" title="Web监控指标"></a>Web监控指标</h4><p><img src="/images/web%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87.png" alt="web监控指标"></p><h4 id="常见性能采集指标"><a href="#常见性能采集指标" class="headerlink" title="常见性能采集指标"></a>常见性能采集指标</h4><p><img src="/images/%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%87%87%E9%9B%86%E6%8C%87%E6%A0%87.png" alt="常见性能采集指标"></p><h4 id="监控文章"><a href="#监控文章" class="headerlink" title="监控文章"></a>监控文章</h4><p><a href="https://www.datadoghq.com/blog/monitoring-101-collecting-data/#metrics">monitoring</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p>特点：</p><ol><li>面向连接的传输层协议</li><li>TCP是点对点的协议</li><li>TCP提供可靠的交付服务，保证传输的数据无差错、不对事、不重复且有序</li><li>TCP提供全双工通信</li><li>TCP是面向字节流的</li></ol><h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><p>报文段由TCP首部和TCP数据两部分组成<br>TCP报文首部最短为20字节，最大长度为60字节。</p><h4 id="一些重要的字段"><a href="#一些重要的字段" class="headerlink" title="一些重要的字段"></a>一些重要的字段</h4><ol><li>序列字段(seq)：序号字段的值为为本报文段所发送的数据的第一个字节的序号</li><li>确认号字段(ack)：值为期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表示N-1为止的所有数据都正确收到</li><li>确认位(ACK)：只有当ACK=1时确认字段才有效</li><li>同步位(SYN)：SYN=1表示这是一个连接请求报文或者连接接收报文</li><li>推送位(PSH)：当接收到PSH=1时，尽快交付接收应用进程，而不是缓存填满后再交付</li><li>终止位(FIN)：用来释放连接，FIN=1表名此报文段的发送方的数据已发送完毕，并要求释放传输连接</li><li>检验和：和UDP一样，需要加上12字节的伪首部。协议字段为6，其他和UDP一样</li></ol><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p><img src="/images/TCP%E9%A6%96%E9%83%A8.png" alt="TCP首部"></p><h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>存在的意义：接收方接收到多个TCP报文段的时候，不清楚它们之前的顺序，<strong>因此需要序列号来保证它们之间的顺序</strong>。<br>必须包含以下两个条件之一，序列号才有意义：</p><ul><li>数据字段至少包含一个字节</li><li>这是一个 SYN 段，或者是 FIN 段，或者是 RST 段。</li></ul><h4 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h4><p>意义：接收方通过回复一个确认号，来<strong>表示确认已经接收到了哪个TCP段</strong>。在 TCP 协议中，一般采用<strong>累积确认</strong>的方式，即每传送多个连续 TCP 段，可以只对最后一个 TCP 段进行确认。<strong>只有当ACK标志位被置位的时候，确认号这个字段才有效</strong>。</p><h4 id="PSH标志位"><a href="#PSH标志位" class="headerlink" title="PSH标志位"></a>PSH标志位</h4><p>发送方使用该标志通知接收方将所收到的数据全部提交给接收进程</p><h4 id="URG标志位和紧急指针"><a href="#URG标志位和紧急指针" class="headerlink" title="URG标志位和紧急指针"></a>URG标志位和紧急指针</h4><p>利用URG配合紧急指针，就可以找到紧急数据的字节号</p><blockquote><p>紧急数据字节号(urgSeq) = TCP 报文序号(seq) + 紧急指针(urgpoint) - 1<br>注意：</p></blockquote><ul><li>即使是紧急数据，仍然会随着普通数据流一起发送，并不会单独为紧急数据开辟一条新的连接通道单独发送。紧急数据不会被优先发送出去</li><li>如果发送方多次发送紧急数据，最后一个数据的紧急指针会将前面的覆盖</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TPC连接需要解决的问题</p><ol><li>要每一方都能够确认对方的存在，检测双方的发送和接受数据能力正常</li><li>要允许双方协商一些参数(如窗口最大值、时间戳、序列号等)<ol><li>确定初始化序列号(ISN),保证接受方知道哪一个报文是第一个报文</li></ol></li><li>能够对运输实体资源进行分配<br>TCP连接的端口是套接字<br>TCP采用C/S模式</li></ol><h4 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h4><p><img src="/images/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP状态机"></p><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server:SYN &#x3D; 1, ACK &#x3D; 0, seq &#x3D; x</span><br><span class="line">    Server -&gt;&gt; Client:SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; y,ack &#x3D; x + 1</span><br><span class="line">    Client -&gt;&gt; Server:ACK &#x3D; 1, seq &#x3D; x + 1, ack &#x3D; y + 1</span><br></pre></td></tr></table></figure><p>通俗来讲：<br>client 对 server 说：我要建立连接<br>server 对 client 说：我已经准好了建立连接了，你也准备一下<br>client 对 server 说：我也准备好了，可以开始了传输数据了</p><h4 id="TCP-三次握手队列（未完成连接队列，已完成连接队列）"><a href="#TCP-三次握手队列（未完成连接队列，已完成连接队列）" class="headerlink" title="TCP 三次握手队列（未完成连接队列，已完成连接队列）"></a>TCP 三次握手队列（未完成连接队列，已完成连接队列）</h4><ul><li><strong>未完成连接队列</strong>（incomplete connection queue），服务器只要收到了 SYN 段，就将该连接加入未完成连接队列。</li><li><strong>已完成连接队列</strong>（complete connection queue），服务器收到了客户端对 SYN 段的确认，将未完成连接队列中的连接移到已完成连接队列。<br><img src="/images/TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97.png" alt="TCP连接队列"></li></ul><h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server:FIN &#x3D; 1, seq &#x3D; u</span><br><span class="line">    Server -&gt;&gt; Client:ACK &#x3D; 1, seq &#x3D; v,ack &#x3D; u + 1</span><br><span class="line">    Server -&gt;&gt; Client:FIN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; w, ack &#x3D; u + 1</span><br><span class="line">    Client -&gt;&gt; Server:ACK &#x3D; 1, seq &#x3D; u + 1, ack &#x3D; w + 1</span><br><span class="line">    Client -&gt;&gt; Client: wait 2MSL(Maximum Segment Lifetime)</span><br></pre></td></tr></table></figure><p>通俗来讲：<br>client 对 server 说：我传完数据了，我要关闭链接了<br>server 对 client 说：等一下，我还有数据传给你<br>server 传完在对 client 说：我也传完数据了，可以关闭链接了<br>client 对 server 说：好的，我收到。<br>client 等了一会再关，为了防止还有消息在路上。如果有通知过来，我就再等会。</p><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><p>因为TCP连接是全双工的。因此每个方向就必须能够单独的关闭。就比如客户端执行了半关闭操作后，只是通知服务器它没有数据要发送了，并不代表它不能接收数据。因此，只要服务器还没有主动关闭，就能够向客户端继续发送数据。也就相当于在步骤 2 和 步骤 3 之间，服务器仍然能够向客户端发送数据。</p><h4 id="为什么要等待2MSL"><a href="#为什么要等待2MSL" class="headerlink" title="为什么要等待2MSL"></a>为什么要等待2MSL</h4><p>MSL表示报文的最大存活时间，等待2MSL能够</p><ul><li>防止连接终止的最后一个ACK丢失</li><li>2MSL足以让报文在网络中消失。防止上一次连接传输的数据影响新的TCP连接。在2MSL中，端口处于TIME_WAIT状态，是无法建立新的连接的。这样就保证了每成功建立一个新连接时，旧连接中的重复 TCP 段都已消逝</li></ul><h4 id="一直处于FIN-WAIT2的状态如何解决"><a href="#一直处于FIN-WAIT2的状态如何解决" class="headerlink" title="一直处于FIN_WAIT2的状态如何解决"></a>一直处于FIN_WAIT2的状态如何解决</h4><p>当主动关闭一方进入FIN_WAIT2 状态时，<strong>只要对端还没有发送 FIN 段过来</strong>（处于 CLOSE_WAIT 状态，等等再关闭，我还有数据要发送），就会一直停留在这个状态。为了防止这种无限 FIN_WAIT2，设置了一个定时器。如果这个连接空闲10分钟75秒，TCP 将进入 CLOSED 状态</p><p><strong>四次挥手为被动关闭的一方提供了很大的伸缩空间，让被动关闭一方有机会继续向主动关闭一方发数据</strong>，如果TCP 协议标准要求步骤 2 和 步骤 3 合并成一个步骤，这种伸缩空间就没有了，也就是说只要有一端关闭了，另一方就没有机会继续发送数据。</p><h3 id="提供网络利用率"><a href="#提供网络利用率" class="headerlink" title="提供网络利用率"></a>提供网络利用率</h3><h4 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h4><ul><li>一个 TCP 连接上最多只能有一个未被确认的未完成的小分组，在它到达目的地前，不能发送其它分组。</li><li>在上一个小分组未到达目的地前，即还未收到它的 ack 前，TCP 会收集后来的小分组。当上一个小分组的 ack 收到后，TCP 就将收集的小分组合并成一个大分组发送出去。</li></ul><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>有时候，发送方发送速度非常快，接收方一下下接收到了好几个 tcp 段，可以通过累积确认的方式，一次确认好几个 tcp 段，这样减少报文段的传输。</p><h4 id="捎带确认"><a href="#捎带确认" class="headerlink" title="捎带确认"></a>捎带确认</h4><p>，双方互相发送数据，当接收到对方的 tcp 段后，先不着急确认，而是等待一会儿，连同数据和 ack 一起发送过去，这种情况叫捎带确认。如果等了一会儿（到时间了），接收方还没有数据要发送，那就直接回复一个纯 ack 过去，这样的 ack 称为延时的 ack（Delayed ACK）.</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="连接异常"><a href="#连接异常" class="headerlink" title="连接异常"></a>连接异常</h4><p>当请求连接的主机不在网络中或者主机在网络中，但是服务没有开启时候，客户端会尝试重新发3此SYN报文尝试重新连接</p><h4 id="异常释放连接"><a href="#异常释放连接" class="headerlink" title="异常释放连接"></a>异常释放连接</h4><p>正常情况下，<strong>关闭连接的方式是发送FIN段</strong>，即四次挥手。这种方式也称为有序释放(orderly release)。也可以<strong>通过发送RST段给对端来释放连接，这种方式称为异常释放</strong>(abortive release)。</p><p>异常终止连接特点：</p><ul><li>丢弃任何尚未发送的数据，立即发送RST报文段</li><li>RST 接收方会区分另一端是异常关闭还是正常关闭，从而做出不同响应</li><li>任何收到 RST 段的一方根本不会为这个RST进行确认</li><li>主动发送 RST 段的一方，不会进入TIME_WAIT状态。</li></ul><h4 id="半打开"><a href="#半打开" class="headerlink" title="半打开"></a>半打开</h4><p>当一方已经关闭或异常终止连接，而另外一方却不知情。这种就称之为TCP半打开。<br>比如客户端主机突然断电。</p><ul><li>如果客户端之后仍然接上网络，但是未开启服务。服务器端发送数据，经过数次重传后放弃连接，并发送RST段。</li><li>如果客户端连上了网络并开启了服务，服务器向客户端发送数据，因为客户端不认识这个连接，因此向服务器端发送RST段。</li></ul><h4 id="同时打开-关闭"><a href="#同时打开-关闭" class="headerlink" title="同时打开/关闭"></a>同时打开/关闭</h4><p>同时打开关闭，指的是已建立连接的两端同时发起主动打开/关闭。<br>对于同时打开，TCP只建立一条连接而不是两条连接。<br>对于同时关闭，双方接收到了FIN之后，端口会变成close状态，但是收到ACK时，状态就变化为TIME_WAIT</p><h3 id="窗口糊涂症"><a href="#窗口糊涂症" class="headerlink" title="窗口糊涂症"></a>窗口糊涂症</h3><p>糊涂窗口综合症。原文叫 Silly Window Syndrome，简称 SWS.<br>SWS 是这样一种情况：接收方通告了一个 1 字节的窗口给发送方，然后发送方发送了 1 字节的数据给接收方。接着，接收方又通告了一个 1 字节的窗口，这样持续下去，使网络的效率很低。<br>解决措施：</p><ul><li>针对接收方来说，先等一段时间，等到接收缓存有足够的空间了才发出确认。</li><li>针对发送方来说，发送方不要发送太小的报文，而是把数据积累成一个足够大的报文段（达到 MSS），或者是积累到接收方通告窗口大小一半的报文段</li></ul><h3 id="TCP-keepalive"><a href="#TCP-keepalive" class="headerlink" title="TCP keepalive"></a>TCP keepalive</h3><p>当TCP连接一定时长没有数据传输的时候，就会发送探测包对对方进行探测，</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 可靠传输</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>使用校验、序号、确认和重传机制来保证可靠传输</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>序号保证数据能够有序提交给应用层</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>确认好使期望收到对方的下一个报文段的数据的第一个字节的序号。使用累计确认，可以直接告诉缺失的数据段</p><h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>引起重传的原因：超时和冗余ACK</p><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>使用一个计时器，在计时器时间内没有收到确认，就会重传该报文<br>超时使用的是一个自适应算法<br>往返时间为RTT(Round-Trip-Time)的计算方式<br>$$ RTT_{new} = (1-\alpha) * RTT_{old} + \alpha * RTT_{样本}  $$<br>$ \alpha $推荐为0.125<br>超时计时器的重传事件RTO(Retransmission Time-Out)<br>$$ RTO = RTT + 4 * RTT_D$$<br>$RTT_D$是RTT的偏差的加权平均<br>$$ RTT_D^{new} = (1-\beta) * RTT_D^{old} + \beta *|RTT - RTT_{样本}|$$<br>$\beta$ 为小于1的系数，推荐值为0.25</p><h4 id="冗余ACK（冗余确认）"><a href="#冗余ACK（冗余确认）" class="headerlink" title="冗余ACK（冗余确认）"></a>冗余ACK（冗余确认）</h4><p>TCP规定每当一个比期望序号大的失序报文段到达时，就会发送一个冗余的ACK，指明下一个期待字节的序号。<br>TCP规定当发送方收到对同一个报文段的3个冗余ACK时，就可以认为更在这个被确认报文段之后的报文段已经丢失。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul><li>超时重传定时器（retransmit）</li><li>持续定时器（persist）</li><li>保活定时器（keepalive，这和 HTTP 协议中的 keepalive 不是同一个概念）</li><li>TIME_WAIT 定时器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 流量控制</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>作用：用以消除发送方使接收方缓存溢出的可能性<br>本质上流量控制是一个速度匹配服务<br>原理：<br>接收方根据自己接受缓存的大小，动态地调整发送方的发送窗口发小。发送方通过设置确认报文首部的窗口字段。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>作用：防止过多的数据注入网络中造成网络路由器和链路过载</p><h4 id="TCP要求发送方维护两个窗口"><a href="#TCP要求发送方维护两个窗口" class="headerlink" title="TCP要求发送方维护两个窗口"></a>TCP要求发送方维护两个窗口</h4><ol><li>接受窗口 rwnd。接收方根据目前接受缓存大小所许诺的最新的窗口值。由发送方控制。</li><li>拥塞窗口 cwnd。发送发根据自己估算的网络拥塞程度而设置窗口值。由发送方根据链路状态估算。<br>$$ 发送窗口的上限值 = Min[rwnd,cwnd] $$</li></ol><p><em>窗口的值指的是最大报文长度(MSS)。MSS的默认值为536字节。所以所有主机都能接受的报文长度为556字节(加上TCP固定首部商都)</em></p><h4 id="维护拥塞窗口的算法"><a href="#维护拥塞窗口的算法" class="headerlink" title="维护拥塞窗口的算法"></a>维护拥塞窗口的算法</h4><p>慢开始、拥塞避免、快重传、快恢复</p><ol><li>一开始使用慢开始算法。发送时 cwnd = 1，每收到一个确认报文后加倍。直到到达一个阈值(ssthresh)。此时cwnd是呈指数增长的</li><li>达到阈值以后，使用拥塞避免算法。每经过一个往返时延，就cwnd + 1。此时cwnd的大小时线性增长的。</li><li>当出现第一次超时(网络拥塞)出现时。再使用慢开始算法，同时阈值调整为超时的cwnd大小的一半</li><li>快重传：当连续收到3个重复的ACK的时候，直接重传未收到的报文，不必等待报文段设置重传计时器超时</li><li>快恢复：当连续收到3个重复的ACK的时候，执行快恢复算法。将cwnd的大小设置为超时的cwnd的大小的一半，之后就执行拥塞避免算法。（不执行慢开始算法）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的RST报文</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E7%9A%84RST%E6%8A%A5%E6%96%87/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E7%9A%84RST%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP的RST报文"><a href="#TCP的RST报文" class="headerlink" title="TCP的RST报文"></a>TCP的RST报文</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>RST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；</p><p>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；接收端收到RST包后，也不必发送ACK包来确认</p><h2 id="产生情景"><a href="#产生情景" class="headerlink" title="产生情景"></a>产生情景</h2><ol><li>目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器</li><li>请求超时</li><li>想取消一个已存在的连接</li><li>客户端在服务端已经关闭掉socket之后，仍然在发送数据</li><li>TCP接收到一个根本不存在的连接上的分节</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>设计哲学: 只做传输协议能做的最少工作。只在IP的数据报服务上增加复用和分用以及差错检测的功能<br>优点</p><ol><li>无需建立连接</li><li>无连接状态</li><li>分组首部开销小，仅有8字节开销</li><li>UDP没有拥塞控制。拥塞也不会影响主机的发送效率，能够容忍一些数据的丢失，但不允许有较大的延迟</li><li>适用于一次性传输比较少了的数据的网络应用。如DNS、SNMP</li><li>UDP提供尽最大努力交付。不保证可靠交付</li><li>面向报文</li></ol><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><ol><li>源端口</li><li>目的端口</li><li>长度</li><li>校验和</li></ol><h2 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h2><p>在计算校验和时，在UDP数据报前增加12字节的伪首部。<br>伪首部由 源IP地址 目的IP地址、0字段、协议字段(UDP为17)、UDP数据报长度<br>伪首部仅仅只用来做校验和，不向下传送也不向上传递。</p><ol><li>UDP校验和校验出UDP数据报是错误的时候，可以丢弃，也可以交付给上层，但需要附上错误报告</li><li>通过伪首部，可以检查源端口号、目的端口号和UDP用户数据报的数据部分。还可以检查IP数据报的源IP地址和目的地址</li></ol><h2 id="可靠性UDP"><a href="#可靠性UDP" class="headerlink" title="可靠性UDP"></a>可靠性UDP</h2><p>实现可靠传输一般有两种途径，一是基于ARQ（Automatic Repeat reQuest）的确认和重传机制，二是使用前向纠错（FEC）。</p><ul><li><p>FEC：是纠删码在通信中的应用，一般在链路层用的比较多。可靠UDP传输主要还是依靠重传机制。</p></li><li><p>ARQ：<br>ARQ包括停等式、回退N帧、选择重传等机制。由于停等式的效率太低，TCP和可靠UDP协议一般使用的是基于回退N帧机制和滑动窗口协议的连续式ARQ。</p></li></ul><h3 id="可靠UDP协议"><a href="#可靠UDP协议" class="headerlink" title="可靠UDP协议"></a>可靠UDP协议</h3><ul><li>UDT(UDP-based Data Transfer Protocol)：DT的主要目的是支持高速广域网上的海量数据传输，所以除了在UDP之上实现类似TCP的协议和算法之外，UDT还对TCP的拥塞算法做了一些细节上的调整。不过UDT的重传效率较低，无效报文，实际效果并不理想。</li><li>KCP：KCP是一个很简单的ARQ的实现，包括选择重传和快重传等机制，对上层提供一个可靠的字节流。应用层可以使用多流复用的框架来实现对多个流的支持</li><li>QUIC：QUIC是Google实现的一种可靠UDP传输协议，并且已经被选择作为HTTP/3的基础。<ul><li>内建安全性，集成TLS</li><li>连接建立过程和TLS协商过程合并，减少往返请求次数，提高连接速度</li><li>集成多种拥塞算法，包括最新的BBR</li><li>多流支持，每个流有独立的拥塞控制，避免单个流中的丢包阻塞其它所有流（Head-of-line Blocking问题），更好的支持类似HTTP/2中的乱序请求</li><li>连接迁移：QUIC可以通过连接ID来唯一标识一个连接，当用户在有线、无线、移动网络之间切换时，可以保持上层连接的有效性，不需要再进行重连</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>功能：</p><ol><li>提供应用程序之间的逻辑通信</li><li>复用和分用。发送方的不同应用进程都可以使用同一个传输层协议传送数据。分用指接收方的传输层在博取报文的首部后能把这些数据正确交付到目的应用程序</li><li>传输层需要对报文的首部和数据部分进行差错检测</li><li>提供两种不同的传输协议。面向连接的TCP和无连接UDP。网略层也可以提供，但是不能同时提供</li></ol><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口是传输层服务提供点TSAP<br>数据链路层的SAP就是MAC的地址，网络层的SAP就是IP地址，传输层的SAP就是端口<br>端口号的长度为16bit，能够表示65536个端口号<br>端口号的分类</p><ol><li>服务端使用的端口号<ol><li>熟知端口号，数值为0~1023<br>常用的熟知端口号</li></ol><ul><li>FTP 21</li><li>TELNET 23</li><li>SMTP 25</li><li>DNS 53</li><li>TFTP 69</li><li>HTTP 80</li><li>SNMP 161</li></ul><ol start="2"><li>登记端口号，数值为1024~49151</li></ol></li><li>客户端使用的端口号<br> 这类端口号尽在客户进程运行时才动态选择，又称短暂端口号<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>套接字实际上就是一个通信端点。唯一标识了网络中一个主意和其上的一个应用(进程)</li></ol><p><strong>套接字 = (主机IP地址，端口号)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>使用端口号 80<br>特点</p><ol><li>无状态</li><li>采用TCP</li><li>既可以使用持久连接也可以使用非持久连接</li></ol><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p><img src="/images/HTTP0.9.png" alt="HTTP"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>只有一个请求行，没有HTTP请求头和请求体</li><li>服务器没有返回头信息，只返回数据</li><li>使用ASCII字符来传输</li></ol><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><h4 id="请求流程-1"><a href="#请求流程-1" class="headerlink" title="请求流程"></a>请求流程</h4><p><img src="/images/HTTP1.0.png" alt="HTTP"></p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>添加请求头和响应头进行协商，解决</p><ul><li>服务器返回的数据是什么类型</li><li>采取什么样的形式压缩</li><li>提供什么语言文件</li><li>文件的具体编码类型</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><h5 id="加入持久连接"><a href="#加入持久连接" class="headerlink" title="加入持久连接"></a>加入持久连接</h5><ul><li>解决的问题：HTTP/1.0 每进行一个HTTP通信，都要经历TCP连接，传输数据，断开TCP的步骤。</li><li>方案：加入持久连接使得在一个TCP上可以传输多个HTTP请求。<h5 id="加入HTTP-管线化-不成熟"><a href="#加入HTTP-管线化-不成熟" class="headerlink" title="加入HTTP 管线化(不成熟)"></a>加入HTTP 管线化(不成熟)</h5></li><li>解决的问题：持久连接虽然能减少TCP的建立和断开次数。但是下一个请求要等待前面一个请求返回之后，若前面请求没有及时返回，会阻塞后面的请求</li><li>方案：加入管线化，将多个HTTP请求整批提交给服务器。虽然可以整批发送，不过还需要根据请求来回复浏览器的请求<h5 id="提供虚拟主机支持"><a href="#提供虚拟主机支持" class="headerlink" title="提供虚拟主机支持"></a>提供虚拟主机支持</h5></li><li>解决的问题：一个物理主机上绑定了多个虚拟主机，每个虚拟主机都有单独的域名，但是都是同一个IP</li><li>方案：在请求头添加Host字段，表示当前域名的地址。这样服务器就可以根据不同的host来做不同的处理<h5 id="对动态生成的内容进行支持"><a href="#对动态生成的内容进行支持" class="headerlink" title="对动态生成的内容进行支持"></a>对动态生成的内容进行支持</h5></li><li>解决的问题：在传输数据之前并不知道最终的数据大小，导致浏览器不知道何时会接受完所有的数据文件</li><li>方案：引入Chunk transfer机制，服务器将数据分割成若干任意大小的数据块，每次发送时会附上上个数据块的长度，最后一个使用零长度的块作为发送数据完成的标志<h5 id="客户端Cookie，安全机制"><a href="#客户端Cookie，安全机制" class="headerlink" title="客户端Cookie，安全机制"></a>客户端Cookie，安全机制</h5></li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><h4 id="HTTP-1-1-的问题"><a href="#HTTP-1-1-的问题" class="headerlink" title="HTTP 1.1 的问题"></a>HTTP 1.1 的问题</h4><ol><li>TCP启动慢，TCP本身是慢启动的</li><li>同时开启多条TCP连接，连接会竞争固定的宽带</li><li>HTTP/1.1队头阻塞问题<h4 id="改进-2"><a href="#改进-2" class="headerlink" title="改进"></a>改进</h4><h5 id="HTTP-2-多路复用"><a href="#HTTP-2-多路复用" class="headerlink" title="HTTP/2 多路复用"></a>HTTP/2 多路复用</h5><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="HTTP"></li></ol><ul><li>解决的问题：TCP慢启动，多TCP连接竞争的问题</li><li>方案：一个域名只使用一个TCP长连接来传输数据，页面资源下载过程只需要慢启动一次，也避免了多TCP连接竞争的问题<h5 id="HTTP-2-多路复用实现"><a href="#HTTP-2-多路复用实现" class="headerlink" title="HTTP/2 多路复用实现"></a>HTTP/2 多路复用实现</h5>引入二进制分帧层</li></ul><ol><li>浏览器准备好了请求数据，包括请求行、请求头等信息</li><li>这些数据经过二进制分帧层处理后，会转化为一个个带ID的帧,通过协议将这么帧发送给服务器</li><li>服务器接收到所有帧以后，会将相同ID的帧合并为一条完整的请求信息</li><li>服务器处理后，将处理的响应行、响应头和响应体分别发送到二进制分帧层</li><li>二进制分帧层会将响应数据一个个转化为带ID的帧，发送给浏览器</li><li>浏览器接收到响应帧后，会根据ID编码将帧的数据提交给对应的请求</li></ol><h5 id="可设置请求的优先级"><a href="#可设置请求的优先级" class="headerlink" title="可设置请求的优先级"></a>可设置请求的优先级</h5><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><h4 id="TCP的问题"><a href="#TCP的问题" class="headerlink" title="TCP的问题"></a>TCP的问题</h4><ol><li>TCP队头阻塞</li><li>TCP建立的时延</li><li>TCP协议中间设备的僵化</li></ol><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><ul><li>QUIC实现了类似TCP的流量控制，其在UDP的基础上增加了一层来保证数据可靠性传输，包括数据包重传，拥塞控制和一些TCP的存在的特性</li><li>集成了TLS加密功能</li><li>实现了HTTP/2的多路复用功能。和TCP不同,QUIC实现了在同一个物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题<h4 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h4><img src="/images/HTTP3%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="HTTP3协议栈"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 应用层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/HTTPS/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/HTTPS/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="在HTTP协议栈中引入安全层"><a href="#在HTTP协议栈中引入安全层" class="headerlink" title="在HTTP协议栈中引入安全层"></a>在HTTP协议栈中引入安全层</h2><ul><li>目的：解决HTTP明文传输的问题，避免中间人攻击</li><li>安全层的职责<ol><li>对发起HTTP请求的数据进行加密操作</li><li>对接受到的HTTP的内容进行解密</li></ol></li></ul><h2 id="使用对称加密协议"><a href="#使用对称加密协议" class="headerlink" title="使用对称加密协议"></a>使用对称加密协议</h2><p><img src="/images/HTTPS%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt="HTTPS 对称加密"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>浏览器发送加密套件列表(加密方法)和一个随机数(client-random)给到服务器</li><li>服务器收到后，选择加密套件并产生一个随机数(service-random)返回给浏览器</li><li>浏览器和服务器使用两个随机数并用加密套件计算密钥</li><li>之后传输利用密钥加密的数据<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3></li></ol><ul><li>传输随机数的时候是明文的，而且合成密钥的算法是公开的。因此黑客拿到随机数后也可以进行破解</li></ul><h2 id="使用非对称加密协议"><a href="#使用非对称加密协议" class="headerlink" title="使用非对称加密协议"></a>使用非对称加密协议</h2><p><img src="/images/HTTPS%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt="HTTPS 非对称加密"></p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>浏览器会发送加密套件列表给到服务器</li><li>服务器发送加密套件和公钥给到浏览器，私钥由服务器自己保存</li><li>浏览器和服务器互相确认，确认之后，浏览器利用公钥加密发送数据<h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3></li><li>非对称加密效率太低</li><li>无法保证服务器发送给浏览器的数据安全。由于私钥加密只有公钥可以解密，黑客也能获取到公钥，不能保证服务器的安全</li></ol><h2 id="对称加密和非对称加密混合使用"><a href="#对称加密和非对称加密混合使用" class="headerlink" title="对称加密和非对称加密混合使用"></a>对称加密和非对称加密混合使用</h2><p><img src="/images/HTTPS%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt="HTTPS 混合对称加密"></p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>浏览器发送对称加密套件列表和加密套件列表和Client-random给到服务器</li><li>服务器返回对称加密和非对称加密套件，service-random 和 公钥给到浏览器</li><li>浏览器根据client-random和service-random计算pre-master，然后利用公钥对pre-master进行加密，发送给加密后的数据给服务器</li><li>服务器解密加密后的pre-master返回服务器确认给浏览器</li><li>浏览器和服务器根据client-random和service-random和pre-master生成master secret</li><li>之后传输利用master secret加密的数据<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>pre-master 是经过公钥加密后传输的，所以黑客无法获取到pre-master，因此他们就无法生成密钥</li><li>使用3个随机数，能够降低被暴力破解的可能性<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>黑客能通过DNS劫持将IP变成黑客的IP，这样访问的就变成了黑客的服务器</li></ol><h2 id="添加数据证书"><a href="#添加数据证书" class="headerlink" title="添加数据证书"></a>添加数据证书</h2><h3 id="数据证书的作用"><a href="#数据证书的作用" class="headerlink" title="数据证书的作用"></a>数据证书的作用</h3><ul><li>通过数字证书向浏览器证明服务器的身份</li><li>数字证书里面包含了服务器的公钥<h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3></li></ul><ol><li>相比于使用对称加密和非对称加密混合使用，服务器不返回公钥给浏览器，而是直接返回数字证书给浏览器，因为数字证书里面包含了公钥</li><li>浏览器在生成pre-master之前，需要验证一下数据证书。这样黑客即使伪造了服务器，也无法伪造证书</li></ol><h3 id="浏览器如何验证数字证书"><a href="#浏览器如何验证数字证书" class="headerlink" title="浏览器如何验证数字证书"></a>浏览器如何验证数字证书</h3><ol><li>浏览器接收到数字证书后，会读取证书中的明文信息，采用CA签名相同的hash函数来计算并得到信息摘要A</li><li>采用对应的CA的公钥解密签名数据，得到信息摘要B</li><li>对比信息摘要A和B，相同则表示是合法的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 应用层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层协议</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>作用：将域名解析成IP地址<br>DNS使用C/S模型，运行在UDP上，使用53号端口<br>域名解析原理<br>常使用迭代查询和递归查询<br><img src="/images/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="迭代查询和递归查询"></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>FTP提供交互式访问，允许客户指明文件的类型和格式，并且允许文件具有存取的权限。<br>使用C/S模型<br>功能：</p><ol><li>提供不同种类主机系统之间的文件传输能力</li><li>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</li><li>以匿名FTP的方式提供公用文件共享的能力</li></ol><p>FTP在工作时使用两个并行的TCP连接，一个是控制连接(端口号21)，一个数据连接。</p><h4 id="FTP传输模式"><a href="#FTP传输模式" class="headerlink" title="FTP传输模式"></a>FTP传输模式</h4><p>FTP的传输模式分为主动传输和被动传输。</p><ul><li>主动传输是当建立好控制连接之后，客户端向服务器发送PORT命令(包含客户端使用什么端口接受数据)，然后服务器就使用端口号为20的端口与客户端指定的端口建立数据连接。</li><li>被动传输是当建立好控制连接之后，客户端向服务器端发送PASV命令。服务器接受到PASV命令之后随机 打开一个高端端口，并通知客户在这个端口上传输数据，客户端收到该端口再建立数据连接。</li></ul><p>数据连接的端口号使用20与FTP的传输模式有关，如果采用主动模式，则数据传输端口号为20，若采用被动模式，则由服务器端和客户端协商决定。</p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>电子邮件的三大组件：用户代理，邮件服务器和电子邮件使用的协议<br><img src="/images/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E6%9E%84%E5%BB%BA.png" alt="电子邮件的组件"><br>SMTP协议使用的是“推的方式”。而POP3使用的是拉的方式</p><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>简单邮件传输协议(Simple Mail Transfer Protocol)。使用的是C/S方式。在传输层使用TCP协议，端口号为25。只能传输一定长度的ASCII码<br>SMTP通信的三个阶段：</p><ol><li>建立连接</li><li>邮件传送</li><li>连接释放<h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4>邮局协议(Post Office Protocol)。使用的是C/S方式。在传输层使用TCP协议。端口号为110<br>另外一个邮件接受协议是网际报文存取协议IMAP。</li></ol><p>基于TCP的应用层协议有：POP3、SMTP（简单邮件传输协议）、TELNET（远程登陆协议）、HTTP（超文本传输协议）、HTTPS（超文本传输安全协议）、FTP（文件传输协议）<br>基于UDP的应用层协议：TFTP（简单文件传输协议）、RIP（路由信息协议）、DHCP（动态主机设置协议）、BOOTP（引导程序协议，DHCP的前身）、IGMP（Internet组管理协议）<br>基于TCP和UDP协议：DNS（域名系统）、ECHO（回绕协议）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 应用层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPV4</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/IPV4/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/IPV4/</url>
      
        <content type="html"><![CDATA[<h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP 首部4个字节</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li>A类：7位网络号 24位主机号</li><li>B类：14位网络号 16位主机号</li><li>C类：21位主机号 8位主机号 </li><li>D类：多播地址</li><li>E类：保留使用</li><li>主机号全为0表示本网络本身。如 192.168.13.0</li><li>主机号全为1表示本网络的广播地址。如192.168.222.255</li><li>0.0.0.0 表示本主机</li><li>255.255.255.255 等效为TCP/IP的广播地址。</li></ul><h4 id="NAT-网络地址转换-network-addresstranslation"><a href="#NAT-网络地址转换-network-addresstranslation" class="headerlink" title="NAT (网络地址转换 network addresstranslation)"></a>NAT (网络地址转换 network addresstranslation)</h4><p>对私有IP和公有IP的转换。从而对外隐藏内部管理的IPizhi<br>私有网络IP地址</p><ul><li>A类网段：10.0.0.0 ~ 10.255.255.255</li><li>B类网段：172.16.0.0 ~ 172.31.255.255</li><li>C类网段：192.168.0.0 ~ 192.168.255.255</li></ul><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>解决问题：IP地址空间的利用率低，两级IP不够灵活<br>划分思路：从主机号借比特作为子网号。三级IP的地址结构为：网络号+子网号+主机号<br>借用子网掩码来得出子网的网络地址</p><h4 id="CIDR-无分类域间路路由选择"><a href="#CIDR-无分类域间路路由选择" class="headerlink" title="CIDR (无分类域间路路由选择)"></a>CIDR (无分类域间路路由选择)</h4><p>特点</p><ol><li>消除传统的A、B、C类的子网划分。变为无分类的两级编制。地址结构为：网络前缀 + 主机号</li><li>使用“斜线记法”</li><li>网络前缀的灵活性好，可以构成超网（路由聚合）</li><li>使用最长前缀匹配</li></ol><h4 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP (地址解析协议)"></a>ARP (地址解析协议)</h4><p>工作在网络层<br>作用：将IP地址转换为MAC地址<br>解决问题：同一个局域网上的主机或路由的IP地址和硬件地址的映射问题<br>工作原理：<br>假设主机A向主机B发送数据</p><ol><li>A先在ARP缓存表中查询有无B的IP地址。有到第二步，没有到第三步</li><li>有就将硬件地址写入MAC帧</li><li>没有就是用MAC地址FF-FF-FF-FF-FF-FF来广播ARP请求分组</li><li>B响应ARP分组，A收到后写入缓存并修改MAC地址</li></ol><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP (动态主机配置协议)"></a>DHCP (动态主机配置协议)</h4><p>是基于UDP的应用层协议，使用CS模式<br>作用：给主机动态地分配IP地址</p><h4 id="ICMP（网络控制报文协议）"><a href="#ICMP（网络控制报文协议）" class="headerlink" title="ICMP（网络控制报文协议）"></a>ICMP（网络控制报文协议）</h4><p>是网络层协议<br>作用：允许主机或路由器报告差错和异常情况。提高IP数据报交付成功的机会<br>报文类型</p><ol><li>差错报文<ol><li>重点不可达</li><li>源点抑制</li><li>时间超过</li><li>参数问题</li><li>改变路由</li></ol></li><li>询问报文<ol><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li><li>掩码地址请求和回答报文</li><li>路由器询问和回答报文<br>常用应用</li></ol></li><li>PING</li><li>traceroute</li></ol><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4向IPv6过渡</p><ol><li>使用双协议栈</li><li>使用隧道技术</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP组播</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E7%BB%84%E6%92%AD/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E7%BB%84%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p>IP组播<br>使用的是D类地址格式<br>前四位为1110，地址范围为224.0.0.0~239.255.255.255<br>特点：</p><ol><li>组播数据报是尽最大努力交互，不提供可靠交付</li><li>组播地址只能用于目的地址</li><li>不产生ICMP报文</li><li>并不是所有的D类地址又可以作为组播地址 </li></ol><h3 id="IGMP协议-（internet-group-management-protocol）"><a href="#IGMP协议-（internet-group-management-protocol）" class="headerlink" title="IGMP协议 （internet group management protocol）"></a>IGMP协议 （internet group management protocol）</h3><p>本质上是找出以源主机为根节点的组播转发树<br>IGMP工作的两个阶段</p><ol><li>新主机加入组播组时，该主机需要向组播组的组播地址发送一个IGMP报文以声明要成为该组的成员。组播路由器收到IGMP报问后，将组成员关系转发给其他组播路由</li><li>本地组播路由要周期性地探寻本地局域网上的机器，以便知道这些主机是否还继续租的成员<br>组播路由算法：</li><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>建立在任何路由器协议上的协议无关的组播(PIM)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由协议</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="域内路由和域间路由"><a href="#域内路由和域间路由" class="headerlink" title="域内路由和域间路由"></a>域内路由和域间路由</h2><p>自治系统：，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位单一技术管理下的一组路由器</p><ol><li>内部网关协议(IGP)<br>例如 RIP 和 OSPF</li><li>外部网关协议(EGP)<br>例如 BGP</li></ol><h3 id="RIP路由协议-路由信息协议"><a href="#RIP路由协议-路由信息协议" class="headerlink" title="RIP路由协议 (路由信息协议)"></a>RIP路由协议 (路由信息协议)</h3><p>基于距离向量的路由选择协议<br>是应用层协议，使用UDP传送数据(端口520)<br>特点：</p><ol><li>仅和相邻路由交换信息</li><li>路由器交换的信息是本路由器所知道的全部信息</li><li>固定时间间隔交换路由信息</li><li>路径一定是最少跳数的路径<br>缺点：</li><li>RIP限制网络规模，能使用的最大距离为15</li><li>网络规模越大，开销越大</li><li>网络出现故障，回出现慢收敛现象。即坏消息传的慢</li></ol><h3 id="OSPF路由协议-（开放最短路径优先协议）"><a href="#OSPF路由协议-（开放最短路径优先协议）" class="headerlink" title="OSPF路由协议 （开放最短路径优先协议）"></a>OSPF路由协议 （开放最短路径优先协议）</h3><p>网络层协议<br>使用Dijkstra算法<br>不使用UDP数据报传送数据，直接使用IP数据报传输<br>每个路由存储的不是完整的路径，而是只存储“下一跳”<br>特点：</p><ol><li>使用泛洪法向所有路由发送信息</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态</li><li>只有当链路状态发生改变时，路由器才用泛洪法向所有路由器发送信息</li><li>直接使用IP数据报传送</li><li>可以对不同服务类型设置不同的代价</li><li>可以实现链路的负载均衡</li><li>支持可变长的子网划分和无分类编制CIDR</li><li>带一个32位的序号，序号越大越新<br>五种分组类型</li><li>问候分组</li><li>数据库描述分组</li><li>链路状态请求分组</li><li>链路状态更新分组</li><li>链路状态确认分组</li></ol><h3 id="BGP协议-（边界网关协议）"><a href="#BGP协议-（边界网关协议）" class="headerlink" title="BGP协议 （边界网关协议）"></a>BGP协议 （边界网关协议）</h3><p>目的：力求寻找一条能够达到目的网络且比较好的路由，而不是寻找最佳路由<br>采用路径向量路由选择协议<br>BGP是应用层协议，基于TCP<br>原理：</p><ol><li>每个自治系统的管理员至少选择一个路由器作为BGP发言人。</li><li>BGP发言人和其他自治系统的BGP发言人建立TCP连接。</li><li>在此连接上建立BGP会话，利用BGP会话交换路由信息。</li><li>当所有BGP发言人都相互交换网络可达性信息后，各BGP发言人就可以找到可达的较好的路由<br>特点：</li><li>交换路由信息的节点数量级是自治系统的数量级。使自治系统之间的路由选择不至于过分复杂</li><li>BGP路由表包括目的网络前缀、下一跳路由和到达目的网络锁需要经过的自治系统的序列。也支持CIDR</li><li>第一次运行时交换的是整个BGP路由表，之后交换的是发生变化的部分<br>四种报文：</li><li>打开报文</li><li>更新报文</li><li>保活报文</li><li>通知报文</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由转发和拥塞控制</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>路由器功能</p><ol><li>路由选择</li><li>分组转发</li></ol><p>拥塞控制<br>解决的问题：如何获取网络中发生拥塞的信息，从而利用这些信息控制。<br>拥塞控制是一个全局性问题，涉及网络中所有的主机、路由器以及导致网络传输能力下降的所有因素。<br>拥塞控制的两种方法</p><ol><li>开环控制<br>事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。是一种静态的方法。</li><li>闭环控制<br>事先不考虑有关发生拥塞的因素，采用监测网络去监视，及时检测哪里发生拥塞，将拥塞的信息传到合适的地方。是一种动态方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由选择算法</title>
      <link href="2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/01/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-距离-向量路由算法"><a href="#1-距离-向量路由算法" class="headerlink" title="1. 距离-向量路由算法"></a>1. 距离-向量路由算法</h3><p>路由选择表包含</p><ul><li>每条路径的目的地</li><li>路径的代价(距离)<br>RIP 采用跳数作为距离的度量。<h3 id="2-链路状态路由"><a href="#2-链路状态路由" class="headerlink" title="2. 链路状态路由"></a>2. 链路状态路由</h3>要求每个算法节点都有完全的拓扑信息<br>每个节点的任务</li></ul><ol><li>主动测试所有邻接节点的状态</li><li>定期将链路转态传播给所有其他节点<br>三大特征</li><li>使用泛洪法向本自治系统中所有路由发送信息</li><li>发送的信息就是路由相邻的所有路由器的链路状态</li><li>只有链路转态发生改变时才会向所有路由器发送此消息</li></ol><h3 id="3-层次路由"><a href="#3-层次路由" class="headerlink" title="3. 层次路由"></a>3. 层次路由</h3><ol><li>内部网关协议(IGP)<br>例如 RIP 和 OSPF</li><li>外部网关协议(EGP)<br>例如 BGP</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内建命令</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h1><ol><li>判断是否是内建命令：type cd</li><li>执行程序：“.” 如”. /usr/bin/bash”</li><li>别名：alias</li><li>删除别名：unalias</li><li>任务前后台切换：bg，fg，jobs<ol><li>bg：放置后台继续运行</li><li>fg：放置在前台继续运行</li><li>jobs：查看暂停任务</li></ol></li><li>改变目录：cd</li><li>声明变量：declare、typeset</li><li>打印字符：echo</li><li>跳出循环：break</li><li>循环控制：continue</li><li>将参数转化为命令执行：eval</li><li>执行命令取代当前Shell：exec</li><li>退出Shell：exit</li><li>使变量能被Shell识别：export</li><li>发送信号给指定PID或进程：kill</li><li>整数运算：let</li><li>显示当前工作目录：pwd</li><li>声明局部变量：local</li><li>从标准输入读取一行到变量：read</li><li>定义函数返回值：return</li><li>向左移动参数：shift</li><li>限制并设置进程资源调度：ulimit</li><li>测试表达式：test</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux启动流程</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="linux启动流程"><a href="#linux启动流程" class="headerlink" title="linux启动流程"></a>linux启动流程</h1><h2 id="linux启动流程（init）"><a href="#linux启动流程（init）" class="headerlink" title="linux启动流程（init）"></a>linux启动流程（init）</h2><ol><li>计算机会加载BIOS，BIOS会对自身的硬件做一次健康检查</li><li>硬件自检后，就进入引导系统。BIOS默认从硬盘的第0柱面，第0磁道，第一个扇区读取MBR（主引导记录）载入引导程序(如grub)</li><li>grub会根据配置文件加载kernel镜像，并运行内核加载后的第一个程序/sbin/init，这个文件会根据/etc/inittab 来进行初始化工作</li><li>根据/etc/inittab 会确定系统运行级别，初始化并运行/etc/rc.sysinit脚本，该脚本会设置系统变量、网络配置，并启动swap、设定/proc、加载用户自定义模块、记载内核设置等</li><li>根据系统运行级别，启动对应的服务，如系统运行级别为3，则会运行/etc/rc3.d/下所有脚本</li><li>运行/etc/rc.local/</li><li>生成终端或者X windows 等待用户登录</li></ol><h2 id="linux启动流程（systemctl）"><a href="#linux启动流程（systemctl）" class="headerlink" title="linux启动流程（systemctl）"></a>linux启动流程（systemctl）</h2><p><a href="https://blog.csdn.net/qq_36119192/article/details/82415113">https://blog.csdn.net/qq_36119192/article/details/82415113</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%91%BD%E4%BB%A4/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li>新增用户 useradd<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -u [UID] -g [GID&#x2F;Group name] -d [home directory] [user name]</span><br><span class="line">useradd -u 5 -g group1 -d &#x2F;home&#x2F;group1 username</span><br></pre></td></tr></table></figure></li><li>修改密码 passwd</li><li>修改用户 usermod</li><li>删除用户 userdel</li></ol><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><ol><li>新增用户组 groupadd</li><li>删除用户组 groupdel</li></ol><h3 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h3><ol><li>查看用户：users、who、w</li><li>调查用户：finger</li></ol><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><ol><li>切换成其他用户：su</li><li>用其他用户的身份执行命令：sudo</li></ol><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><ol><li>单一时刻执行一次任务：at<ol><li>查看当前at命令调度的任务列表：atq</li><li>删除at任务列表的任务：atrm</li></ol></li><li>周期任务：cron</li></ol><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li>创建文件：touch</li><li>删除文件：rm</li><li>移动或者重命名文件：mv</li><li>查看文件：cat</li><li>查看文件头：head(显示文件前10行的内容，使用-n调整显示的行数)</li><li>查看文件尾：tail(显示文件后10行内容)</li><li>文件格式转换：dos2unix</li></ol><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li>进入目录：cd</li><li>创建目录：mkdir</li><li>删除目录：rm和rmdir</li><li>文件和目录复制：cp</li></ol><h3 id="文件和目录权限"><a href="#文件和目录权限" class="headerlink" title="文件和目录权限"></a>文件和目录权限</h3><ol><li>查看文件和目录权限： ls -l</li><li>改变文件权限：chmod</li><li>改变文件的拥有者：chown</li><li>改变文件的拥有组：chgrp</li><li>查看文件类型：file</li><li>查看文件隐藏属性：lsattr</li><li>设置文件隐藏属性：chattr</li></ol><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><ol><li>一般查找：find</li><li>数据库查找：locate<ol><li>更新数据库：updatedb</li></ol></li><li>查找执行文件：which/whereis</li></ol><h3 id="文件打包和压缩"><a href="#文件打包和压缩" class="headerlink" title="文件打包和压缩"></a>文件打包和压缩</h3><ol><li>gzip/gunzip：压缩成gz</li><li>tar：压缩成gz/tgz<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">压缩：</span><br><span class="line">tar -zcvf [compressed file name] [origin file name/directory]</span><br><span class="line">tar -zcvf boot.tgz /boot</span><br><span class="line">-z:使用gzip雅座</span><br><span class="line">-c:创建压缩文件</span><br><span class="line">-v:显示当前被压缩的文件</span><br><span class="line">-f:使用文件名</span><br><span class="line"></span><br><span class="line">解压：</span><br><span class="line">tar -zxvf [compressed file name] [target directory]</span><br></pre></td></tr></table></figure></li><li>bzip2：压缩成bz2<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">压缩：bzip2 [file name]</span><br><span class="line">解压：bzip -d [compressed file name]</span><br></pre></td></tr></table></figure></li><li>cpio：通常和find一起使用，通过管道的方式传递给cpio进行备份，生成cpio文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">备份：find . -name *.conf | cpio -cov &gt; /temp/config.cpio</span><br><span class="line">还原：cpio --absolute-filenames -icvu &lt; /temp/conf.cpio</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h3><ol><li>创建文件系统：fdisk</li><li>磁盘挂载：mount</li><li>磁盘检查：fsck、badblocks<ol><li>fsck(file system check)用于未挂载的磁盘，否则会造成文件系统损坏</li><li>badblocks用于检查磁盘坏道</li></ol></li></ol><h3 id="逻辑卷"><a href="#逻辑卷" class="headerlink" title="逻辑卷"></a>逻辑卷</h3><ol><li>创建和查看物理卷：pvcreate，pvdisplay</li><li>创建和查看卷组：vgcreate，vgdisplay</li><li>扩展卷组：vgextend</li><li>创建和查看逻辑卷：lvcreate，lvdisplay</li></ol><h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><ol><li>文本搜索：grep<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep [-ivnc] [pattern] [file name]</span><br><span class="line">grep -ivnc &#x27;name&#x27; test.txt</span><br><span class="line">-i:不区分大小写</span><br><span class="line">-v:反向匹配</span><br><span class="line">-n:输出行号</span><br><span class="line">-c:统计包含匹配的行数</span><br></pre></td></tr></table></figure></li><li>排序：sort<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort [-ntkr] [file name]</span><br><span class="line">-n:采取数字排序</span><br><span class="line">-t:指定分隔符</span><br><span class="line">-k:指定第几列</span><br><span class="line">-r:反向排序</span><br></pre></td></tr></table></figure></li><li>删除重复内容：uniq(需要和sort一起使用)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq [-ic]</span><br><span class="line">-i:忽略大小写</span><br><span class="line">-c:计算重复行数</span><br></pre></td></tr></table></figure></li><li>截取文本:cut(处理的对象时一行文本)</li><li>文本替换:tr</li><li>文本合并:paste</li><li>分割大文件:split(只支持行数分割和大小分割，二进制文件只能按照大小分割)</li></ol><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><ol><li>检查和配置网卡：ipconfig</li><li>路由和网关：route</li><li>网络测试工具<ol><li>检测可达性：ping</li><li>查询DNS记录：host</li><li>查询路由：traceroute</li></ol></li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ol><li>进程查看：ps，top</li><li>进程终止：kill，killall</li><li>查询进程打开的文件：lsof（list open file）<ol><li>查找使用某个端口的进程：lsof -i:8080</li><li>还能恢复文件，只能正在被某个进程使用的文件</li></ol></li><li>进程优先级调整：nice、renice</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基本概念</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux逻辑卷"><a href="#Linux逻辑卷" class="headerlink" title="Linux逻辑卷"></a>Linux逻辑卷</h2><ol><li>物理卷（physical volume,PV）：物理磁盘分区</li><li>卷组（Volume Group，VG）：PV的集合</li><li>逻辑卷（Logic Volume,LV）:PV划出来的一块逻辑磁盘</li></ol><h2 id="Shell-内建命令"><a href="#Shell-内建命令" class="headerlink" title="Shell 内建命令"></a>Shell 内建命令</h2><p>指的是Bash本身提供的命令，而不是文件系统中的执行文件，如cd。<br>执行外建命令会触发IO，还需要fork一个单独的进程来完成，执行完再退出，而内建命令不需要，因此内建命令会比外建命令执行地快</p><h2 id="AWK教程"><a href="#AWK教程" class="headerlink" title="AWK教程"></a>AWK教程</h2><p><a href="http://www.ruanyifeng.com/blog/2018/11/awk.html">http://www.ruanyifeng.com/blog/2018/11/awk.html</a></p><h2 id="文件标识符"><a href="#文件标识符" class="headerlink" title="文件标识符"></a>文件标识符</h2><ul><li>标准输入为0</li><li>标准输出为1</li><li>标准错误输出为2</li></ul><h2 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h2><h3 id="Buffers-和-Cache"><a href="#Buffers-和-Cache" class="headerlink" title="Buffers 和 Cache"></a>Buffers 和 Cache</h3><ul><li>buffers 主要目的是做流量整形，把突发的大数量规模小的I/O整理成平稳的小数量较大规模的I/O</li><li>cache 是为了弥补高速设备和低速设备的速度差异引入的中间层，最终达到加快访问速度的作用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础知识</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础知识"><a href="#linux基础知识" class="headerlink" title="linux基础知识"></a>linux基础知识</h1><h2 id="linux文件目录"><a href="#linux文件目录" class="headerlink" title="linux文件目录"></a>linux文件目录</h2><h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><p>二进制可执行命令 (ls,cat,mkdir等),启动时会用到的命令，即文件系统还没有被挂载的时候都可以使用的命令 </p><h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h3><p>放置开机的时候会使用的文件，包括一些连接文件以及镜像文件</p><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>任何设备与设备接口都是以文件的形式存在于该目录中</p><h3 id="etc-系统管理和配置文件"><a href="#etc-系统管理和配置文件" class="headerlink" title="/etc 系统管理和配置文件"></a>/etc 系统管理和配置文件</h3><p>系统的所有配置文件都存在这个目录中</p><h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h3><p>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</p><h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，比如用户user的主目录就是/home/user，可以用~user表示</p><h3 id="lib-标准程序设计库，又叫动态链接共享库，作用类似windows里的-dll文件"><a href="#lib-标准程序设计库，又叫动态链接共享库，作用类似windows里的-dll文件" class="headerlink" title="/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件"></a>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件</h3><p>放置开机时会使用的函数库</p><h3 id="sbin-超级管理命令"><a href="#sbin-超级管理命令" class="headerlink" title="/sbin 超级管理命令"></a>/sbin 超级管理命令</h3><p>存放的是系统管理员使用的系统管理程序，如ifconfig等。</p><h3 id="tmp-temporary"><a href="#tmp-temporary" class="headerlink" title="/tmp (temporary)"></a>/tmp (temporary)</h3><p>公共的临时文件存储点</p><h3 id="boot-1"><a href="#boot-1" class="headerlink" title="/boot"></a>/boot</h3><p>存放用于系统引导时使用的各种文件</p><h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><p>系统管理员的主目录</p><h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h3><p>系统提供这个目录是让用户临时挂载其他的文件系统</p><h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h3><p>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</p><h3 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h3><p>下面放置可删除设备，linux 系统会自动识别一些设备，例如U盘、光驱</p><h3 id="srv（service）"><a href="#srv（service）" class="headerlink" title="/srv（service）"></a>/srv（service）</h3><p>该目录存放一些服务启动之后需要提取的数据，比如WWW服务的数据就可以放在这里</p><h3 id="sys"><a href="#sys" class="headerlink" title="/sys"></a>/sys</h3><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。<br>该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><h3 id="var-variable"><a href="#var-variable" class="headerlink" title="/var (variable)"></a>/var (variable)</h3><p>某些大文件的溢出区，比方说各种服务的日志文件</p><h3 id="usr-UNIX-Software-Resource"><a href="#usr-UNIX-Software-Resource" class="headerlink" title="/usr (UNIX Software Resource)"></a>/usr (UNIX Software Resource)</h3><p>最庞大的目录，要用到的应用程序和文件几乎都在这个目录</p><h2 id="profile-bash-profile-bashrc"><a href="#profile-bash-profile-bashrc" class="headerlink" title="profile,bash_profile,bashrc"></a>profile,bash_profile,bashrc</h2><h3 id="profile-etc-profile"><a href="#profile-etc-profile" class="headerlink" title="profile(etc/profile)"></a>profile(etc/profile)</h3><p>设置系统级的环境变量和启动程序，当用户登录login时，文件会被执行，并从/etc/profile.d目录下查找shell的设置</p><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="bashrc"></a>bashrc</h3><p>用于配置函数或者别名。有两种级别，系统级位于/etc/bashrc，用户级位于~/.bashrc，两者分别会对所有用户和当前用户生效，bashrc只会针对指定的shell类型起作用。bash只会被bash shell调用</p><h3 id="bash-profile-文件"><a href="#bash-profile-文件" class="headerlink" title="bash_profile 文件"></a>bash_profile 文件</h3><p>bash_profile只对单一用户生效，文件存储于~/.bash_profile，是用户级别的设置，可以理解为某一个用户的profile目录下，这个文件同样可以用于环境配置和启动程序，但对单个用户有效。与profile不同的是，bash_profile 只会对当前用户生效</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常见配置文件</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/linux%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-常见配置文件"><a href="#Linux-常见配置文件" class="headerlink" title="Linux 常见配置文件"></a>Linux 常见配置文件</h1><h2 id="启动时调用的配置文件"><a href="#启动时调用的配置文件" class="headerlink" title="启动时调用的配置文件"></a>启动时调用的配置文件</h2><ol><li>/etc/inittab:系统初始化配置</li><li>/etc/rcX.d：系统运行级别</li><li>/etc/profile：系统级的环境变量和启动程序</li></ol><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><ol><li>/etc/passwd:保存账号等信息</li><li>/etc/shadow:保存密码等信息，只有root用户能访问</li><li>/etc/group:用户组</li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li>/etc/fstab：挂载配置</li></ol><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><ol><li>/etc/sysconfig/network-scripts/:网络配置(redhat和centos)</li><li>/etc/hosts:host配置</li><li>/etc/resolv.conf:DNS客户端配置文件</li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ol><li>/etc/crontab:定时任务</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 操作</title>
      <link href="2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/vim%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/01/%E8%BF%90%E7%BB%B4/linux/linux%E5%9F%BA%E7%A1%80/vim%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="块模式编辑"><a href="#块模式编辑" class="headerlink" title="块模式编辑"></a>块模式编辑</h3><p>ctrl+v 进入块模式<br>Shift+i 进入快模式下的插入</p><h3 id="复制，粘贴，剪切"><a href="#复制，粘贴，剪切" class="headerlink" title="复制，粘贴，剪切"></a>复制，粘贴，剪切</h3><p>d — 剪切操作<br>y — 复制操作<br>p — 粘贴操作<br>^ — 选中当前行，光标到行首<br>$ — 选中当前行，光标到行尾</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
